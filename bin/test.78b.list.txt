------- FILE c:\Users\Jag\Desktop\plotmap scrolling doublebuffer\test.78b.asm LEVEL 1 PASS 3
      1  28000 ????						; MACRO.H
      2  28000 ????
      3  28000 ????						; Based on the 2600 macro.h file.
      4  28000 ????						; Macros irrelevant to the 7800 have been removed, and the sleep macro 
      5  28000 ????						; has been adapted to give accurate results on the 7800.
      6  28000 ????
      7  28000 ????						; Version 1.0 2019/12/11 (based on the 2600 Version 1.05, 13/NOVEMBER/2003)
      8  28000 ????
      9  28000 ????						; Available macros...
     10  28000 ????						;   SLEEP n		 - sleep for n cycles
     11  28000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     12  28000 ????
     13  28000 ????						;-------------------------------------------------------------------------------
     14  28000 ????						; SLEEP duration
     15  28000 ????						; Original author: Thomas Jentzsch
     16  28000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     17  28000 ????						; useful for code where precise timing is required.
     18  28000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     19  28000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     20  28000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     21  28000 ????
     22  28000 ????				       MAC	sleep
     23  28000 ????			    .CYCLES    SET	{1}
     24  28000 ????
     25  28000 ????				       IF	.CYCLES < 2
     26  28000 ????				       ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     27  28000 ????				       ERR
     28  28000 ????				       ENDIF
     29  28000 ????
     30  28000 ????				       IF	.CYCLES & 1
     31  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     32  28000 ????				       nop	$80
     33  28000 ????				       ELSE
     34  28000 ????				       bit	$80
     35  28000 ????				       ENDIF
     36  28000 ????			    .CYCLES    SET	.CYCLES - 3
     37  28000 ????				       ENDIF
     38  28000 ????
     39  28000 ????				       REPEAT	.CYCLES / 2
     40  28000 ????				       nop
     41  28000 ????				       REPEND
     42  28000 ????				       ENDM		;usage: SLEEP n (n>1)
     43  28000 ????
     44  28000 ????
     45  28000 ????						;-------------------------------------------------------------------------------
     46  28000 ????						; FRACSLEEP duration
     47  28000 ????						; Based on Thomas Jentzsch's SLEEP macro, but takes cycles*2 to allow for
     48  28000 ????						; 7800 based 0.5 cycle sleep.
     49  28000 ????
     50  28000 ????				       MAC	fracsleep
     51  28000 ????			    .CYCLES    SET	{1}
     52  28000 ????
     53  28000 ????				       IF	.CYCLES < 4
     54  28000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration must be > 4"
     55  28000 ????				       ERR
     56  28000 ????				       ENDIF
     57  28000 ????				       IF	.CYCLES = 5
     58  28000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration = 5 is impossible"
     59  28000 ????				       ERR
     60  28000 ????				       ENDIF
     61  28000 ????
     62  28000 ????				       IF	.CYCLES & 1
     63  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     64  28000 ????				       nop	$0	; TIA access is 3.5 cycles
     65  28000 ????				       ELSE
     66  28000 ????				       bit	$0	; TIA access is 3.5 cycles
     67  28000 ????				       ENDIF
     68  28000 ????			    .CYCLES    SET	.CYCLES - 7
     69  28000 ????				       ENDIF
     70  28000 ????
     71  28000 ????				       IF	.CYCLES & 2
     72  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     73  28000 ????				       nop	$80
     74  28000 ????				       ELSE
     75  28000 ????				       bit	$80
     76  28000 ????				       ENDIF
     77  28000 ????			    .CYCLES    SET	.CYCLES - 6
     78  28000 ????				       ENDIF
     79  28000 ????
     80  28000 ????				       REPEAT	.CYCLES / 4
     81  28000 ????				       nop
     82  28000 ????				       REPEND
     83  28000 ????				       ENDM		;usage: FRACSLEEP n (n>1)
     84  28000 ????
     85  28000 ????
     86  28000 ????						;-------------------------------------------------------
     87  28000 ????						; SET_POINTER
     88  28000 ????						; Original author: Manuel Rotschkar
     89  28000 ????						;
     90  28000 ????						; Sets a 2 byte RAM pointer to an absolute address.
     91  28000 ????						;
     92  28000 ????						; Usage: SET_POINTER pointer, address
     93  28000 ????						; Example: SET_POINTER SpritePTR, SpriteData
     94  28000 ????						;
     95  28000 ????						; Note: Alters the accumulator, NZ flags
     96  28000 ????						; IN 1: 2 byte RAM location reserved for pointer
     97  28000 ????						; IN 2: absolute address
     98  28000 ????
     99  28000 ????				       MAC	set_pointer
    100  28000 ????			    .POINTER   SET	{1}
    101  28000 ????			    .ADDRESS   SET	{2}
    102  28000 ????
    103  28000 ????				       LDA	#<.ADDRESS	; Get Lowbyte of Address
    104  28000 ????				       STA	.POINTER	; Store in pointer
    105  28000 ????				       LDA	#>.ADDRESS	; Get Hibyte of Address
    106  28000 ????				       STA	.POINTER+1	; Store in pointer+1
    107  28000 ????
    108  28000 ????				       ENDM
    109  28000 ????
    110  28000 ????						; EOF
    111  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    112  28000 ????
    113  28000 ????						; 7800MACRO.H
    114  28000 ????
    115  28000 ????						;-------------------------------------------------------
    116  28000 ????						; BOXCOLLISIONCHECK
    117  28000 ????						; author: Mike Saarna
    118  28000 ????						;
    119  28000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    120  28000 ????						; and shape for overlap. Carry is set for collision detected, clear for none.
    121  28000 ????						; 
    122  28000 ????						; Usage: BOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    123  28000 ????						;
    124  28000 ????
    125  28000 ????				       MAC	boxcollisioncheck
    126  28000 ????			    .boxx1     SET	{1}
    127  28000 ????			    .boxy1     SET	{2}
    128  28000 ????			    .boxw1     SET	{3}
    129  28000 ????			    .boxh1     SET	{4}
    130  28000 ????			    .boxx2     SET	{5}
    131  28000 ????			    .boxy2     SET	{6}
    132  28000 ????			    .boxw2     SET	{7}
    133  28000 ????			    .boxh2     SET	{8}
    134  28000 ????
    135  28000 ????			    .DoXCollisionCheck
    136  28000 ????				       lda	.boxx1	;3
    137  28000 ????				       cmp	.boxx2	;2
    138  28000 ????				       bcs	.X1isbiggerthanX2	;2/3
    139  28000 ????			    .X2isbiggerthanX1
    140  28000 ????				       adc	#.boxw1	;2
    141  28000 ????				       cmp	.boxx2	;3
    142  28000 ????				       bcs	.DoYCollisionCheck	;3/2
    143  28000 ????				       bcc	.noboxcollision	;3
    144  28000 ????			    .X1isbiggerthanX2
    145  28000 ????				       clc		;2
    146  28000 ????				       sbc	#.boxw2	;2
    147  28000 ????				       cmp	.boxx2	;3
    148  28000 ????				       bcs	.noboxcollision	;3/2
    149  28000 ????			    .DoYCollisionCheck
    150  28000 ????				       lda	.boxy1	;3
    151  28000 ????				       cmp	.boxy2	;3
    152  28000 ????				       bcs	.Y1isbiggerthanY2	;3/2
    153  28000 ????			    .Y2isbiggerthanY1
    154  28000 ????				       adc	#.boxh1	;2
    155  28000 ????				       cmp	.boxy2	;3
    156  28000 ????				       jmp	.checkdone	;6 
    157  28000 ????			    .Y1isbiggerthanY2
    158  28000 ????				       clc		;2
    159  28000 ????				       sbc	#.boxh2	;2
    160  28000 ????				       cmp	.boxy2	;3
    161  28000 ????				       bcs	.noboxcollision	;3/2
    162  28000 ????			    .boxcollision
    163  28000 ????				       sec		;2
    164  28000 ????				       .byte	$24	; hardcoded "BIT [clc opcode]", used to skip over the following clc
    165  28000 ????			    .noboxcollision
    166  28000 ????				       clc		;2
    167  28000 ????			    .checkdone
    168  28000 ????
    169  28000 ????				       ENDM
    170  28000 ????
    171  28000 ????						; QBOXCOLLISIONCHECK
    172  28000 ????						; author: unknown
    173  28000 ????						;
    174  28000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    175  28000 ????						; and shape for overlap. Carry is CLEAR for collision detected, SET for none.
    176  28000 ????						; 
    177  28000 ????						; Usage: QBOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    178  28000 ????						;
    179  28000 ????				       MAC	qboxcollisioncheck
    180  28000 ????			    .boxx1     SET	{1}
    181  28000 ????			    .boxy1     SET	{2}
    182  28000 ????			    .boxw1     SET	{3}
    183  28000 ????			    .boxh1     SET	{4}
    184  28000 ????			    .boxx2     SET	{5}
    185  28000 ????			    .boxy2     SET	{6}
    186  28000 ????			    .boxw2     SET	{7}
    187  28000 ????			    .boxh2     SET	{8}
    188  28000 ????
    189  28000 ????				       lda	.boxx2
    190  28000 ????				       clc
    191  28000 ????				       adc	#.boxw2
    192  28000 ????				       sbc	.boxx1
    193  28000 ????				       cmp	#.boxw1+.boxw2-1
    194  28000 ????				       bcs	.qboxcollisiondone
    195  28000 ????						;if we're here, carry is clear
    196  28000 ????				       lda	.boxy2
    197  28000 ????				       adc	#.boxh2
    198  28000 ????				       sbc	.boxy1
    199  28000 ????				       cmp	#.boxh1+.boxh2-1
    200  28000 ????			    .qboxcollisiondone
    201  28000 ????				       rol		; temp for testing - invert carry...
    202  28000 ????				       eor	#1
    203  28000 ????				       ror
    204  28000 ????				       ENDM
    205  28000 ????
    206  28000 ????
    207  28000 ????				       MAC	median3
    208  28000 ????
    209  28000 ????						; A median filter (for smoothing paddle jitter)
    210  28000 ????						;   this macro takes the current paddle value, compares it to historic
    211  28000 ????						;   values, and replaces the current paddle value with the median.
    212  28000 ????						; 
    213  28000 ????						; called as:  MEDIAN3 STORAGE CURRENT
    214  28000 ????						;    where STORAGE points to 3 consecutive bytes of memory. The first 2
    215  28000 ????						;	  must be dedicated to this MEDIAN filter. The last 1 is a temp.
    216  28000 ????						;    where CURRENT is memory holding the new value you wish to compare to
    217  28000 ????						;	  the previous values, and update with the median value.
    218  28000 ????						;
    219  28000 ????						; returns: CURRENT (modified to contain median value)
    220  28000 ????						;
    221  28000 ????						; author: Mike Saarna (aka RevEng)
    222  28000 ????
    223  28000 ????			    .MedianBytes SET	{1}
    224  28000 ????			    .NewValue  SET	{2}
    225  28000 ????
    226  28000 ????				       lda	#0
    227  28000 ????				       ldy	.NewValue
    228  28000 ????				       sty	.MedianBytes+2	; put the new value in the most "recent" slot
    229  28000 ????
    230  28000 ????						; build an index from relative size comparisons between our 3 values.
    231  28000 ????				       cpy	.MedianBytes
    232  28000 ????				       rol
    233  28000 ????				       cpy	.MedianBytes+1
    234  28000 ????				       rol
    235  28000 ????				       ldy	.MedianBytes
    236  28000 ????				       cpy	.MedianBytes+1
    237  28000 ????				       rol
    238  28000 ????				       tay
    239  28000 ????
    240  28000 ????				       ldx	MedianOrderLUT,y	; convert the size-comparison index to an index to the median value
    241  28000 ????				       lda	.MedianBytes,x
    242  28000 ????				       sta	.NewValue	; we replace the new value memory with the median value
    243  28000 ????
    244  28000 ????						; then shift values from "newer" bytes to "older" bytes, leaving the 
    245  28000 ????						; newest byte (.MedianBytes+2) empty for next time.
    246  28000 ????				       lda	.MedianBytes+1
    247  28000 ????				       sta	.MedianBytes
    248  28000 ????				       lda	.MedianBytes+2
    249  28000 ????				       sta	.MedianBytes+1
    250  28000 ????				       ifnconst	MedianOrderLUT
    251  28000 ????				       jmp	MedianOrderLUTend
    252  28000 ????			    MedianOrderLUT		; converts our "comparison index" to an index to the median value
    253  28000 ????				       .byte	0	; 0  B2 < B0 < B1
    254  28000 ????				       .byte	1	; 1  B2 < B1 < B0
    255  28000 ????				       .byte	2	; 2   impossible 
    256  28000 ????				       .byte	2	; 3  B1 < B2 < B0
    257  28000 ????				       .byte	2	; 4  B0 < B2 < B1
    258  28000 ????				       .byte	2	; 5   impossible 
    259  28000 ????				       .byte	1	; 6  B0 < B1 < B2
    260  28000 ????				       .byte	0	; 7  B1 < B0 < B2
    261  28000 ????			    MedianOrderLUTend
    262  28000 ????				       endif
    263  28000 ????				       ENDM
    264  28000 ????
    265  28000 ????				       MAC	plotsprite
    266  28000 ????
    267  28000 ????						; A macro version of the plotsprite command. 
    268  28000 ????						; This trades off rom space for speed.
    269  28000 ????						; It also doesn't check if the visible screen is displayed or not.
    270  28000 ????						; It has no training wheels. It is all rusty sharp edges.
    271  28000 ????
    272  28000 ????			    .GFXLabel  SET	{1}
    273  28000 ????			    .Palette   SET	{2}	; constant
    274  28000 ????			    .SpriteX   SET	{3}	; variable
    275  28000 ????			    .SpriteY   SET	{4}	; variable
    276  28000 ????			    .ByteOffset SET	{5}	; variable 
    277  28000 ????
    278  28000 ????				       lda	.SpriteY
    279  28000 ????				       lsr
    280  28000 ????				       lsr
    281  28000 ????				       asr	#%11111110	; ensure carry is clear
    282  28000 ????				       if	WZONEHEIGHT = 16
    283  28000 ????				       asr	#%11111110	; ensure carry is clear
    284  28000 ????				       endif
    285  28000 ????
    286  28000 ????				       tax
    287  28000 ????
    288  28000 ????				       lda	DLPOINTL,x	; setup DL pointer for this zone
    289  28000 ????				       sta	dlpnt
    290  28000 ????				       lda	DLPOINTH,x	; setup DL pointer for this zone
    291  28000 ????				       sta	dlpnt+1
    292  28000 ????
    293  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    294  28000 ????
    295  28000 ????				       lda	.ByteOffset
    296  28000 ????				       if	{1}_width = 2
    297  28000 ????				       asl
    298  28000 ????				       endif
    299  28000 ????				       if	{1}_width = 3
    300  28000 ????				       asl
    301  28000 ????				       adc	.ByteOffset
    302  28000 ????				       endif
    303  28000 ????				       if	{1}_width = 4
    304  28000 ????				       asl
    305  28000 ????				       asl
    306  28000 ????				       endif
    307  28000 ????				       if	{1}_width = 5
    308  28000 ????				       asl
    309  28000 ????				       asl
    310  28000 ????				       adc	.ByteOffset
    311  28000 ????				       endif
    312  28000 ????				       if	{1}_width = 6
    313  28000 ????				       asl
    314  28000 ????				       adc	.ByteOffset
    315  28000 ????				       asl
    316  28000 ????				       endif
    317  28000 ????				       if	{1}_width = 7
    318  28000 ????				       asl
    319  28000 ????				       adc	.ByteOffset
    320  28000 ????				       asl
    321  28000 ????				       adc	.ByteOffset
    322  28000 ????				       endif
    323  28000 ????				       if	{1}_width = 8
    324  28000 ????				       asl
    325  28000 ????				       asl
    326  28000 ????				       asl
    327  28000 ????				       endif
    328  28000 ????				       if	{1}_width = 9
    329  28000 ????				       asl
    330  28000 ????				       asl
    331  28000 ????				       asl
    332  28000 ????				       adc	.ByteOffset
    333  28000 ????				       endif
    334  28000 ????				       if	{1}_width = 10
    335  28000 ????				       asl
    336  28000 ????				       asl
    337  28000 ????				       adc	.ByteOffset
    338  28000 ????				       asl
    339  28000 ????				       endif
    340  28000 ????				       if	{1}_width = 11
    341  28000 ????				       asl
    342  28000 ????				       asl
    343  28000 ????				       adc	.ByteOffset
    344  28000 ????				       asl
    345  28000 ????				       adc	.ByteOffset
    346  28000 ????				       endif
    347  28000 ????				       if	{1}_width = 12
    348  28000 ????				       asl
    349  28000 ????				       adc	.ByteOffset
    350  28000 ????				       asl
    351  28000 ????				       asl
    352  28000 ????				       endif
    353  28000 ????				       if	{1}_width = 13
    354  28000 ????				       asl
    355  28000 ????				       adc	.ByteOffset
    356  28000 ????				       asl
    357  28000 ????				       asl
    358  28000 ????				       adc	.ByteOffset
    359  28000 ????				       endif
    360  28000 ????				       if	{1}_width = 14
    361  28000 ????				       asl
    362  28000 ????				       adc	.ByteOffset
    363  28000 ????				       asl
    364  28000 ????				       adc	.ByteOffset
    365  28000 ????				       asl
    366  28000 ????				       endif
    367  28000 ????
    368  28000 ????				       adc	#<.GFXLabel	; carry is clear via previous asl or asr
    369  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    370  28000 ????
    371  28000 ????				       iny
    372  28000 ????
    373  28000 ????				       lda	#({1}_mode | %01000000)
    374  28000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    375  28000 ????
    376  28000 ????				       iny
    377  28000 ????
    378  28000 ????				       lda	.SpriteY
    379  28000 ????				       and	#(WZONEHEIGHT - 1)
    380  28000 ????				       cmp	#1	; clear carry if our sprite is just in this zone
    381  28000 ????				       ora	#>.GFXLabel
    382  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    383  28000 ????
    384  28000 ????				       iny
    385  28000 ????
    386  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    387  28000 ????				       sta	(dlpnt),y	; #4 - palette|width
    388  28000 ????
    389  28000 ????				       iny
    390  28000 ????
    391  28000 ????				       lda	.SpriteX
    392  28000 ????				       sta	(dlpnt),y	; #5 - x object position
    393  28000 ????
    394  28000 ????				       iny
    395  28000 ????				       sty	dlend,x
    396  28000 ????
    397  28000 ????				       ifconst	ALWAYSTERMINATE
    398  28000 ????				       iny
    399  28000 ????				       lda	#0
    400  28000 ????				       sta	(dlpnt),y
    401  28000 ????				       endif
    402  28000 ????
    403  28000 ????				       bcc	.PLOTSPRITEend
    404  28000 ????
    405  28000 ????				       inx		; next zone
    406  28000 ????
    407  28000 ????				       lda	DLPOINTL,x	; setup DL pointer for this zone
    408  28000 ????				       sta	dlpnt
    409  28000 ????				       lda	DLPOINTH,x	; setup DL pointer for this zone
    410  28000 ????				       sta	dlpnt+1
    411  28000 ????
    412  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    413  28000 ????
    414  28000 ????				       lda	.ByteOffset
    415  28000 ????				       if	{1}_width = 1
    416  28000 ????				       clc
    417  28000 ????				       endif
    418  28000 ????				       if	{1}_width = 2
    419  28000 ????				       asl		; carry clear
    420  28000 ????				       endif
    421  28000 ????				       if	{1}_width = 3
    422  28000 ????				       asl		; carry clear
    423  28000 ????				       adc	.ByteOffset
    424  28000 ????				       endif
    425  28000 ????				       if	{1}_width = 4
    426  28000 ????				       asl		; carry clear
    427  28000 ????				       asl
    428  28000 ????				       endif
    429  28000 ????				       if	{1}_width = 5
    430  28000 ????				       asl		; carry clear
    431  28000 ????				       asl
    432  28000 ????				       adc	.ByteOffset
    433  28000 ????				       endif
    434  28000 ????				       if	{1}_width = 6
    435  28000 ????				       asl		; carry clear
    436  28000 ????				       adc	.ByteOffset
    437  28000 ????				       asl
    438  28000 ????				       endif
    439  28000 ????				       if	{1}_width = 7
    440  28000 ????				       asl		; carry clear
    441  28000 ????				       adc	.ByteOffset
    442  28000 ????				       asl
    443  28000 ????				       endif
    444  28000 ????				       if	{1}_width = 8
    445  28000 ????				       asl		; carry clear
    446  28000 ????				       asl
    447  28000 ????				       asl
    448  28000 ????				       endif
    449  28000 ????				       if	{1}_width = 9
    450  28000 ????				       asl		; carry clear
    451  28000 ????				       asl
    452  28000 ????				       asl
    453  28000 ????				       adc	.ByteOffset
    454  28000 ????				       endif
    455  28000 ????				       if	{1}_width = 10
    456  28000 ????				       asl		; carry clear
    457  28000 ????				       asl
    458  28000 ????				       adc	.ByteOffset
    459  28000 ????				       asl
    460  28000 ????				       endif
    461  28000 ????				       if	{1}_width = 11
    462  28000 ????				       asl		; carry clear
    463  28000 ????				       asl
    464  28000 ????				       adc	.ByteOffset
    465  28000 ????				       asl
    466  28000 ????				       adc	.ByteOffset
    467  28000 ????				       endif
    468  28000 ????				       if	{1}_width = 12
    469  28000 ????				       asl		; carry clear
    470  28000 ????				       adc	.ByteOffset
    471  28000 ????				       asl
    472  28000 ????				       asl
    473  28000 ????				       endif
    474  28000 ????				       if	{1}_width = 13
    475  28000 ????				       asl		; carry clear
    476  28000 ????				       adc	.ByteOffset
    477  28000 ????				       asl
    478  28000 ????				       asl
    479  28000 ????				       adc	.ByteOffset
    480  28000 ????				       endif
    481  28000 ????				       if	{1}_width = 14
    482  28000 ????				       asl		; carry clear
    483  28000 ????				       adc	.ByteOffset
    484  28000 ????				       asl
    485  28000 ????				       adc	.ByteOffset
    486  28000 ????				       asl
    487  28000 ????				       endif
    488  28000 ????
    489  28000 ????				       adc	#<.GFXLabel
    490  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    491  28000 ????
    492  28000 ????				       iny
    493  28000 ????
    494  28000 ????				       lda	#({1}_mode | %01000000)
    495  28000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    496  28000 ????
    497  28000 ????				       iny
    498  28000 ????
    499  28000 ????				       lda	.SpriteY
    500  28000 ????				       and	#(WZONEHEIGHT - 1)
    501  28000 ????				       ora	#>(.GFXLabel - (WZONEHEIGHT * 256))	; start in the dma hole
    502  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    503  28000 ????
    504  28000 ????				       iny
    505  28000 ????
    506  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    507  28000 ????				       sta	(dlpnt),y	; #4 - palette|width
    508  28000 ????
    509  28000 ????				       iny
    510  28000 ????
    511  28000 ????				       lda	.SpriteX
    512  28000 ????				       sta	(dlpnt),y	; #5 - x object position
    513  28000 ????
    514  28000 ????				       iny
    515  28000 ????				       sty	dlend,x
    516  28000 ????
    517  28000 ????				       ifconst	ALWAYSTERMINATE
    518  28000 ????				       iny
    519  28000 ????				       lda	#0
    520  28000 ????				       sta	(dlpnt),y
    521  28000 ????				       endif
    522  28000 ????
    523  28000 ????			    .PLOTSPRITEend
    524  28000 ????				       ENDM
    525  28000 ????
    526  28000 ????				       MAC	sizeof
    527  28000 ????
    528  28000 ????						; echo's the size difference between the current address and the
    529  28000 ????						; a label that was passed as an argument. This is a quick way to
    530  28000 ????						; determine the size of a structure.
    531  28000 ????
    532  28000 ????			    .NAME      SETSTR	{1}
    533  28000 ????				       echo	" The Size of",.NAME,"is:",[* - {1}]d,[* - {2}]d,"bytes."
    534  28000 ????				       ENDM
    535  28000 ????
    536  28000 ????						;
    537  28000 ????						; speakjet.inc
    538  28000 ????						;
    539  28000 ????						;
    540  28000 ????						; AtariVox Speech Synth Driver
    541  28000 ????						;
    542  28000 ????						; By Alex Herbert, 2004
    543  28000 ????						;
    544  28000 ????
    545  28000 ????
    546  28000 ????
    547  28000 ????
    548  28000 ????						; Constants
    549  28000 ????
    550  28000 ????
    551  28000 ????		00 01	    SERIAL_OUTMASK equ	$01
    552  28000 ????		00 02	    SERIAL_RDYMASK equ	$02
    553  28000 ????
    554  28000 ????
    555  28000 ????
    556  28000 ????						; Macros
    557  28000 ????
    558  28000 ????				       mac	spkout
    559  28000 ????
    560  28000 ????						; check buffer-full status
    561  28000 ????				       lda	SWCHA
    562  28000 ????				       and	#SERIAL_RDYMASK
    563  28000 ????				       beq	.speech_done
    564  28000 ????
    565  28000 ????						; get next speech byte
    566  28000 ????				       ldy	#$00
    567  28000 ????				       lda	(speech_addr),y
    568  28000 ????
    569  28000 ????						; invert data and check for end of string
    570  28000 ????				       eor	#$ff
    571  28000 ????						;sta BACKGRND ; debug - uncomment to flash the background color with vox data
    572  28000 ????				       beq	.speech_done
    573  28000 ????				       sta	{1}
    574  28000 ????
    575  28000 ????						; increment speech pointer
    576  28000 ????				       inc	speech_addr
    577  28000 ????				       bne	.incaddr_skip
    578  28000 ????				       inc	speech_addr+1
    579  28000 ????			    .incaddr_skip
    580  28000 ????
    581  28000 ????						; output byte as serial data
    582  28000 ????
    583  28000 ????				       sec		; start bit
    584  28000 ????			    .byteout_loop
    585  28000 ????						; put carry flag into bit 0 of SWACNT, preserving other bits
    586  28000 ????				       lda	SWACNT	; 4
    587  28000 ????				       and	#$fe	; 2 6
    588  28000 ????				       adc	#$00	; 2 8
    589  28000 ????				       sta	SWACNT	; 4 12
    590  28000 ????
    591  28000 ????						; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
    592  28000 ????				       cpy	#$09	; 2 14
    593  28000 ????				       beq	.speech_done	; 2 16
    594  28000 ????				       iny		; 2 18
    595  28000 ????
    596  28000 ????						; the 7800 is 1.5x faster than the 2600. Waste more cycles here
    597  28000 ????						; to match the original baud rate...
    598  28000 ????						;ldx	  #$07 ; 2600
    599  28000 ????				       ldx	#$0D
    600  28000 ????
    601  28000 ????			    .delay_loop
    602  28000 ????				       dex		; 
    603  28000 ????				       bne	.delay_loop	; 36 54
    604  28000 ????
    605  28000 ????						; shift next data bit into carry
    606  28000 ????				       lsr	{1}	; 5 59
    607  28000 ????
    608  28000 ????						; and loop (branch always taken)
    609  28000 ????				       bpl	.byteout_loop	; 3 62 cycles for loop
    610  28000 ????
    611  28000 ????			    .speech_done
    612  28000 ????
    613  28000 ????				       endm
    614  28000 ????
    615  28000 ????
    616  28000 ????				       mac	speak
    617  28000 ????
    618  28000 ????				       lda	#<{1}
    619  28000 ????				       sta	speech_addr
    620  28000 ????				       lda	#>{1}
    621  28000 ????				       sta	speech_addr+1
    622  28000 ????
    623  28000 ????				       endm
    624  28000 ????
    625  28000 ????
    626  28000 ????
    627  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    628  28000 ????
    629  28000 ????				       processor	6502
    630  28000 ????
------- FILE 7800basic.h LEVEL 2 PASS 3
      0  28000 ????				       include	"7800basic.h"
      1  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  28000 ????
      3  28000 ????				       processor	6502
------- FILE 7800.h LEVEL 3 PASS 3
      0  28000 ????				       include	"7800.h"
      1  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  28000 ????
      3  28000 ????						; 7800.h
      4  28000 ????						; Version 1.0, 2019/12/13
      5  28000 ????
      6  28000 ????						; This file defines hardware registers and memory mapping for the
      7  28000 ????						; Atari 7800. It is distributed as a companion machine-specific support package
      8  28000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  28000 ????						; available at https://github.com/dasm-assembler/dasm
     10  28000 ????
     11  28000 ????
     12  28000 ????						; ******************** 7800 Hardware Addresses ***************************
     13  28000 ????						;
     14  28000 ????						;	 MEMORY MAP USAGE OF THE 7800
     15  28000 ????						;
     16  28000 ????						;	  00 -   1F	TIA REGISTERS
     17  28000 ????						;	  20 -   3F	MARIA REGISTERS
     18  28000 ????						;	  40 -   FF	RAM block 0 (zero page)
     19  28000 ????						;	 100 -  11F	TIA   (mirror of 0000-001f)
     20  28000 ????						;	 120 -  13F	MARIA (mirror of 0020-003f)
     21  28000 ????						;	 140 -  1FF	RAM block 1 (stack)
     22  28000 ????						;	 200 -  21F	TIA   (mirror of 0000-001f)
     23  28000 ????						;	 220 -  23F	MARIA (mirror of 0020-003f)
     24  28000 ????						;	 240 -  27F	???
     25  28000 ????						;	 280 -  2FF	RIOT I/O ports and timers
     26  28000 ????						;	 300 -  31F	TIA   (mirror of 0000-001f)
     27  28000 ????						;	 320 -  33F	MARIA (mirror of 0020-003f)
     28  28000 ????						;	 340 -  3FF	???
     29  28000 ????						;	 400 -  47F	unused address space
     30  28000 ????						;	 480 -  4FF	RIOT RAM
     31  28000 ????						;	 500 -  57F	unused address space
     32  28000 ????						;	 580 -  5FF	RIOT RAM (mirror of 0480-04ff)
     33  28000 ????						;	 600 - 17FF	unused address space
     34  28000 ????						;	1800 - 203F	RAM
     35  28000 ????						;	2040 - 20FF	RAM block 0 (mirror of 0000-001f)
     36  28000 ????						;	2100 - 213F	RAM
     37  28000 ????						;	2140 - 21FF	RAM block 1 (mirror of 0140-01ff)
     38  28000 ????						;	2200 - 27FF	RAM
     39  28000 ????						;	2800 - 2FFF	unavailable to external devices (bios bus-conflict)
     40  28000 ????						;	3000 - 3FFF	unused address space
     41  28000 ????						;	4000 - FF7F	potential cartridge address space
     42  28000 ????						;	FF80 - FFF9	RESERVED FOR ENCRYPTION
     43  28000 ????						;	FFFA - FFFF	6502 VECTORS
     44  28000 ????
     45  28000 ????
     46  28000 ????						;****** 00-1F ********* TIA REGISTERS ******************
     47  28000 ????
     48  28000 ????		00 01	    INPTCTRL   =	$01	;Input control. In same address space as TIA. write-only
     49  28000 ????		00 01	    VBLANK     =	$01	;VBLANK. D7=1:dump paddle caps to ground.     write-only
     50  28000 ????		00 02	    _WSYNC     =	$02	;Wait for HSync			       write-only
     51  28000 ????		00 03	    _RSYNC     =	$03	;Reset HSync				       write-only
     52  28000 ????		00 08	    INPT0      =	$08	;Paddle Control Input 0		       read-only
     53  28000 ????		00 09	    INPT1      =	$09	;Paddle Control Input 1		       read-only
     54  28000 ????		00 0a	    INPT2      =	$0A	;Paddle Control Input 2		       read-only
     55  28000 ????		00 0b	    INPT3      =	$0B	;Paddle Control Input 3		       read-only
     56  28000 ????
     57  28000 ????						; ** some common alternate names for INPT0/1/2/3
     58  28000 ????		00 08	    INPT4B     =	$08	;Joystick 0 Fire 1			       read-only
     59  28000 ????		00 09	    INPT4A     =	$09	;Joystick 0 Fire 1			       read-only
     60  28000 ????		00 0a	    INPT5B     =	$0A	;Joystick 1 Fire 0			       read-only
     61  28000 ????		00 0b	    INPT5A     =	$0B	;Joystick 1 Fire 1			       read-only
     62  28000 ????		00 08	    INPT4R     =	$08	;Joystick 0 Fire 1			       read-only
     63  28000 ????		00 09	    INPT4L     =	$09	;Joystick 0 Fire 1			       read-only
     64  28000 ????		00 0a	    INPT5R     =	$0A	;Joystick 1 Fire 0			       read-only
     65  28000 ????		00 0b	    INPT5L     =	$0B	;Joystick 1 Fire 1			       read-only
     66  28000 ????
     67  28000 ????		00 0c	    INPT4      =	$0C	;Player 0 Fire Button Input		       read-only
     68  28000 ????		00 0d	    INPT5      =	$0D	;Player 1 Fire Button Input		       read-only
     69  28000 ????
     70  28000 ????		00 15	    AUDC0      =	$15	;Audio Control Channel   0		       write-only
     71  28000 ????		00 16	    AUDC1      =	$16	;Audio Control Channel   1		       write-only
     72  28000 ????		00 17	    AUDF0      =	$17	;Audio Frequency Channel 0		       write-only
     73  28000 ????		00 18	    AUDF1      =	$18	;Audio Frequency Channel 1		       write-only
     74  28000 ????		00 19	    AUDV0      =	$19	;Audio Volume Channel	  0		       write-only
     75  28000 ????		00 1a	    AUDV1      =	$1A	;Audio Volume Channel	  1		       write-only
     76  28000 ????
     77  28000 ????						;****** 20-3F ********* MARIA REGISTERS ***************
     78  28000 ????
     79  28000 ????		00 20	    BACKGRND   =	$20	;Background Color			       write-only
     80  28000 ????		00 21	    P0C1       =	$21	;Palette 0 - Color 1			       write-only
     81  28000 ????		00 22	    P0C2       =	$22	;Palette 0 - Color 2			       write-only
     82  28000 ????		00 23	    P0C3       =	$23	;Palette 0 - Color 3			       write-only
     83  28000 ????		00 24	    WSYNC      =	$24	;Wait For Sync 			       write-only
     84  28000 ????		00 25	    P1C1       =	$25	;Palette 1 - Color 1			       write-only
     85  28000 ????		00 26	    P1C2       =	$26	;Palette 1 - Color 2			       write-only
     86  28000 ????		00 27	    P1C3       =	$27	;Palette 1 - Color 3			       write-only
     87  28000 ????		00 28	    MSTAT      =	$28	;Maria Status				       read-only
     88  28000 ????		00 29	    P2C1       =	$29	;Palette 2 - Color 1			       write-only
     89  28000 ????		00 2a	    P2C2       =	$2A	;Palette 2 - Color 2			       write-only
     90  28000 ????		00 2b	    P2C3       =	$2B	;Palette 2 - Color 3			       write-only
     91  28000 ????		00 2c	    DPPH       =	$2C	;Display List List Pointer High	       write-only
     92  28000 ????		00 2d	    P3C1       =	$2D	;Palette 3 - Color 1			       write-only
     93  28000 ????		00 2e	    P3C2       =	$2E	;Palette 3 - Color 2			       write-only
     94  28000 ????		00 2f	    P3C3       =	$2F	;Palette 3 - Color 3			       write-only
     95  28000 ????		00 30	    DPPL       =	$30	;Display List List Pointer Low 	       write-only
     96  28000 ????		00 31	    P4C1       =	$31	;Palette 4 - Color 1			       write-only
     97  28000 ????		00 32	    P4C2       =	$32	;Palette 4 - Color 2			       write-only
     98  28000 ????		00 33	    P4C3       =	$33	;Palette 4 - Color 3			       write-only
     99  28000 ????		00 34	    CHARBASE   =	$34	;Character Base Address		       write-only
    100  28000 ????		00 34	    CHBASE     =	$34	;Character Base Address		       write-only
    101  28000 ????		00 35	    P5C1       =	$35	;Palette 5 - Color 1			       write-only
    102  28000 ????		00 36	    P5C2       =	$36	;Palette 5 - Color 2			       write-only
    103  28000 ????		00 37	    P5C3       =	$37	;Palette 5 - Color 3			       write-only
    104  28000 ????		00 38	    OFFSET     =	$38	;Unused - Store zero here		       write-only
    105  28000 ????		00 39	    P6C1       =	$39	;Palette 6 - Color 1			       write-only
    106  28000 ????		00 3a	    P6C2       =	$3A	;Palette 6 - Color 2			       write-only
    107  28000 ????		00 3b	    P6C3       =	$3B	;Palette 6 - Color 3			       write-only
    108  28000 ????		00 3c	    CTRL       =	$3C	;Maria Control Register		       write-only
    109  28000 ????		00 3d	    P7C1       =	$3D	;Palette 7 - Color 1			       write-only
    110  28000 ????		00 3e	    P7C2       =	$3E	;Palette 7 - Color 2			       write-only
    111  28000 ????		00 3f	    P7C3       =	$3F	;Palette 7 - Color 3			       write-only
    112  28000 ????
    113  28000 ????
    114  28000 ????						;****** 280-2FF ******* PIA PORTS AND TIMERS ************
    115  28000 ????
    116  28000 ????		02 80	    SWCHA      =	$280	;P0+P1 Joystick Directional Input	       read-write
    117  28000 ????		02 81	    CTLSWA     =	$281	;I/O Control for SCHWA 		       read-write
    118  28000 ????		02 81	    SWACNT     =	$281	;VCS name for above			       read-write
    119  28000 ????		02 82	    SWCHB      =	$282	;Console Switches			       read-write
    120  28000 ????		02 83	    CTLSWB     =	$283	;I/O Control for SCHWB 		       read-write
    121  28000 ????		02 83	    SWBCNT     =	$283	;VCS name for above			       read-write
    122  28000 ????
    123  28000 ????		02 84	    INTIM      =	$284	;Interval Timer Read			       read-only
    124  28000 ????		02 94	    TIM1T      =	$294	;Set 1    CLK Interval (838   nsec/interval)  write-only
    125  28000 ????		02 95	    TIMINT     =	$295	;Interval Timer Interrupt		       read-only
    126  28000 ????		02 95	    TIM8T      =	$295	;Set 8    CLK Interval (6.7   usec/interval)  write-only
    127  28000 ????		02 96	    TIM64T     =	$296	;Set 64   CLK Interval (63.6  usec/interval)  write-only
    128  28000 ????		02 97	    T1024T     =	$297	;Set 1024 CLK Interval (858.2 usec/interval)  write-only
    129  28000 ????		02 9e	    TIM64TI    =	$29E	;Interrupt timer 64T			       write-only
    130  28000 ????
    131  28000 ????						;XM
    132  28000 ????		04 70	    XCTRL      =	$470	; 7=YM2151 6=RAM@6k 5=RAM@4k 4=pokey@450 3=hsc 2=cart 1=RoF_bank1 0=RoF_bank2
    133  28000 ????		04 70	    XCTRL1     =	$470
    134  28000 ????		04 78	    XCTRL2     =	$478
    135  28000 ????		04 7c	    XCTRL3     =	$47c
    136  28000 ????		04 71	    XCTRL4     =	$471
    137  28000 ????		04 72	    XCTRL5     =	$472
    138  28000 ????
    139  28000 ????						; Pokey register relative locations, since its base may be different
    140  28000 ????						; depending on the hardware.
    141  28000 ????		00 00	    PAUDF0     =	$0	; extra audio channels and frequencies
    142  28000 ????		00 01	    PAUDC0     =	$1
    143  28000 ????		00 02	    PAUDF1     =	$2
    144  28000 ????		00 03	    PAUDC1     =	$3
    145  28000 ????		00 04	    PAUDF2     =	$4
    146  28000 ????		00 05	    PAUDC2     =	$5
    147  28000 ????		00 06	    PAUDF3     =	$6
    148  28000 ????		00 07	    PAUDC3     =	$7
    149  28000 ????		00 08	    PAUDCTL    =	$8	; Audio Control
    150  28000 ????		00 09	    PSTIMER    =	$9
    151  28000 ????		00 0a	    PRANDOM    =	$A	; 17 bit polycounter pseudo random
    152  28000 ????		00 0f	    PSKCTL     =	$F	; Serial Port control
------- FILE 7800basic.h
------- FILE 7800basic_variable_redefs.h LEVEL 3 PASS 3
      0  28000 ????				       include	"7800basic_variable_redefs.h"
      1  28000 ????						; This file contains variable mapping and other information for the current project.
      2  28000 ????
      3  28000 ????		00 00	    tiles2_mode =	$00
      4  28000 ????		00 1e	    tiles2_width_twoscompliment =	$1e
      5  28000 ????		00 02	    tiles2_width =	$02
      6  28000 ????		00 00	    tiles0_mode =	$00
      7  28000 ????		00 1e	    tiles0_width_twoscompliment =	$1e
      8  28000 ????		00 02	    tiles0_width =	$02
      9  28000 ????		00 00	    enemySprite_mode =	$00
     10  28000 ????		00 1e	    enemySprite_width_twoscompliment =	$1e
     11  28000 ????		00 02	    enemySprite_width =	$02
     12  28000 ????		00 00	    playerSprite_mode =	$00
     13  28000 ????		00 1e	    playerSprite_width_twoscompliment =	$1e
     14  28000 ????		00 02	    playerSprite_width =	$02
     15  28000 ????		00 b8	    tiles2_color3 =	$b8
     16  28000 ????		00 b6	    tiles2_color2 =	$b6
     17  28000 ????		00 b3	    tiles2_color1 =	$b3
     18  28000 ????		00 00	    tiles2_color0 =	$00
     19  28000 ????		00 00	    tiles0_color1 =	0
     20  28000 ????		00 00	    tiles0_color0 =	$00
     21  28000 ????		00 42	    enemySprite_color1 =	$42
     22  28000 ????		00 00	    enemySprite_color0 =	$00
     23  28000 ????		00 6c	    playerSprite_color3 =	$6c
     24  28000 ????		00 57	    playerSprite_color2 =	$57
     25  28000 ????		00 69	    playerSprite_color1 =	$69
     26  28000 ????		00 00	    playerSprite_color0 =	$00
     27  28000 ????		00 01	    DOUBLEBUFFER =	1
     28  28000 ????		00 f8	    enemy1Y    =	s
     29  28000 ????		00 f7	    enemy1XInt =	r
     30  28000 ????		00 f6	    enemy1Visible =	q
     31  28000 ????		00 f6	    enemy1X    =	q
     32  28000 ????		00 f5	    windowX    =	p
     33  28000 ????
     34  28000 ????		00 f4	    scrollCounter =	o
     35  28000 ????
     36  28000 ????		00 ef	    playerVelocityXFrac =	j
     37  28000 ????
     38  28000 ????		00 ee	    playerVelocityXInt =	i
     39  28000 ????		00 ee	    playerVelocityX =	i
     40  28000 ????		00 ed	    playerVelocityYFrac =	h
     41  28000 ????
     42  28000 ????		00 ec	    playerVelocityYInt =	g
     43  28000 ????		00 ec	    playerVelocityY =	g
     44  28000 ????		00 07	    tileWidthMask =	%00000111
     45  28000 ????
     46  28000 ????		00 0f	    tileHeightMask =	%00001111
     47  28000 ????
     48  28000 ????		00 08	    tileWidth  =	8
     49  28000 ????
     50  28000 ????		00 10	    tileHeight =	16
     51  28000 ????
     52  28000 ????		00 07	    playerWidthMinusOne =	7
     53  28000 ????
     54  28000 ????		00 0f	    playerHeightMinusOne =	15
     55  28000 ????
     56  28000 ????		00 20	    screenOffsetY =	16 * 2
     57  28000 ????
     58  28000 ????		ff ff ff f8 screenOffsetX =	- 8
     59  28000 ????
     60  28000 ????		00 ea	    charValue  =	e
     61  28000 ????
     62  28000 ????		00 f2	    mapSize    =	m
     63  28000 ????
     64  28000 ????		00 f1	    fineScrollX =	l
     65  28000 ????
     66  28000 ????		00 f0	    coarseScrollX =	k
     67  28000 ????
     68  28000 ????		00 e9	    playerYFrac =	d
     69  28000 ????		00 e8	    playerYInt =	c
     70  28000 ????		00 e8	    playerY    =	c
     71  28000 ????		00 e7	    playerXFrac =	b
     72  28000 ????		00 e6	    playerXInt =	a
     73  28000 ????		00 e6	    playerX    =	a
     74  28000 ????		40 00	    tileMap    =	$4000
     75  28000 ????
     76  28000 ????		00 06	    bgTile     =	# < ( tiles2 + 0 )
     77  28000 ????
     78  28000 ????		00 e0	    SCREENHEIGHT =	224
     79  28000 ????		00 01	    DOUBLEWIDE =	1
     80  28000 ????		00 10	    ZONEHEIGHT =	16
     81  28000 ????		00 01	    NTSC       =	1
     82  28000 ????		00 01	    SGRAM      =	1
     83  28000 ????		00 08	    bankswitchmode =	8
     84  28000 ????		00 01	    ROM128K    =	1
------- FILE 7800basic.h
      6  28000 ????
      7  28000 ????						;************ 7800 overall RAM map **************
      8  28000 ????
      9  28000 ????						;	   40-FF	 zero page RAM
     10  28000 ????						;	  140-1FF	 RAM (stack)
     11  28000 ????						;	 1800-203F	 RAM
     12  28000 ????						;	 2100-213F	 RAM
     13  28000 ????						;	 2200-27FF	 RAM
     14  28000 ????
     15  28000 ????						;************ 7800basic RAM usage map **************
     16  28000 ????
     17  28000 ????						;	   40-FF	 numerous defines, listed below
     18  28000 ????						;	  140-1FF	 RAM (stack)
     19  28000 ????
     20  28000 ????						;	 1800-187F	 DLL  (1800-18DF with page flipping enabled)
     21  28000 ????						;	 1880-1FFF	 DLs  (18E0-1FFF with page flipping enabled)
     22  28000 ????
     23  28000 ????						;	 2000-203F	 Reserved
     24  28000 ????						;	 2100-213F	 Reserved
     25  28000 ????						;	 2200-27FF	 Free
     26  28000 ????
     27  28000 ????		1f e0	    eeprombuffer =	$1FE0
     28  28000 ????		18 00	    DLLMEM     =	$1800
     29  28000 ????		00 70	    DBOFFSET   =	$70	; $E0 length DL is /2 for double-buffering
     30  28000 ????
     31  28000 ????			   -	       ifconst	PLOTVALUEPAGE
     32  28000 ????			   -VALBUFFER  =	(PLOTVALUEPAGE*256)
     33  28000 ????				       else
     34  28000 ????		20 00	    VALBUFFER  =	$2000	; to $203F  ** never let VALBUFFER straddle pages
     35  28000 ????				       endif
     36  28000 ????
     37  28000 ????
     38  28000 ????		21 00	    pausestate =	$2100
     39  28000 ????		21 01	    dlzero     =	$2101	; zero to force end of $2100 DL, which we use in vblank and overscan
     40  28000 ????		21 02	    sINPT1     =	$2102	; save register for joy button joy0
     41  28000 ????		21 03	    sINPT3     =	$2103	; save register for joy button joy1
     42  28000 ????		21 04	    currentbank =	$2104
     43  28000 ????
     44  28000 ????		21 05	    currentrambank =	$2105
     45  28000 ????		21 06	    charactermode =	$2106
     46  28000 ????		21 07	    sCTRL      =	$2107
     47  28000 ????		21 08	    pokeydetected =	$2108
     48  28000 ????		21 09	    paldetected =	$2109
     49  28000 ????		21 0a	    avoxdetected =	$210A
     50  28000 ????		21 0b	    sCHARBASE  =	$210B	; save register for CHARBASE
     51  28000 ????
     52  28000 ????		21 0c	    hsdevice   =	$210C
     53  28000 ????		21 0d	    hsdifficulty =	$210D
     54  28000 ????		21 0e	    hserror    =	$210E
     55  28000 ????		21 0f	    hsgameslot =	$210F
     56  28000 ????		21 10	    hsnewscoreline =	$2110
     57  28000 ????		21 11	    hsnewscorerank =	$2111
     58  28000 ????		21 12	    HSRAMTable =	$2112	; to $212F (30 bytes) Format: III*5, SSS*5
     59  28000 ????		21 12	    HSRAMInitials =	$2112	; see above
     60  28000 ????		21 21	    HSRAMScores =	$2121	; see above
     61  28000 ????
     62  28000 ????		21 31	    ssCTRL     =	$2131
     63  28000 ????		21 32	    ssCHARBASE =	$2132
     64  28000 ????		21 33	    hsdisplaymode =	$2133
     65  28000 ????		21 34	    gamedifficulty =	$2134
     66  28000 ????		21 35	    hsinitialpos =	$2135
     67  28000 ????		21 36	    hsinitialhold =	$2136
     68  28000 ????		21 37	    hscursorx  =	$2137
     69  28000 ????		21 38	    hsjoydebounce =	$2138
     70  28000 ????		21 39	    hsswcha    =	$2139
     71  28000 ????		21 3a	    hsinpt1    =	$213A
     72  28000 ????		21 3b	    hscolorchaseindex =	$213B
     73  28000 ????		21 3c	    visibleDLLstart =	$213C
     74  28000 ????		21 3d	    overscanDLLstart =	$213D
     75  28000 ????		21 3e	    frameslost =	$213E
     76  28000 ????
     77  28000 ????
     78  28000 ????		00 40	    rand       =	$40
     79  28000 ????		00 41	    rand16     =	$41
     80  28000 ????		00 42	    temp1      =	$42
     81  28000 ????		00 43	    temp2      =	$43
     82  28000 ????		00 44	    temp3      =	$44
     83  28000 ????		00 45	    temp4      =	$45
     84  28000 ????		00 46	    temp5      =	$46
     85  28000 ????		00 47	    temp6      =	$47
     86  28000 ????		00 48	    temp7      =	$48
     87  28000 ????		00 49	    temp8      =	$49
     88  28000 ????		00 4a	    temp9      =	$4a
     89  28000 ????
     90  28000 ????		00 4b	    pokeybase  =	$4b
     91  28000 ????		00 4b	    pokeybaselo =	$4b
     92  28000 ????		00 4c	    pokeybasehi =	$4c
     93  28000 ????
     94  28000 ????		00 4d	    visibleover =	$4d
     95  28000 ????
     96  28000 ????		00 4e	    sfx1pointlo =	$4e
     97  28000 ????		00 4f	    sfx2pointlo =	$4f
     98  28000 ????		00 50	    sfx1pointhi =	$50
     99  28000 ????		00 51	    sfx2pointhi =	$51
    100  28000 ????
    101  28000 ????		00 52	    sfx1priority =	$52
    102  28000 ????		00 53	    sfx2priority =	$53
    103  28000 ????		00 54	    sfx1poffset =	$54
    104  28000 ????		00 55	    sfx2poffset =	$55
    105  28000 ????
    106  28000 ????		00 56	    sfx1frames =	$56
    107  28000 ????		00 57	    sfx2frames =	$57
    108  28000 ????		00 58	    sfx1tick   =	$58
    109  28000 ????		00 59	    sfx2tick   =	$59
    110  28000 ????
    111  28000 ????		00 5a	    tempmath   =	$5a
    112  28000 ????
    113  28000 ????		00 5b	    pokey1pointlo =	$5b
    114  28000 ????		00 5c	    pokey1pointhi =	$5c
    115  28000 ????		00 5d	    pokey2pointlo =	$5d
    116  28000 ????		00 5e	    pokey2pointhi =	$5e
    117  28000 ????		00 5f	    pokey3pointlo =	$5f
    118  28000 ????		00 60	    pokey3pointhi =	$60
    119  28000 ????		00 61	    pokey4pointlo =	$61
    120  28000 ????		00 62	    pokey4pointhi =	$62
    121  28000 ????
    122  28000 ????		00 63	    dlpnt      =	$63	; to $64
    123  28000 ????		00 65	    dlend      =	$65	; to $81 - for 28 possible visible dll entries
    124  28000 ????		00 82	    dlendsave  =	$82	; to $9e - for 28 possible visible dll entries
    125  28000 ????
    126  28000 ????		00 9f	    speech_addr =	$9f
    127  28000 ????		00 a0	    speech_addr_hi =	$a0
    128  28000 ????
    129  28000 ????		00 a1	    HSGameTableLo =	$a1
    130  28000 ????		00 a2	    HSGameTableHi =	$a2
    131  28000 ????		00 a3	    HSVoxHi    =	$a3
    132  28000 ????		00 a4	    HSVoxLo    =	$a4
    133  28000 ????
    134  28000 ????						;channel pointers
    135  28000 ????
    136  28000 ????		00 a5	    songchannel1layer1lo =	$a5
    137  28000 ????		00 a6	    songchannel2layer1lo =	$a6
    138  28000 ????		00 a7	    songchannel3layer1lo =	$a7
    139  28000 ????		00 a8	    songchannel4layer1lo =	$a8
    140  28000 ????
    141  28000 ????		00 a9	    songchannel1layer2lo =	$a9
    142  28000 ????		00 aa	    songchannel2layer2lo =	$aA
    143  28000 ????		00 ab	    songchannel3layer2lo =	$aB
    144  28000 ????		00 ac	    songchannel4layer2lo =	$aC
    145  28000 ????
    146  28000 ????		00 ad	    songchannel1layer3lo =	$aD
    147  28000 ????		00 ae	    songchannel2layer3lo =	$aE
    148  28000 ????		00 af	    songchannel3layer3lo =	$aF
    149  28000 ????		00 b0	    songchannel4layer3lo =	$b0
    150  28000 ????
    151  28000 ????		00 b1	    songchannel1layer1hi =	$b1
    152  28000 ????		00 b2	    songchannel2layer1hi =	$b2
    153  28000 ????		00 b3	    songchannel3layer1hi =	$b3
    154  28000 ????		00 b4	    songchannel4layer1hi =	$b4
    155  28000 ????
    156  28000 ????		00 b5	    songchannel1layer2hi =	$b5
    157  28000 ????		00 b6	    songchannel2layer2hi =	$b6
    158  28000 ????		00 b7	    songchannel3layer2hi =	$b7
    159  28000 ????		00 b8	    songchannel4layer2hi =	$b8
    160  28000 ????
    161  28000 ????		00 b9	    songchannel1layer3hi =	$b9
    162  28000 ????		00 ba	    songchannel2layer3hi =	$bA
    163  28000 ????		00 bb	    songchannel3layer3hi =	$bB
    164  28000 ????		00 bc	    songchannel4layer3hi =	$bC
    165  28000 ????
    166  28000 ????		00 bd	    songdatalo =	$bd
    167  28000 ????		00 be	    songdatahi =	$be
    168  28000 ????
    169  28000 ????		00 bf	    inactivechannelcount =	$bf
    170  28000 ????
    171  28000 ????		00 c0	    songchannel1transpose =	$c0
    172  28000 ????		00 c1	    songchannel2transpose =	$c1
    173  28000 ????		00 c2	    songchannel3transpose =	$c2
    174  28000 ????		00 c3	    songchannel4transpose =	$c3
    175  28000 ????
    176  28000 ????		00 c4	    songstackindex =	$c4
    177  28000 ????
    178  28000 ????		00 c5	    songchannel1instrumentlo =	$c5
    179  28000 ????		00 c6	    songchannel2instrumentlo =	$c6
    180  28000 ????		00 c7	    songchannel3instrumentlo =	$c7
    181  28000 ????		00 c8	    songchannel4instrumentlo =	$c8
    182  28000 ????
    183  28000 ????		00 c9	    songchannel1instrumenthi =	$c9
    184  28000 ????		00 ca	    songchannel2instrumenthi =	$ca
    185  28000 ????		00 cb	    songchannel3instrumenthi =	$cb
    186  28000 ????		00 cc	    songchannel4instrumenthi =	$cc
    187  28000 ????
    188  28000 ????		00 cd	    sfx1notedata =	$cd
    189  28000 ????		00 ce	    sfx2notedata =	$ce
    190  28000 ????
    191  28000 ????		00 cf	    songloops  =	$cf
    192  28000 ????
    193  28000 ????		00 d0	    songpointerlo =	$D0
    194  28000 ????		00 d1	    songpointerhi =	$D1
    195  28000 ????
    196  28000 ????		00 d2	    voxlock    =	$D2
    197  28000 ????		00 d3	    voxqueuesize =	$D3
    198  28000 ????
    199  28000 ????		00 d4	    vblankroutines =	$D4
    200  28000 ????
    201  28000 ????		00 d5	    doublebufferstate =	$D5
    202  28000 ????		00 d6	    doublebufferdloffset =	$D6
    203  28000 ????		00 d7	    doublebufferbufferdirty =	$D7
    204  28000 ????
    205  28000 ????		00 d8	    inttemp1   =	$D8
    206  28000 ????		00 d9	    inttemp2   =	$D9
    207  28000 ????		00 da	    inttemp3   =	$DA
    208  28000 ????		00 db	    inttemp4   =	$DB
    209  28000 ????		00 dc	    inttemp5   =	$DC
    210  28000 ????		00 dd	    inttemp6   =	$DD
    211  28000 ????
    212  28000 ????		00 de	    sfxschedulelock =	$DE
    213  28000 ????		00 df	    sfxschedulemissed =	$DF
    214  28000 ????		00 e0	    sfxinstrumentlo =	$E0
    215  28000 ????		00 e1	    sfxinstrumenthi =	$E1
    216  28000 ????		00 e2	    sfxpitchoffset =	$E2
    217  28000 ????		00 e3	    sfxnoteindex =	$E3
    218  28000 ????
    219  28000 ????		00 e4	    CTLSWAs    =	$E4
    220  28000 ????		00 e5	    CTLSWBs    =	$E5
    221  28000 ????
    222  28000 ????		00 e6	    A	       =	$e6
    223  28000 ????		00 e6	    a	       =	$e6
    224  28000 ????		00 e7	    B	       =	$e7
    225  28000 ????		00 e7	    b	       =	$e7
    226  28000 ????		00 e8	    C	       =	$e8
    227  28000 ????		00 e8	    c	       =	$e8
    228  28000 ????		00 e9	    D	       =	$e9
    229  28000 ????		00 e9	    d	       =	$e9
    230  28000 ????		00 ea	    E	       =	$ea
    231  28000 ????		00 ea	    e	       =	$ea
    232  28000 ????		00 eb	    F	       =	$eb
    233  28000 ????		00 eb	    f	       =	$eb
    234  28000 ????		00 ec	    G	       =	$ec
    235  28000 ????		00 ec	    g	       =	$ec
    236  28000 ????		00 ed	    H	       =	$ed
    237  28000 ????		00 ed	    h	       =	$ed
    238  28000 ????		00 ee	    I	       =	$ee
    239  28000 ????		00 ee	    i	       =	$ee
    240  28000 ????		00 ef	    J	       =	$ef
    241  28000 ????		00 ef	    j	       =	$ef
    242  28000 ????		00 f0	    K	       =	$f0
    243  28000 ????		00 f0	    k	       =	$f0
    244  28000 ????		00 f1	    L	       =	$f1
    245  28000 ????		00 f1	    l	       =	$f1
    246  28000 ????		00 f2	    M	       =	$f2
    247  28000 ????		00 f2	    m	       =	$f2
    248  28000 ????		00 f3	    N	       =	$f3
    249  28000 ????		00 f3	    n	       =	$f3
    250  28000 ????		00 f4	    O	       =	$f4
    251  28000 ????		00 f4	    o	       =	$f4
    252  28000 ????		00 f5	    P	       =	$f5
    253  28000 ????		00 f5	    p	       =	$f5
    254  28000 ????		00 f6	    Q	       =	$f6
    255  28000 ????		00 f6	    q	       =	$f6
    256  28000 ????		00 f7	    R	       =	$f7
    257  28000 ????		00 f7	    r	       =	$f7
    258  28000 ????		00 f8	    S	       =	$f8
    259  28000 ????		00 f8	    s	       =	$f8
    260  28000 ????		00 f9	    T	       =	$f9
    261  28000 ????		00 f9	    t	       =	$f9
    262  28000 ????		00 fa	    U	       =	$fa
    263  28000 ????		00 fa	    u	       =	$fa
    264  28000 ????		00 fb	    V	       =	$fb
    265  28000 ????		00 fb	    v	       =	$fb
    266  28000 ????		00 fc	    W	       =	$fc
    267  28000 ????		00 fc	    w	       =	$fc
    268  28000 ????		00 fd	    X	       =	$fd
    269  28000 ????		00 fd	    x	       =	$fd
    270  28000 ????		00 fe	    Y	       =	$fe
    271  28000 ????		00 fe	    y	       =	$fe
    272  28000 ????		00 ff	    Z	       =	$ff
    273  28000 ????		00 ff	    z	       =	$ff
    274  28000 ????
    275  28000 ????						; var0-var99 variables use the top of the stack
    276  28000 ????		01 40	    var0       =	$140
    277  28000 ????		01 41	    var1       =	$141
    278  28000 ????		01 42	    var2       =	$142
    279  28000 ????		01 43	    var3       =	$143
    280  28000 ????		01 44	    var4       =	$144
    281  28000 ????		01 45	    var5       =	$145
    282  28000 ????		01 46	    var6       =	$146
    283  28000 ????		01 47	    var7       =	$147
    284  28000 ????		01 48	    var8       =	$148
    285  28000 ????		01 49	    var9       =	$149
    286  28000 ????		01 4a	    var10      =	$14a
    287  28000 ????		01 4b	    var11      =	$14b
    288  28000 ????		01 4c	    var12      =	$14c
    289  28000 ????		01 4d	    var13      =	$14d
    290  28000 ????		01 4e	    var14      =	$14e
    291  28000 ????		01 4f	    var15      =	$14f
    292  28000 ????		01 50	    var16      =	$150
    293  28000 ????		01 51	    var17      =	$151
    294  28000 ????		01 52	    var18      =	$152
    295  28000 ????		01 53	    var19      =	$153
    296  28000 ????		01 54	    var20      =	$154
    297  28000 ????		01 55	    var21      =	$155
    298  28000 ????		01 56	    var22      =	$156
    299  28000 ????		01 57	    var23      =	$157
    300  28000 ????		01 58	    var24      =	$158
    301  28000 ????		01 59	    var25      =	$159
    302  28000 ????		01 5a	    var26      =	$15a
    303  28000 ????		01 5b	    var27      =	$15b
    304  28000 ????		01 5c	    var28      =	$15c
    305  28000 ????		01 5d	    var29      =	$15d
    306  28000 ????		01 5e	    var30      =	$15e
    307  28000 ????		01 5f	    var31      =	$15f
    308  28000 ????		01 60	    var32      =	$160
    309  28000 ????		01 61	    var33      =	$161
    310  28000 ????		01 62	    var34      =	$162
    311  28000 ????		01 63	    var35      =	$163
    312  28000 ????		01 64	    var36      =	$164
    313  28000 ????		01 65	    var37      =	$165
    314  28000 ????		01 66	    var38      =	$166
    315  28000 ????		01 67	    var39      =	$167
    316  28000 ????		01 68	    var40      =	$168
    317  28000 ????		01 69	    var41      =	$169
    318  28000 ????		01 6a	    var42      =	$16a
    319  28000 ????		01 6b	    var43      =	$16b
    320  28000 ????		01 6c	    var44      =	$16c
    321  28000 ????		01 6d	    var45      =	$16d
    322  28000 ????		01 6e	    var46      =	$16e
    323  28000 ????		01 6f	    var47      =	$16f
    324  28000 ????		01 70	    var48      =	$170
    325  28000 ????		01 71	    var49      =	$171
    326  28000 ????		01 72	    var50      =	$172
    327  28000 ????		01 73	    var51      =	$173
    328  28000 ????		01 74	    var52      =	$174
    329  28000 ????		01 75	    var53      =	$175
    330  28000 ????		01 76	    var54      =	$176
    331  28000 ????		01 77	    var55      =	$177
    332  28000 ????		01 78	    var56      =	$178
    333  28000 ????		01 79	    var57      =	$179
    334  28000 ????		01 7a	    var58      =	$17a
    335  28000 ????		01 7b	    var59      =	$17b
    336  28000 ????		01 7c	    var60      =	$17c
    337  28000 ????		01 7d	    var61      =	$17d
    338  28000 ????		01 7e	    var62      =	$17e
    339  28000 ????		01 7f	    var63      =	$17f
    340  28000 ????		01 80	    var64      =	$180
    341  28000 ????		01 81	    var65      =	$181
    342  28000 ????		01 82	    var66      =	$182
    343  28000 ????		01 83	    var67      =	$183
    344  28000 ????		01 84	    var68      =	$184
    345  28000 ????		01 85	    var69      =	$185
    346  28000 ????		01 86	    var70      =	$186
    347  28000 ????		01 87	    var71      =	$187
    348  28000 ????		01 88	    var72      =	$188
    349  28000 ????		01 89	    var73      =	$189
    350  28000 ????		01 8a	    var74      =	$18a
    351  28000 ????		01 8b	    var75      =	$18b
    352  28000 ????		01 8c	    var76      =	$18c
    353  28000 ????		01 8d	    var77      =	$18d
    354  28000 ????		01 8e	    var78      =	$18e
    355  28000 ????		01 8f	    var79      =	$18f
    356  28000 ????		01 90	    var80      =	$190
    357  28000 ????		01 91	    var81      =	$191
    358  28000 ????		01 92	    var82      =	$192
    359  28000 ????		01 93	    var83      =	$193
    360  28000 ????		01 94	    var84      =	$194
    361  28000 ????		01 95	    var85      =	$195
    362  28000 ????		01 96	    var86      =	$196
    363  28000 ????		01 97	    var87      =	$197
    364  28000 ????		01 98	    var88      =	$198
    365  28000 ????		01 99	    var89      =	$199
    366  28000 ????		01 9a	    var90      =	$19a
    367  28000 ????		01 9b	    var91      =	$19b
    368  28000 ????		01 9c	    var92      =	$19c
    369  28000 ????		01 9d	    var93      =	$19d
    370  28000 ????		01 9e	    var94      =	$19e
    371  28000 ????		01 9f	    var95      =	$19f
    372  28000 ????		01 a0	    var96      =	$1a0
    373  28000 ????		01 a1	    var97      =	$1a1
    374  28000 ????		01 a2	    var98      =	$1a2
    375  28000 ????		01 a3	    var99      =	$1a3
    376  28000 ????
    377 U01c4 ????				      SEG.U	"7800basicRAM"
    378 U01a4					      ORG	$1A4
    379 U01a4
    380 U01a4							; MAX allocation locations are in comments...
    381 U01a4		       00	   framecounter DS	1	; $1A4
    382 U01a5		       00	   countdownseconds DS	1	; $1A5
    383 U01a6		       00 00 00    score0     DS	3	; $1A6 $1A7 $1A8
    384 U01a9		       00 00 00    score1     DS	3	; $1A9 $1AA $1AB
    385 U01ac		       00	   pausebuttonflag DS	1	; $1AC
    386 U01ad		       00	   valbufend  DS	1	; $1AD
    387 U01ae		       00	   valbufendsave DS	1	; $1AE
    388 U01af		       00	   finescrollx DS	1	; $1AF
    389 U01b0		       00	   finescrolly DS	1	; $1B0
    390 U01b1		       00	   joybuttonmode DS	1	; $1B1 ; track joysticks that were changed to one-button mode
    391 U01b2		       00	   interruptindex DS	1	; $1B2
    392 U01b3
    393 U01b3					      ifconst	DOUBLEBUFFER
    394 U01b3		       00	   doublebufferminimumframetarget DS	1	; $1B3
    395 U01b4		       00	   doublebufferminimumframeindex DS	1	; $1B4
    396 U01b5					      endif
    397 U01b5
    398 U01b5		       00	   pausedisable DS	1	; $1B5
    399 U01b6		       00	   XCTRL1s    DS	1	; $1B6
    400 U01b7
    401 U01b7				  -	      ifconst	AVOXVOICE
    402 U01b7				  -avoxenable DS	1	; $1B7
    403 U01b7				  -tempavox   DS	1	; $1B8
    404 U01b7					      endif
    405 U01b7
    406 U01b7				  -	      ifconst	MUSICTRACKER
    407 U01b7				  -songtempo  DS	1	; $1B9
    408 U01b7				  -songtick   DS	1	; $1BA
    409 U01b7				  -
    410 U01b7				  -songchannel1layer1loops DS	1	; $1BB
    411 U01b7				  -songchannel2layer1loops DS	1	; $1BC
    412 U01b7				  -songchannel3layer1loops DS	1	; $1BD
    413 U01b7				  -songchannel4layer1loops DS	1	; $1BE
    414 U01b7				  -
    415 U01b7				  -songchannel1layer2loops DS	1	; $1BF
    416 U01b7				  -songchannel2layer2loops DS	1	; $1C0
    417 U01b7				  -songchannel3layer2loops DS	1	; $1C1
    418 U01b7				  -songchannel4layer2loops DS	1	; $1C2
    419 U01b7				  -
    420 U01b7				  -songchannel1layer3loops DS	1	; $1C3
    421 U01b7				  -songchannel2layer3loops DS	1	; $1C4
    422 U01b7				  -songchannel3layer3loops DS	1	; $1C5
    423 U01b7				  -songchannel4layer3loops DS	1	; $1C6
    424 U01b7				  -
    425 U01b7				  -songchannel1busywait DS	1	; $1C7
    426 U01b7				  -songchannel2busywait DS	1	; $1C8
    427 U01b7				  -songchannel3busywait DS	1	; $1C9
    428 U01b7				  -songchannel4busywait DS	1	; $1CA
    429 U01b7				  -
    430 U01b7				  -songchannel1stackdepth DS	1	; $1CB
    431 U01b7				  -songchannel2stackdepth DS	1	; $1CC
    432 U01b7				  -songchannel3stackdepth DS	1	; $1CD
    433 U01b7				  -songchannel4stackdepth DS	1	; $1CE
    434 U01b7					      endif
    435 U01b7
    436 U01b7		       00	   palframes  DS	1	; $1CF
    437 U01b8		       00	   palfastframe DS	1	; $1D0
    438 U01b9
    439 U01b9				  -	      ifconst	MOUSESUPPORT
    440 U01b9				  -port0resolution DS	1	; $1D1
    441 U01b9				  -port1resolution DS	1	; $1D2
    442 U01b9					      else
    443 U01b9				  -	      ifconst	TRAKBALLSUPPORT
    444 U01b9				  -port0resolution DS	1	; $1D1
    445 U01b9				  -port1resolution DS	1	; $1D2
    446 U01b9					      endif
    447 U01b9					      endif
    448 U01b9
    449 U01b9		       00	   port0control DS	1	; $1D3
    450 U01ba		       00	   port1control DS	1	; $1D4
    451 U01bb
    452 U01bb							; port#control values...
    453 U01bb							;	1 = proline
    454 U01bb							;	2 = lightgun
    455 U01bb							;	3 = paddle
    456 U01bb							;	4 = trakball
    457 U01bb							;	5 = vcs joystick
    458 U01bb							;	6 = driving
    459 U01bb							;	7 = keypad
    460 U01bb							;	8 = st mouse/cx80
    461 U01bb							;	9 = amiga mouse
    462 U01bb							;     10 = atarivox
    463 U01bb
    464 U01bb							; controller 0 data...
    465 U01bb		       00	   paddleposition0 DS	1	; $1D5
    466 U01bb		       01 bb	   keypadmatrix0a =	paddleposition0
    467 U01bb		       01 bb	   drivingposition0 =	paddleposition0
    468 U01bb		       01 bb	   trakballx0 =	paddleposition0
    469 U01bb		       01 bb	   mousex0    =	paddleposition0
    470 U01bb		       01 bb	   lighttgunx0 =	paddleposition0
    471 U01bb		       01 bb	   snes2atari0lo =	paddleposition0
    472 U01bc
    473 U01bc							; controller 1 data...
    474 U01bc		       00	   paddleposition2 DS	1	; $1D6
    475 U01bc		       01 bc	   keypadmatrix1a =	paddleposition2
    476 U01bc		       01 bc	   drivingposition1 =	paddleposition2
    477 U01bc		       01 bc	   trakballx1 =	paddleposition2
    478 U01bc		       01 bc	   mousex1    =	paddleposition2
    479 U01bc		       01 bc	   lightgunx1 =	paddleposition2
    480 U01bc		       01 bc	   snes2atari1lo =	paddleposition2
    481 U01bd
    482 U01bd							; controller 0 altdata...
    483 U01bd		       00	   paddleposition1 DS	1	; $1D7
    484 U01bd		       01 bd	   keypadmatrix0b =	paddleposition1
    485 U01bd		       01 bd	   trakbally0 =	paddleposition1
    486 U01bd		       01 bd	   mousey0    =	paddleposition1
    487 U01bd		       01 bd	   lightguny0 =	paddleposition1
    488 U01bd		       01 bd	   snes2atari0hi =	paddleposition1
    489 U01be
    490 U01be							; controller 1 altdata...
    491 U01be		       00	   paddleposition3 DS	1	; $1D8
    492 U01be		       01 be	   keypadmatrix1b =	paddleposition3
    493 U01be		       01 be	   trakbally1 =	paddleposition3
    494 U01be		       01 be	   mousey1    =	paddleposition3
    495 U01be		       01 be	   lightguny1 =	paddleposition3
    496 U01be		       01 be	   snes2atari1hi =	paddleposition3
    497 U01bf
    498 U01bf							; controller state save. for trakball state+dir codes, rotary position codes
    499 U01bf		       00	   controller0statesave DS	1	; $1D9
    500 U01bf		       01 bf	   paddleprevious0 =	controller0statesave
    501 U01bf		       01 bf	   mousecodex0 =	controller0statesave
    502 U01bf		       01 bf	   trakballcodex0 =	controller0statesave
    503 U01bf		       01 bf	   keypadmatrix0c =	controller0statesave
    504 U01bf		       01 bf	   snesdetected0 =	controller0statesave
    505 U01c0
    506 U01c0		       00	   controller1statesave DS	1	; $1DA
    507 U01c0		       01 c0	   paddleprevious2 =	controller1statesave
    508 U01c0		       01 c0	   mousecodex1 =	controller1statesave
    509 U01c0		       01 c0	   trakballcodex1 =	controller1statesave
    510 U01c0		       01 c0	   keypadmatrix1c =	controller1statesave
    511 U01c0		       01 c0	   snesdetected1 =	controller1statesave
    512 U01c1
    513 U01c1		       00	   paddleprevious1 DS	1	; $1DB
    514 U01c1		       01 c1	   keypadmatrix0d =	paddleprevious1
    515 U01c1		       01 c1	   mousecodey0 =	paddleprevious1
    516 U01c1		       01 c1	   trakballcodey0 =	paddleprevious1
    517 U01c2
    518 U01c2		       00	   paddleprevious3 DS	1	; $1DC
    519 U01c2		       01 c2	   keypadmatrix1d =	paddleprevious3
    520 U01c2		       01 c2	   mousecodey1 =	paddleprevious3
    521 U01c2		       01 c2	   trakballcodey1 =	paddleprevious3
    522 U01c3
    523 U01c3				  -	      ifconst	pokeysupport
    524 U01c3				  -pokey1frames DS	1	; $1DD
    525 U01c3				  -pokey1tick DS	1	; $1DE
    526 U01c3				  -pokey2frames DS	1	; $1DF
    527 U01c3				  -pokey2tick DS	1	; $1E0
    528 U01c3				  -pokey3frames DS	1	; $1E1
    529 U01c3				  -pokey3tick DS	1	; $1E2
    530 U01c3				  -pokey4frames DS	1	; $1E3
    531 U01c3				  -pokey4tick DS	1	; $1E4
    532 U01c3				  -pokey1priority DS	1	; $1E5
    533 U01c3				  -pokey1offset DS	1	; $1E6
    534 U01c3				  -pokey2priority DS	1	; $1E7
    535 U01c3				  -pokey2offset DS	1	; $1E8
    536 U01c3				  -pokey3priority DS	1	; $1E9
    537 U01c3				  -pokey3offset DS	1	; $1EA
    538 U01c3				  -pokey4priority DS	1	; $1EB
    539 U01c3				  -pokey4offset DS	1	; $1EC
    540 U01c3					      endif
    541 U01c3
    542 U01c3				  -	      ifconst	pokeykeysupport
    543 U01c3				  -pokeylastkeycode DS	1
    544 U01c3				  -pokeykeycode DS	1
    545 U01c3				  -pokeykeydebounce DS	1
    546 U01c3					      endif
    547 U01c3
    548 U01c3				  -	      ifconst	RMT
    549 U01c3				  -rasterpause DS	1
    550 U01c3					      endif		; RMT
    551 U01c3				  -	      ifconst	RMTVOLUME
    552 U01c3				  -rmtvolume  DS	1
    553 U01c3					      endif		; RMTVOLUME
    554 U01c3				  -	      ifconst	TIAVOLUME
    555 U01c3				  -tiavolume  DS	1
    556 U01c3					      endif		; TIAVOLUME
    557 U01c3
    558 U01c3				  -	      ifconst	FOURBITFADE
    559 U01c3				  -fourbittemp1 DS	1
    560 U01c3				  -fourbitfadevalue DS	1
    561 U01c3				  -fourbittemp1int DS	1
    562 U01c3				  -fourbitfadevalueint DS	1
    563 U01c3					      endif		; FOURBITFADE
    564 U01c3
    565 U01c3				  -	      ifconst	SNES2ATARISUPPORT
    566 U01c3				  -snesport   DS	1
    567 U01c3					      endif
    568 U01c3
    569 U01c3							; see if we need an interrupthold byte...
    570 U01c3				   INTERRUPTNEEDED SET	0
    571 U01c3				  -	      ifconst	.topscreenroutine
    572 U01c3				  -INTERRUPTNEEDED SET	1
    573 U01c3					      endif
    574 U01c3				  -	      ifconst	.bottomscreenroutine
    575 U01c3				  -INTERRUPTNEEDED SET	1
    576 U01c3					      endif
    577 U01c3				  -	      ifconst	.userinterrupt
    578 U01c3				  -INTERRUPTNEEDED SET	1
    579 U01c3					      endif
    580 U01c3				  -	      if	INTERRUPTNEEDED = 1
    581 U01c3				  -interrupthold DS	1	; $1ED
    582 U01c3					      endif
    583 U01c3
    584 U01c3					      ifnconst	CANARYOFF
    585 U01c3		       00	   canary     DS	1	; $1EF
    586 U01c4					      endif
    587 U01c4
    588 U01c4
    589 U01c4				  -	      ifnconst	bankswitchmode
    590 U01c4				  -	      echo	"  stack allowance:",[($1FF - .)/2]d,"nested subroutines."
    591 U01c4					      else
   stack allowance: 19 nested subroutines.
    592 U01c4					      echo	"  stack allowance:",[($1FF - .)/3]d,"nested subroutines."
    593 U01c4					      endif
    594 U01c4					      ifnconst	CANARYOFF
   the canary is situated at: $1c3
    595 U01c4					      echo	"  the canary is situated at:",[canary]
    596 U01c4				  -	      else
    597 U01c4				  -	      echo	"  the canary is disabled."
    598 U01c4					      endif
    599 U01c4
    600 U01c4							; $1EE - $1FF reserved for stack
    601 U01c4
    602  28000 ????				       SEG	"GAME"
    603  28000 ????
------- FILE c:\Users\Jag\Desktop\plotmap scrolling doublebuffer\test.78b.asm
------- FILE 7800basic_variable_redefs.h LEVEL 2 PASS 3
      0  28000 ????				       include	"7800basic_variable_redefs.h"
      1  28000 ????						; This file contains variable mapping and other information for the current project.
      2  28000 ????
      3  28000 ????		00 00	    tiles2_mode =	$00
      4  28000 ????		00 1e	    tiles2_width_twoscompliment =	$1e
      5  28000 ????		00 02	    tiles2_width =	$02
      6  28000 ????		00 00	    tiles0_mode =	$00
      7  28000 ????		00 1e	    tiles0_width_twoscompliment =	$1e
      8  28000 ????		00 02	    tiles0_width =	$02
      9  28000 ????		00 00	    enemySprite_mode =	$00
     10  28000 ????		00 1e	    enemySprite_width_twoscompliment =	$1e
     11  28000 ????		00 02	    enemySprite_width =	$02
     12  28000 ????		00 00	    playerSprite_mode =	$00
     13  28000 ????		00 1e	    playerSprite_width_twoscompliment =	$1e
     14  28000 ????		00 02	    playerSprite_width =	$02
     15  28000 ????		00 b8	    tiles2_color3 =	$b8
     16  28000 ????		00 b6	    tiles2_color2 =	$b6
     17  28000 ????		00 b3	    tiles2_color1 =	$b3
     18  28000 ????		00 00	    tiles2_color0 =	$00
     19  28000 ????		00 00	    tiles0_color1 =	0
     20  28000 ????		00 00	    tiles0_color0 =	$00
     21  28000 ????		00 42	    enemySprite_color1 =	$42
     22  28000 ????		00 00	    enemySprite_color0 =	$00
     23  28000 ????		00 6c	    playerSprite_color3 =	$6c
     24  28000 ????		00 57	    playerSprite_color2 =	$57
     25  28000 ????		00 69	    playerSprite_color1 =	$69
     26  28000 ????		00 00	    playerSprite_color0 =	$00
     27  28000 ????		00 01	    DOUBLEBUFFER =	1
     28  28000 ????		00 f8	    enemy1Y    =	s
     29  28000 ????		00 f7	    enemy1XInt =	r
     30  28000 ????		00 f6	    enemy1Visible =	q
     31  28000 ????		00 f6	    enemy1X    =	q
     32  28000 ????		00 f5	    windowX    =	p
     33  28000 ????
     34  28000 ????		00 f4	    scrollCounter =	o
     35  28000 ????
     36  28000 ????		00 ef	    playerVelocityXFrac =	j
     37  28000 ????
     38  28000 ????		00 ee	    playerVelocityXInt =	i
     39  28000 ????		00 ee	    playerVelocityX =	i
     40  28000 ????		00 ed	    playerVelocityYFrac =	h
     41  28000 ????
     42  28000 ????		00 ec	    playerVelocityYInt =	g
     43  28000 ????		00 ec	    playerVelocityY =	g
     44  28000 ????		00 07	    tileWidthMask =	%00000111
     45  28000 ????
     46  28000 ????		00 0f	    tileHeightMask =	%00001111
     47  28000 ????
     48  28000 ????		00 08	    tileWidth  =	8
     49  28000 ????
     50  28000 ????		00 10	    tileHeight =	16
     51  28000 ????
     52  28000 ????		00 07	    playerWidthMinusOne =	7
     53  28000 ????
     54  28000 ????		00 0f	    playerHeightMinusOne =	15
     55  28000 ????
     56  28000 ????		00 20	    screenOffsetY =	16 * 2
     57  28000 ????
     58  28000 ????		ff ff ff f8 screenOffsetX =	- 8
     59  28000 ????
     60  28000 ????		00 ea	    charValue  =	e
     61  28000 ????
     62  28000 ????		00 f2	    mapSize    =	m
     63  28000 ????
     64  28000 ????		00 f1	    fineScrollX =	l
     65  28000 ????
     66  28000 ????		00 f0	    coarseScrollX =	k
     67  28000 ????
     68  28000 ????		00 e9	    playerYFrac =	d
     69  28000 ????		00 e8	    playerYInt =	c
     70  28000 ????		00 e8	    playerY    =	c
     71  28000 ????		00 e7	    playerXFrac =	b
     72  28000 ????		00 e6	    playerXInt =	a
     73  28000 ????		00 e6	    playerX    =	a
     74  28000 ????		40 00	    tileMap    =	$4000
     75  28000 ????
     76  28000 ????		00 06	    bgTile     =	# < ( tiles2 + 0 )
     77  28000 ????
     78  28000 ????		00 e0	    SCREENHEIGHT =	224
     79  28000 ????		00 01	    DOUBLEWIDE =	1
     80  28000 ????		00 10	    ZONEHEIGHT =	16
     81  28000 ????		00 01	    NTSC       =	1
     82  28000 ????		00 01	    SGRAM      =	1
     83  28000 ????		00 08	    bankswitchmode =	8
     84  28000 ????		00 01	    ROM128K    =	1
------- FILE c:\Users\Jag\Desktop\plotmap scrolling doublebuffer\test.78b.asm
    633  28000 ????
    634  28000 ????						; BEADHEADER... disabled for now
    635  28000 ????						; A BEAD header gets automatically incorportated into the ROM header. 
    636  28000 ????						; For more BEAD executable info, check out the spec...
    637  28000 ????						; http://7800.8bitdev.org/index.php/The_Atari_7800_BEAD_Execuable_Specification
    638  28000 ????
    639  28000 ????		00 01	    GAMEDESCRIPTIONSET =	1
    640  28000 ????		4e 61 6d 65 GAMEDESCRIPTION =	"Test Name"
    641  28000 ????
    642  28000 ????
    643  28000 ????		00 40	    BDHSC      =	%01000000
    644  28000 ????		00 20	    BDYM       =	%00100000
    645  28000 ????		00 10	    BDPOKEY    =	%00010000
    646  28000 ????		00 08	    BDROF      =	%00001000
    647  28000 ????		00 00	    BD16K      =	%00000000
    648  28000 ????		00 01	    BD32K      =	%00000001
    649  28000 ????		00 02	    BD48K      =	%00000010
    650  28000 ????		00 05	    BD1800     =	%00000101
    651  28000 ????		00 06	    BD4000     =	%00000110
    652  28000 ????
    653  28000 ????			   -	       ifconst	BEADHEADER
    654  28000 ????			   -BEADHARDWARE SET	0
    655  28000 ????			   -	       ifconst	ROM16K
    656  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD16K)
    657  28000 ????			   -	       endif
    658  28000 ????			   -	       ifconst	ROM32K
    659  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD32K)
    660  28000 ????			   -	       endif
    661  28000 ????			   -	       ifconst	ROM48K
    662  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD48K)
    663  28000 ????			   -	       endif
    664  28000 ????			   -	       ifconst	pokeysupport
    665  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDPOKEY)
    666  28000 ????			   -	       endif
    667  28000 ????			   -	       ifconst	HSSUPPORT
    668  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDHSC)
    669  28000 ????			   -	       endif
    670  28000 ????				       endif
    671  28000 ????
    672  28000 ????						;start address of cart...
    673  28000 ????
    674  28000 ????			    BANK_WAS_SET SET	0
    675  28000 ????
    676  28000 ????			   -	       ifconst	ROM8K
    677  28000 ????			   -	       ORG	$E000,0
    678  28000 ????			   -BANK_WAS_SET SET	1
    679  28000 ????				       endif		; ROM8K
    680  28000 ????
    681  28000 ????			   -	       ifconst	ROM16K
    682  28000 ????			   -	       ORG	$C000,0
    683  28000 ????			   -BANK_WAS_SET SET	1
    684  28000 ????			   -	       ifconst	BEADHEADER
    685  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    686  28000 ????			   -	       ifconst	GAMEDESCRIPTION
    687  28000 ????			   -	       CLC
    688  28000 ????			   -	       BCC	_SKIPDESCRIPTION
    689  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
    690  28000 ????			   -_SKIPDESCRIPTION
    691  28000 ????			   -	       endif
    692  28000 ????			   -	       jmp	($FFFC)
    693  28000 ????			   -	       endif		; GAMEDESCRIPTION
    694  28000 ????				       endif		; BEADHEADER
    695  28000 ????				       endif		; ROM16K
    696  28000 ????
    697  28000 ????			   -	       ifconst	ROM32K
    698  28000 ????			   -	       ORG	$8000,0
    699  28000 ????			   -BANK_WAS_SET SET	1
    700  28000 ????			   -	       ifconst	BEADHEADER
    701  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    702  28000 ????			   -	       ifconst	GAMEDESCRIPTION
    703  28000 ????			   -	       CLC
    704  28000 ????			   -	       BCC	_SKIPDESCRIPTION
    705  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
    706  28000 ????			   -_SKIPDESCRIPTION
    707  28000 ????			   -	       endif
    708  28000 ????			   -	       jmp	($FFFC)
    709  28000 ????			   -	       endif		; GAMEDESCRIPTION
    710  28000 ????				       endif		; BEADHEADER
    711  28000 ????				       endif		; ROM32K
    712  28000 ????
    713  28000 ????			   -	       ifconst	ROM48K
    714  28000 ????			   -	       ORG	$4000,0
    715  28000 ????			   -BANK_WAS_SET SET	1
    716  28000 ????			   -	       ifconst	BEADHEADER
    717  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    718  28000 ????			   -	       ifconst	GAMEDESCRIPTIONSET
    719  28000 ????			   -	       CLC
    720  28000 ????			   -	       BCC	_SKIPDESCRIPTION
    721  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
    722  28000 ????			   -_SKIPDESCRIPTION
    723  28000 ????			   -	       endif		; GAMEDESCRIPTIONSET
    724  28000 ????			   -	       jmp	($FFFC)
    725  28000 ????			   -	       endif		; BEADHEADER
    726  28000 ????				       endif		; ROM48K
    727  28000 ????
    728  28000 ????			   -	       ifconst	ROM52K
    729  28000 ????			   -BANK_WAS_SET SET	1
    730  28000 ????			   -	       ORG	$3000,0
    731  28000 ????				       endif		; ROM52K
    732  28000 ????
    733  28000 ????				       ifconst	bankswitchmode
    734  28000 ????			   -	       ifconst	ROMAT4K
    735  28000 ????			   -BANK_WAS_SET SET	1
    736  28000 ????			   -	       ORG	$4000,0
    737  28000 ????			   -	       RORG	$4000
    738  28000 ????				       else		; ROMAT4K
    739  28000 ????			    BANK_WAS_SET SET	1
    740  8000					      ORG	$8000,0
    741  8000					      RORG	$8000
    742  8000					      endif
    743  8000					      endif
    744  8000
    745  8000				  -	      if	BANK_WAS_SET = 0
    746  8000				  -	      ORG	$8000,0	; default is 32K
    747  8000					      endif
    748  8000
    749  8000							;7800basic v0.20 Jul 29 2022 10:37:24
    750  8000				   SPACEOVERFLOW SET	0
    751  8000				   game
    752  8000				   .L00 		;;  set romsize 128kRAM
    753  8000
    754  8000				   .L01 		;;  set tv ntsc
    755  8000
    756  8000				   .L02 		;;  set zoneheight 16
    757  8000
    758  8000				   .L03 		;;  set doublewide on ;This tells MARIA to fetch 2 bytes of character data for each character you plot, effectively making the characters twice as wide.
    759  8000
    760  8000				   .L04 		;;  set screenheight 224 ;208
    761  8000
    762  8000				   .L05 		;;  set dlmemory $2200 $27FF
    763  8000
    764  8000		       22 00	   DLMEMSTART =	$2200
    765  8000		       27 ff	   DLMEMEND   =	$27FF
    766  8000
    767  8000				   .
    768  8000							;; 
    769  8000
    770  8000				   .
    771  8000							;; 
    772  8000
    773  8000				   .
    774  8000							;; 
    775  8000
    776  8000				   .L06 		;;  displaymode 160A
    777  8000
    778  8000		       a9 50		      lda	#%01010000	;Enable DMA, mode=160x2/160x4, 2x character width
    779  8002		       85 3c		      sta	CTRL
    780  8004
    781  8004		       8d 07 21 	      sta	sCTRL
    782  8007
    783  8007				   .L07 		;;  set basepath graphics ; This sets the compiler to look for all of your image files in <root folder>\basepath.
    784  8007
    785  8007				   .
    786  8007							;; 
    787  8007
    788  8007				   .L08 		;;  bank 1
    789  8007
    790  8007				   .L09 		;;  gosub clearPalettes
    791  8007
    792  8007		       20 0e 84 	      jsr	.clearPalettes
    793  800a
    794  800a				   .
    795  800a							;; 
    796  800a
    797  800a				   .L010		;;  const bgTile  =  # <  ( tiles2 + 0 ) 
    798  800a
    799  800a				   .L011		;;  characterset tiles0
    800  800a
    801  800a		       a9 e0		      lda	#>tiles0
    802  800c		       8d 0b 21 	      sta	sCHARBASE
    803  800f
    804  800f		       85 34		      sta	CHARBASE
    805  8011		       a9 60		      lda	#(tiles0_mode | %01100000)
    806  8013		       8d 06 21 	      sta	charactermode
    807  8016
    808  8016				   .
    809  8016							;; 
    810  8016
    811  8016				   .
    812  8016							;; 
    813  8016
    814  8016				   .
    815  8016							;; 
    816  8016
    817  8016				   .
    818  8016							;; 
    819  8016
    820  8016				   .
    821  8016							;; 
    822  8016
    823  8016				   .
    824  8016							;; 
    825  8016
    826  8016				   .
    827  8016							;; 
    828  8016
    829  8016				   .
    830  8016							;; 
    831  8016
    832  8016				   .
    833  8016							;; 
    834  8016
    835  8016				   .
    836  8016							;; 
    837  8016
    838  8016				   .
    839  8016							;; 
    840  8016
    841  8016				   .
    842  8016							;; 
    843  8016
    844  8016				   .
    845  8016							;; 
    846  8016
    847  8016				   .
    848  8016							;; 
    849  8016
    850  8016				   .
    851  8016							;; 
    852  8016
    853  8016				   .L012		;;  dim tileMap  =  $4000
    854  8016
    855  8016				   .L013		;;  memcpy tileMap level1bigger 3060
    856  8016
    857  8016		       a0 00		      ldy	#0
    858  8018				   memcpyloop0
    859  8018		       b9 03 c0 	      lda	level1bigger+0,y
    860  801b		       99 00 40 	      sta	tileMap+0,y
    861  801e		       88		      dey
    862  801f		       d0 f7		      bne	memcpyloop0
    863  8021		       a0 00		      ldy	#0
    864  8023				   memcpyloop1
    865  8023		       b9 03 c1 	      lda	level1bigger+256,y
    866  8026		       99 00 41 	      sta	tileMap+256,y
    867  8029		       88		      dey
    868  802a		       d0 f7		      bne	memcpyloop1
    869  802c		       a0 00		      ldy	#0
    870  802e				   memcpyloop2
    871  802e		       b9 03 c2 	      lda	level1bigger+512,y
    872  8031		       99 00 42 	      sta	tileMap+512,y
    873  8034		       88		      dey
    874  8035		       d0 f7		      bne	memcpyloop2
    875  8037		       a0 00		      ldy	#0
    876  8039				   memcpyloop3
    877  8039		       b9 03 c3 	      lda	level1bigger+768,y
    878  803c		       99 00 43 	      sta	tileMap+768,y
    879  803f		       88		      dey
    880  8040		       d0 f7		      bne	memcpyloop3
    881  8042		       a0 00		      ldy	#0
    882  8044				   memcpyloop4
    883  8044		       b9 03 c4 	      lda	level1bigger+1024,y
    884  8047		       99 00 44 	      sta	tileMap+1024,y
    885  804a		       88		      dey
    886  804b		       d0 f7		      bne	memcpyloop4
    887  804d		       a0 00		      ldy	#0
    888  804f				   memcpyloop5
    889  804f		       b9 03 c5 	      lda	level1bigger+1280,y
    890  8052		       99 00 45 	      sta	tileMap+1280,y
    891  8055		       88		      dey
    892  8056		       d0 f7		      bne	memcpyloop5
    893  8058		       a0 00		      ldy	#0
    894  805a				   memcpyloop6
    895  805a		       b9 03 c6 	      lda	level1bigger+1536,y
    896  805d		       99 00 46 	      sta	tileMap+1536,y
    897  8060		       88		      dey
    898  8061		       d0 f7		      bne	memcpyloop6
    899  8063		       a0 00		      ldy	#0
    900  8065				   memcpyloop7
    901  8065		       b9 03 c7 	      lda	level1bigger+1792,y
    902  8068		       99 00 47 	      sta	tileMap+1792,y
    903  806b		       88		      dey
    904  806c		       d0 f7		      bne	memcpyloop7
    905  806e		       a0 00		      ldy	#0
    906  8070				   memcpyloop8
    907  8070		       b9 03 c8 	      lda	level1bigger+2048,y
    908  8073		       99 00 48 	      sta	tileMap+2048,y
    909  8076		       88		      dey
    910  8077		       d0 f7		      bne	memcpyloop8
    911  8079		       a0 00		      ldy	#0
    912  807b				   memcpyloop9
    913  807b		       b9 03 c9 	      lda	level1bigger+2304,y
    914  807e		       99 00 49 	      sta	tileMap+2304,y
    915  8081		       88		      dey
    916  8082		       d0 f7		      bne	memcpyloop9
    917  8084		       a0 00		      ldy	#0
    918  8086				   memcpyloop10
    919  8086		       b9 03 ca 	      lda	level1bigger+2560,y
    920  8089		       99 00 4a 	      sta	tileMap+2560,y
    921  808c		       88		      dey
    922  808d		       d0 f7		      bne	memcpyloop10
    923  808f		       a0 f4		      ldy	#244
    924  8091				   memcpyloop11
    925  8091		       b9 02 cb 	      lda	level1bigger-1+2816,y
    926  8094		       99 ff 4a 	      sta	tileMap-1+2816,y
    927  8097		       88		      dey
    928  8098		       d0 f7		      bne	memcpyloop11
    929  809a		       a0 f4		      ldy	#244
    930  809c				   memcpyloop12
    931  809c		       b9 02 c0 	      lda	level1bigger-1,y
    932  809f		       99 ff 3f 	      sta	tileMap-1,y
    933  80a2		       88		      dey
    934  80a3		       d0 f7		      bne	memcpyloop12
    935  80a5				   .
    936  80a5							;; 
    937  80a5
    938  80a5				   .
    939  80a5							;; 
    940  80a5
    941  80a5				   .L014		;;  dim playerX  =  a.b  :  dim playerXInt  =	a  :  dim playerXFrac  =  b  :	a  =  8
    942  80a5
    943  80a5		       a9 08		      LDA	#8
    944  80a7		       85 e6		      STA	a
    945  80a9				   .L015		;;  dim playerY  =  c.d  :  dim playerYInt  =	c  :  dim playerYFrac  =  d  :	c  =  80
    946  80a9
    947  80a9		       a9 50		      LDA	#80
    948  80ab		       85 e8		      STA	c
    949  80ad				   .
    950  80ad							;; 
    951  80ad
    952  80ad				   .L016		;;  dim coarseScrollX	=  k
    953  80ad
    954  80ad				   .L017		;;  dim fineScrollX  =  l
    955  80ad
    956  80ad				   .L018		;;  dim mapSize  =  m
    957  80ad
    958  80ad				   .
    959  80ad							;; 
    960  80ad
    961  80ad				   .L019		;;  rem ** These are defining the map you're using. MapSize is the total number of characters in a row of your map.
    962  80ad
    963  80ad				   .L020		;;  mapSize  =  255
    964  80ad
    965  80ad		       a9 ff		      LDA	#255
    966  80af		       85 f2		      STA	mapSize
    967  80b1				   .
    968  80b1							;; 
    969  80b1
    970  80b1				   .
    971  80b1							;; 
    972  80b1
    973  80b1				   .L021		;;  dim charValue  =  e
    974  80b1
    975  80b1				   .L022		;;  const screenOffsetX  =   - 8
    976  80b1
    977  80b1				   .L023		;;  const screenOffsetY  =  16  *  2
    978  80b1
    979  80b1				   .
    980  80b1							;; 
    981  80b1
    982  80b1				   .L024		;;  const playerHeightMinusOne  =  15
    983  80b1
    984  80b1				   .L025		;;  const playerWidthMinusOne	=  7
    985  80b1
    986  80b1				   .
    987  80b1							;; 
    988  80b1
    989  80b1				   .L026		;;  const tileHeight  =  16
    990  80b1
    991  80b1				   .L027		;;  const tileWidth  =  8
    992  80b1
    993  80b1				   .
    994  80b1							;; 
    995  80b1
    996  80b1				   .
    997  80b1							;; 
    998  80b1
    999  80b1				   .
   1000  80b1							;; 
   1001  80b1
   1002  80b1				   .
   1003  80b1							;; 
   1004  80b1
   1005  80b1				   .L028		;;  const tileHeightMask  =  %00001111
   1006  80b1
   1007  80b1				   .L029		;;  const tileWidthMask  =  %00000111
   1008  80b1
   1009  80b1				   .
   1010  80b1							;; 
   1011  80b1
   1012  80b1							;.leftSlide.f{0}.
   1013  80b1				   .L030		;;  def leftSlide = f{0}
   1014  80b1
   1015  80b1							;.rightSlide.f{1}.
   1016  80b1				   .L031		;;  def rightSlide = f{1}
   1017  80b1
   1018  80b1							;.movingUp.f{2}.
   1019  80b1				   .L032		;;  def movingUp = f{2}
   1020  80b1
   1021  80b1							;.jumpRestrainer.f{3}.
   1022  80b1				   .L033		;;  def jumpRestrainer = f{3}
   1023  80b1
   1024  80b1				   .
   1025  80b1							;; 
   1026  80b1
   1027  80b1				   .L034		;;  dim playerVelocityY  =  g.h  :  dim playerVelocityYInt  =	g  :  dim playerVelocityYFrac  =  h
   1028  80b1
   1029  80b1				   .L035		;;  dim playerVelocityX  =  i.j  :  dim playerVelocityXInt  =	i  :  dim playerVelocityXFrac  =  j
   1030  80b1
   1031  80b1							;.accelerationY.0.25.
   1032  80b1				   .L036		;;  def accelerationY = 0.25
   1033  80b1
   1034  80b1							;.accelerationX.0.125.
   1035  80b1				   .L037		;;  def accelerationX = 0.125
   1036  80b1
   1037  80b1				   .
   1038  80b1							;; 
   1039  80b1
   1040  80b1				   .L038		;;  dim scrollCounter	=  o
   1041  80b1
   1042  80b1				   .L039		;;  dim windowX  =  p
   1043  80b1
   1044  80b1				   .
   1045  80b1							;; 
   1046  80b1
   1047  80b1				   .L040		;;  dim enemy1X  =  q.r  :  dim enemy1Visible	=  q  :  dim enemy1XInt  =  r  :  q  =	1  :  r  =  128
   1048  80b1
   1049  80b1		       a9 01		      LDA	#1
   1050  80b3		       85 f6		      STA	q
   1051  80b5		       a9 80		      LDA	#128
   1052  80b7		       85 f7		      STA	r
   1053  80b9				   .L041		;;  dim enemy1Y  =  s	:  s  =  16  *	12
   1054  80b9
   1055  80b9		       a9 10		      LDA	#16
   1056  80bb		       0a		      asl
   1057  80bc		       18		      clc
   1058  80bd		       69 10		      adc	#16
   1059  80bf		       0a		      asl
   1060  80c0		       0a		      asl
   1061  80c1		       85 f8		      STA	s
   1062  80c3				   .
   1063  80c3							;; 
   1064  80c3
   1065  80c3							;.enemy1Left.t{0}.
   1066  80c3				   .L042		;;  def enemy1Left = t{0}
   1067  80c3
   1068  80c3				   .
   1069  80c3							;; 
   1070  80c3
   1071  80c3							;._top. ( playerYInt - screenOffsetY )  / tileHeight.
   1072  80c3				   .L043		;;  def _top =  ( playerYInt - screenOffsetY )  / tileHeight
   1073  80c3
   1074  80c3							;._bottom. (  ( playerYInt - screenOffsetY )  + playerHeightMinusOne )  / tileHeight.
   1075  80c3				   .L044		;;  def _bottom =  (  ( playerYInt - screenOffsetY )  + playerHeightMinusOne )  / tileHeight
   1076  80c3
   1077  80c3							;._left. (  (	( playerXInt - fineScrollX )  - screenOffsetX )  / tileWidth )	+ coarseScrollX.
   1078  80c3				   .L045		;;  def _left =  (  (	( playerXInt - fineScrollX )  - screenOffsetX )  / tileWidth )	+ coarseScrollX
   1079  80c3
   1080  80c3							;._right. (  (  (  ( playerXInt - fineScrollX )  - screenOffsetX )  + playerWidthMinusOne )  / tileWidth )  + coarseScrollX.
   1081  80c3				   .L046		;;  def _right =  (  (  (  ( playerXInt - fineScrollX )  - screenOffsetX )  + playerWidthMinusOne )  / tileWidth )  + coarseScrollX
   1082  80c3
   1083  80c3				   .
   1084  80c3							;; 
   1085  80c3
   1086  80c3				   .
   1087  80c3							;; 
   1088  80c3
   1089  80c3				   .L047		;;  temp1  =  fineScrollX  -  8
   1090  80c3
   1091  80c3		       a5 f1		      LDA	fineScrollX
   1092  80c5		       38		      SEC
   1093  80c6		       e9 08		      SBC	#8
   1094  80c8		       85 42		      STA	temp1
   1095  80ca				   .L048		;;  doublebuffer on
   1096  80ca
   1097  80ca		       a9 01		      lda	#1
   1098  80cc		       85 d5		      sta	doublebufferstate
   1099  80ce				   .L049		;;  clearscreen
   1100  80ce
   1101  80ce		       20 87 f0 	      jsr	clearscreen
   1102  80d1				   .L050		;;  plotmap tileMap 0 temp1 2 21 12 coarseScrollX 0 mapSize
   1103  80d1
   1104  80d1		       a9 0b		      lda	#11	; width in two's complement
   1105  80d3		       85 44		      sta	temp3
   1106  80d5		       09 00		      ora	#0	; palette left shifted 5 bits
   1107  80d7		       85 44		      sta	temp3
   1108  80d9		       a5 42		      lda	temp1
   1109  80db		       85 45		      sta	temp4
   1110  80dd
   1111  80dd		       a9 02		      lda	#2
   1112  80df		       85 46		      sta	temp5
   1113  80e1
   1114  80e1		       a9 0c		      lda	#12
   1115  80e3		       85 47		      sta	temp6
   1116  80e5		       a9 00		      lda	#<tileMap
   1117  80e7		       85 42		      sta	temp1
   1118  80e9
   1119  80e9		       a9 40		      lda	#>tileMap
   1120  80eb		       85 43		      sta	temp2
   1121  80ed
   1122  80ed		       a0 00		      ldy	#0
   1123  80ef		       c0 00		      cpy	#0
   1124  80f1		       f0 14		      beq	skipmapyadjust13
   1125  80f3		       a5 f2		      lda	mapSize
   1126  80f5
   1127  80f5		       20 20 f4 	      jsr	mul16
   1128  80f8							;result is in A, temp1 contains overflow
   1129  80f8		       85 43		      sta	temp2
   1130  80fa		       18		      clc
   1131  80fb		       a9 00		      lda	#<tileMap
   1132  80fd		       65 42		      adc	temp1
   1133  80ff		       85 42		      sta	temp1
   1134  8101		       a9 40		      lda	#>tileMap
   1135  8103		       65 43		      adc	temp2
   1136  8105		       85 43		      sta	temp2
   1137  8107				   skipmapyadjust13
   1138  8107		       18		      clc
   1139  8108		       a5 f0		      lda	coarseScrollX
   1140  810a		       65 42		      adc	temp1
   1141  810c		       85 42		      sta	temp1
   1142  810e		       a9 00		      lda	#0
   1143  8110		       65 43		      adc	temp2
   1144  8112		       85 43		      sta	temp2
   1145  8114				   plotcharactersloop14
   1146  8114		       20 9f f3 	      jsr	plotcharacters
   1147  8117		       18		      clc
   1148  8118		       a5 f2		      lda	mapSize
   1149  811a
   1150  811a		       65 42		      adc	temp1
   1151  811c		       85 42		      sta	temp1
   1152  811e		       a9 00		      lda	#0
   1153  8120		       65 43		      adc	temp2
   1154  8122		       85 43		      sta	temp2
   1155  8124		       e6 46		      inc	temp5
   1156  8126		       c6 47		      dec	temp6
   1157  8128		       d0 ea		      bne	plotcharactersloop14
   1158  812a				   .L051		;;  savescreen
   1159  812a
   1160  812a		       20 ab f0 	      jsr	savescreen
   1161  812d				   .
   1162  812d							;; 
   1163  812d
   1164  812d				   .
   1165  812d							;; 
   1166  812d
   1167  812d				   .
   1168  812d							;; 
   1169  812d
   1170  812d				   .L052		;;  P3C1  =  $c3
   1171  812d
   1172  812d		       a9 c3		      LDA	#$c3
   1173  812f		       85 2d		      STA	P3C1
   1174  8131				   .L053		;;  P3C2  =  $c3
   1175  8131
   1176  8131		       a9 c3		      LDA	#$c3
   1177  8133		       85 2e		      STA	P3C2
   1178  8135				   .L054		;;  P3C3  =  $c3
   1179  8135
   1180  8135		       a9 c3		      LDA	#$c3
   1181  8137		       85 2f		      STA	P3C3
   1182  8139				   .
   1183  8139							;; 
   1184  8139
   1185  8139				   .
   1186  8139							;; 
   1187  8139
   1188  8139				   .L055		;;  P4C1  =  $33
   1189  8139
   1190  8139		       a9 33		      LDA	#$33
   1191  813b		       85 31		      STA	P4C1
   1192  813d				   .L056		;;  P4C2  =  $33
   1193  813d
   1194  813d		       a9 33		      LDA	#$33
   1195  813f		       85 32		      STA	P4C2
   1196  8141				   .L057		;;  P4C3  =  $33
   1197  8141
   1198  8141		       a9 33		      LDA	#$33
   1199  8143		       85 33		      STA	P4C3
   1200  8145				   .
   1201  8145							;; 
   1202  8145
   1203  8145				   .
   1204  8145							;; 
   1205  8145
   1206  8145				   .L058		;;  P0C1  =  $85
   1207  8145
   1208  8145		       a9 85		      LDA	#$85
   1209  8147		       85 21		      STA	P0C1
   1210  8149				   .L059		;;  P0C2  =  $89
   1211  8149
   1212  8149		       a9 89		      LDA	#$89
   1213  814b		       85 22		      STA	P0C2
   1214  814d				   .L060		;;  P0C3  =  $8d
   1215  814d
   1216  814d		       a9 8d		      LDA	#$8d
   1217  814f		       85 23		      STA	P0C3
   1218  8151				   .main
   1219  8151							;; main
   1220  8151
   1221  8151				   .
   1222  8151							;; 
   1223  8151
   1224  8151				   .
   1225  8151							;; 
   1226  8151
   1227  8151				   .
   1228  8151							;; 
   1229  8151
   1230  8151				   .
   1231  8151							;; 
   1232  8151
   1233  8151				   .
   1234  8151							;; 
   1235  8151
   1236  8151				   .
   1237  8151							;; 
   1238  8151
   1239  8151				   .
   1240  8151							;; 
   1241  8151
   1242  8151				   .
   1243  8151							;; 
   1244  8151
   1245  8151				   .
   1246  8151							;; 
   1247  8151
   1248  8151				   .L061		;;  if leftSlide then goto skipRight
   1249  8151
   1250  8151		       a5 eb		      LDA	f
   1251  8153		       4a		      LSR
   1252  8154		       90 03		      BCC	.skipL061
   1253  8156				   .condpart0
   1254  8156		       4c 42 82 	      jmp	.skipRight
   1255  8159
   1256  8159				   .skipL061
   1257  8159				   .L062		;;  if !joy0right then goto slideRight
   1258  8159
   1259  8159		       2c 80 02 	      bit	SWCHA
   1260  815c		       10 03		      BPL	.skipL062
   1261  815e				   .condpart1
   1262  815e		       4c 7d 81 	      jmp	.slideRight
   1263  8161
   1264  8161				   .skipL062
   1265  8161				   .
   1266  8161							;; 
   1267  8161
   1268  8161				   .L063		;;  if playerVelocityXInt  <  2 then playerVelocityX  =  playerVelocityX  +  accelerationX
   1269  8161
   1270  8161		       a5 ee		      LDA	playerVelocityXInt
   1271  8163		       c9 02		      CMP	#2
   1272  8165		       b0 0d		      BCS	.skipL063
   1273  8167				   .condpart2
   1274  8167		       a5 ef		      LDA	j
   1275  8169		       18		      CLC
   1276  816a		       69 20		      ADC	#32
   1277  816c		       85 ef		      STA	j
   1278  816e		       a5 ee		      LDA	playerVelocityX
   1279  8170		       69 00		      ADC	#0
   1280  8172		       85 ee		      STA	playerVelocityX
   1281  8174				   .skipL063
   1282  8174				   .L064		;;  rightSlide  =  1
   1283  8174
   1284  8174		       a5 eb		      LDA	f
   1285  8176		       09 02		      ORA	#2
   1286  8178		       85 eb		      STA	f
   1287  817a				   .L065		;;  goto moveRight
   1288  817a
   1289  817a		       4c a5 81 	      jmp	.moveRight
   1290  817d
   1291  817d				   .
   1292  817d							;; 
   1293  817d
   1294  817d				   .slideRight
   1295  817d							;; slideRight
   1296  817d
   1297  817d				   .L066		;;  if !rightSlide then skipSlideRight
   1298  817d
   1299  817d		       a5 eb		      LDA	f
   1300  817f		       29 02		      AND	#2
   1301  8181				  -	      if	((* - .skipSlideRight) < 127) && ((* - .skipSlideRight) > -128)
   1302  8181				  -	      BEQ	.skipSlideRight
   1303  8181					      else
   1304  8181		       d0 03		      bne	.0skipskipSlideRight
   1305  8183		       4c 42 82 	      jmp	.skipSlideRight
   1306  8186				   .0skipskipSlideRight
   1307  8186					      endif
   1308  8186				   .L067		;;  playerVelocityX  =  playerVelocityX  -  accelerationX
   1309  8186
   1310  8186		       a5 ef		      LDA	j
   1311  8188		       38		      SEC
   1312  8189		       e9 20		      SBC	#32
   1313  818b		       85 ef		      STA	j
   1314  818d		       a5 ee		      LDA	playerVelocityX
   1315  818f		       e9 00		      SBC	#0
   1316  8191		       85 ee		      STA	playerVelocityX
   1317  8193				   .L068		;;  if playerVelocityXInt  =  0  &&  playerVelocityXFrac  =  0 then rightSlide  =  0
   1318  8193
   1319  8193		       a5 ee		      LDA	playerVelocityXInt
   1320  8195		       c9 00		      CMP	#0
   1321  8197		       d0 0c		      BNE	.skipL068
   1322  8199				   .condpart3
   1323  8199		       a5 ef		      LDA	playerVelocityXFrac
   1324  819b		       c9 00		      CMP	#0
   1325  819d		       d0 06		      BNE	.skip3then
   1326  819f				   .condpart4
   1327  819f		       a5 eb		      LDA	f
   1328  81a1		       29 fd		      AND	#253
   1329  81a3		       85 eb		      STA	f
   1330  81a5				   .skip3then
   1331  81a5				   .skipL068
   1332  81a5				   .
   1333  81a5							;; 
   1334  81a5
   1335  81a5				   .moveRight
   1336  81a5							;; moveRight
   1337  81a5
   1338  81a5				   .L069		;;  playerX  =  playerX  +  playerVelocityX
   1339  81a5
   1340  81a5		       a5 e7		      LDA	b
   1341  81a7		       18		      CLC
   1342  81a8		       65 ef		      ADC	j
   1343  81aa		       85 e7		      STA	b
   1344  81ac		       a5 e6		      LDA	playerX
   1345  81ae		       65 ee		      ADC	playerVelocityX
   1346  81b0		       85 e6		      STA	playerX
   1347  81b2				   .
   1348  81b2							;; 
   1349  81b2
   1350  81b2				   .L070		;;  x	=  _right
   1351  81b2
   1352  81b2							; complex statement detected
   1353  81b2		       a5 e6		      LDA	playerXInt
   1354  81b4		       38		      SEC
   1355  81b5		       e5 f1		      SBC	fineScrollX
   1356  81b7		       38		      SEC
   1357  81b8		       e9 f8		      SBC	#screenOffsetX
   1358  81ba		       18		      CLC
   1359  81bb		       69 07		      ADC	#playerWidthMinusOne
   1360  81bd		       a0 08		      LDY	#tileWidth
   1361  81bf		       20 11 f4 	      jsr	div8
   1362  81c2		       18		      CLC
   1363  81c3		       65 f0		      ADC	coarseScrollX
   1364  81c5		       85 fd		      STA	x
   1365  81c7				   .L071		;;  y	=  _top
   1366  81c7
   1367  81c7							; complex statement detected
   1368  81c7		       a5 e8		      LDA	playerYInt
   1369  81c9		       38		      SEC
   1370  81ca		       e9 20		      SBC	#screenOffsetY
   1371  81cc		       a0 10		      LDY	#tileHeight
   1372  81ce		       20 11 f4 	      jsr	div8
   1373  81d1		       85 fe		      STA	y
   1374  81d3				   .L072		;;  charValue	=  peekchar (  tileMap ,  x ,  y ,  255 ,  12  ) 
   1375  81d3
   1376  81d3		       a4 fe		      ldy	y
   1377  81d5		       b9 08 ef 	      lda	tileMap_mult_lo,y
   1378  81d8		       85 42		      sta	temp1
   1379  81da		       b9 14 ef 	      lda	tileMap_mult_hi,y
   1380  81dd		       85 43		      sta	temp2
   1381  81df		       a4 fd		      ldy	x
   1382  81e1		       b1 42		      lda	(temp1),y
   1383  81e3		       85 ea		      STA	charValue
   1384  81e5				   .L073		;;  if charValue  =  bgTile then goto hitRightWall
   1385  81e5
   1386  81e5		       a5 ea		      LDA	charValue
   1387  81e7		       c9 06		      CMP	#bgTile
   1388  81e9		       d0 03		      BNE	.skipL073
   1389  81eb				   .condpart5
   1390  81eb		       4c 1b 82 	      jmp	.hitRightWall
   1391  81ee
   1392  81ee				   .skipL073
   1393  81ee				   .
   1394  81ee							;; 
   1395  81ee
   1396  81ee				   .L074		;;  y	=  _bottom
   1397  81ee
   1398  81ee							; complex statement detected
   1399  81ee		       a5 e8		      LDA	playerYInt
   1400  81f0		       38		      SEC
   1401  81f1		       e9 20		      SBC	#screenOffsetY
   1402  81f3		       18		      CLC
   1403  81f4		       69 0f		      ADC	#playerHeightMinusOne
   1404  81f6		       a0 10		      LDY	#tileHeight
   1405  81f8		       20 11 f4 	      jsr	div8
   1406  81fb		       85 fe		      STA	y
   1407  81fd				   .L075		;;  charValue	=  peekchar (  tileMap ,  x ,  y ,  255 ,  12  ) 
   1408  81fd
   1409  81fd		       a4 fe		      ldy	y
   1410  81ff		       b9 08 ef 	      lda	tileMap_mult_lo,y
   1411  8202		       85 42		      sta	temp1
   1412  8204		       b9 14 ef 	      lda	tileMap_mult_hi,y
   1413  8207		       85 43		      sta	temp2
   1414  8209		       a4 fd		      ldy	x
   1415  820b		       b1 42		      lda	(temp1),y
   1416  820d		       85 ea		      STA	charValue
   1417  820f				   .L076		;;  if charValue  =  bgTile then goto hitRightWall
   1418  820f
   1419  820f		       a5 ea		      LDA	charValue
   1420  8211		       c9 06		      CMP	#bgTile
   1421  8213		       d0 03		      BNE	.skipL076
   1422  8215				   .condpart6
   1423  8215		       4c 1b 82 	      jmp	.hitRightWall
   1424  8218
   1425  8218				   .skipL076
   1426  8218				   .L077		;;  goto noRightWall
   1427  8218
   1428  8218		       4c 35 82 	      jmp	.noRightWall
   1429  821b
   1430  821b				   .
   1431  821b							;; 
   1432  821b
   1433  821b				   .hitRightWall
   1434  821b							;; hitRightWall
   1435  821b
   1436  821b				   .L078		;;  playerXInt  =  playerXInt	-   ( playerXInt  &  tileWidthMask ) 
   1437  821b
   1438  821b							; complex statement detected
   1439  821b		       a5 e6		      LDA	playerXInt
   1440  821d		       48		      PHA
   1441  821e		       29 07		      AND	#tileWidthMask
   1442  8220		       a8		      TAY
   1443  8221		       68		      PLA
   1444  8222		       84 5a		      STY	tempmath
   1445  8224		       38		      SEC
   1446  8225		       e5 5a		      SBC	tempmath
   1447  8227		       85 e6		      STA	playerXInt
   1448  8229				   .
   1449  8229							;; 
   1450  8229
   1451  8229				   .L079		;;  rightSlide  =  0
   1452  8229
   1453  8229		       a5 eb		      LDA	f
   1454  822b		       29 fd		      AND	#253
   1455  822d		       85 eb		      STA	f
   1456  822f				   .L080		;;  playerVelocityXInt  =  0  :  playerVelocityXFrac  =  0
   1457  822f
   1458  822f		       a9 00		      LDA	#0
   1459  8231		       85 ee		      STA	playerVelocityXInt
   1460  8233		       85 ef		      STA	playerVelocityXFrac
   1461  8235				   .
   1462  8235							;; 
   1463  8235
   1464  8235				   .noRightWall
   1465  8235							;; noRightWall
   1466  8235
   1467  8235				   .L081		;;  if playerXInt  >=	152 then scrollCounter	=  152	:  gosub scrollRight
   1468  8235
   1469  8235		       a5 e6		      LDA	playerXInt
   1470  8237		       c9 98		      CMP	#152
   1471  8239		       90 07		      BCC	.skipL081
   1472  823b				   .condpart7
   1473  823b		       a9 98		      LDA	#152
   1474  823d		       85 f4		      STA	scrollCounter
   1475  823f		       20 95 87 	      jsr	.scrollRight
   1476  8242
   1477  8242				   .skipL081
   1478  8242				   .skipSlideRight
   1479  8242							;; skipSlideRight
   1480  8242
   1481  8242				   .skipRight
   1482  8242							;; skipRight
   1483  8242
   1484  8242				   .
   1485  8242							;; 
   1486  8242
   1487  8242				   .
   1488  8242							;; 
   1489  8242
   1490  8242				   .
   1491  8242							;; 
   1492  8242
   1493  8242				   .
   1494  8242							;; 
   1495  8242
   1496  8242				   .
   1497  8242							;; 
   1498  8242
   1499  8242				   .
   1500  8242							;; 
   1501  8242
   1502  8242				   .
   1503  8242							;; 
   1504  8242
   1505  8242				   .
   1506  8242							;; 
   1507  8242
   1508  8242				   .
   1509  8242							;; 
   1510  8242
   1511  8242				   .
   1512  8242							;; 
   1513  8242
   1514  8242				   .
   1515  8242							;; 
   1516  8242
   1517  8242				   .L082		;;  if rightSlide then goto skipLeft
   1518  8242
   1519  8242		       a5 eb		      LDA	f
   1520  8244		       29 02		      AND	#2
   1521  8246		       f0 03		      BEQ	.skipL082
   1522  8248				   .condpart8
   1523  8248		       4c 3e 83 	      jmp	.skipLeft
   1524  824b
   1525  824b				   .skipL082
   1526  824b				   .L083		;;  if !joy0left then goto slideLeft
   1527  824b
   1528  824b		       2c 80 02 	      bit	SWCHA
   1529  824e		       50 03		      BVC	.skipL083
   1530  8250				   .condpart9
   1531  8250		       4c 6f 82 	      jmp	.slideLeft
   1532  8253
   1533  8253				   .skipL083
   1534  8253				   .
   1535  8253							;; 
   1536  8253
   1537  8253				   .L084		;;  if playerVelocityXInt  <  2 then playerVelocityX  =  playerVelocityX  +  accelerationX
   1538  8253
   1539  8253		       a5 ee		      LDA	playerVelocityXInt
   1540  8255		       c9 02		      CMP	#2
   1541  8257		       b0 0d		      BCS	.skipL084
   1542  8259				   .condpart10
   1543  8259		       a5 ef		      LDA	j
   1544  825b		       18		      CLC
   1545  825c		       69 20		      ADC	#32
   1546  825e		       85 ef		      STA	j
   1547  8260		       a5 ee		      LDA	playerVelocityX
   1548  8262		       69 00		      ADC	#0
   1549  8264		       85 ee		      STA	playerVelocityX
   1550  8266				   .skipL084
   1551  8266				   .L085		;;  leftSlide	=  1
   1552  8266
   1553  8266		       a5 eb		      LDA	f
   1554  8268		       09 01		      ORA	#1
   1555  826a		       85 eb		      STA	f
   1556  826c				   .L086		;;  goto moveLeft
   1557  826c
   1558  826c		       4c 96 82 	      jmp	.moveLeft
   1559  826f
   1560  826f				   .
   1561  826f							;; 
   1562  826f
   1563  826f				   .slideLeft
   1564  826f							;; slideLeft
   1565  826f
   1566  826f				   .L087		;;  if !leftSlide then skipSlideLeft
   1567  826f
   1568  826f		       a5 eb		      LDA	f
   1569  8271		       4a		      LSR
   1570  8272				  -	      if	((* - .skipSlideLeft) < 127) && ((* - .skipSlideLeft) > -128)
   1571  8272				  -	      bcc	.skipSlideLeft
   1572  8272					      else
   1573  8272		       b0 03		      bcs	.1skipskipSlideLeft
   1574  8274		       4c 3e 83 	      jmp	.skipSlideLeft
   1575  8277				   .1skipskipSlideLeft
   1576  8277					      endif
   1577  8277				   .L088		;;  playerVelocityX  =  playerVelocityX  -  accelerationX
   1578  8277
   1579  8277		       a5 ef		      LDA	j
   1580  8279		       38		      SEC
   1581  827a		       e9 20		      SBC	#32
   1582  827c		       85 ef		      STA	j
   1583  827e		       a5 ee		      LDA	playerVelocityX
   1584  8280		       e9 00		      SBC	#0
   1585  8282		       85 ee		      STA	playerVelocityX
   1586  8284				   .L089		;;  if playerVelocityXInt  =  0  &&  playerVelocityXFrac  =  0 then leftSlide	=  0
   1587  8284
   1588  8284		       a5 ee		      LDA	playerVelocityXInt
   1589  8286		       c9 00		      CMP	#0
   1590  8288		       d0 0c		      BNE	.skipL089
   1591  828a				   .condpart11
   1592  828a		       a5 ef		      LDA	playerVelocityXFrac
   1593  828c		       c9 00		      CMP	#0
   1594  828e		       d0 06		      BNE	.skip11then
   1595  8290				   .condpart12
   1596  8290		       a5 eb		      LDA	f
   1597  8292		       29 fe		      AND	#254
   1598  8294		       85 eb		      STA	f
   1599  8296				   .skip11then
   1600  8296				   .skipL089
   1601  8296				   .
   1602  8296							;; 
   1603  8296
   1604  8296				   .moveLeft
   1605  8296							;; moveLeft
   1606  8296
   1607  8296				   .L090		;;  playerX  =  playerX  -  playerVelocityX
   1608  8296
   1609  8296		       a5 e7		      LDA	b
   1610  8298		       38		      SEC
   1611  8299		       e5 ef		      SBC	j
   1612  829b		       85 e7		      STA	b
   1613  829d		       a5 e6		      LDA	playerX
   1614  829f		       e5 ee		      SBC	playerVelocityX
   1615  82a1		       85 e6		      STA	playerX
   1616  82a3				   .
   1617  82a3							;; 
   1618  82a3
   1619  82a3				   .L091		;;  x	=  _left
   1620  82a3
   1621  82a3							; complex statement detected
   1622  82a3		       a5 e6		      LDA	playerXInt
   1623  82a5		       38		      SEC
   1624  82a6		       e5 f1		      SBC	fineScrollX
   1625  82a8		       38		      SEC
   1626  82a9		       e9 f8		      SBC	#screenOffsetX
   1627  82ab		       a0 08		      LDY	#tileWidth
   1628  82ad		       20 11 f4 	      jsr	div8
   1629  82b0		       18		      CLC
   1630  82b1		       65 f0		      ADC	coarseScrollX
   1631  82b3		       85 fd		      STA	x
   1632  82b5				   .L092		;;  y	=  _top
   1633  82b5
   1634  82b5							; complex statement detected
   1635  82b5		       a5 e8		      LDA	playerYInt
   1636  82b7		       38		      SEC
   1637  82b8		       e9 20		      SBC	#screenOffsetY
   1638  82ba		       a0 10		      LDY	#tileHeight
   1639  82bc		       20 11 f4 	      jsr	div8
   1640  82bf		       85 fe		      STA	y
   1641  82c1				   .L093		;;  charValue	=  peekchar (  tileMap ,  x ,  y ,  255 ,  12  ) 
   1642  82c1
   1643  82c1		       a4 fe		      ldy	y
   1644  82c3		       b9 08 ef 	      lda	tileMap_mult_lo,y
   1645  82c6		       85 42		      sta	temp1
   1646  82c8		       b9 14 ef 	      lda	tileMap_mult_hi,y
   1647  82cb		       85 43		      sta	temp2
   1648  82cd		       a4 fd		      ldy	x
   1649  82cf		       b1 42		      lda	(temp1),y
   1650  82d1		       85 ea		      STA	charValue
   1651  82d3				   .L094		;;  if charValue  =  bgTile then goto hitLeftWall
   1652  82d3
   1653  82d3		       a5 ea		      LDA	charValue
   1654  82d5		       c9 06		      CMP	#bgTile
   1655  82d7		       d0 03		      BNE	.skipL094
   1656  82d9				   .condpart13
   1657  82d9		       4c 09 83 	      jmp	.hitLeftWall
   1658  82dc
   1659  82dc				   .skipL094
   1660  82dc				   .
   1661  82dc							;; 
   1662  82dc
   1663  82dc				   .L095		;;  y	=  _bottom
   1664  82dc
   1665  82dc							; complex statement detected
   1666  82dc		       a5 e8		      LDA	playerYInt
   1667  82de		       38		      SEC
   1668  82df		       e9 20		      SBC	#screenOffsetY
   1669  82e1		       18		      CLC
   1670  82e2		       69 0f		      ADC	#playerHeightMinusOne
   1671  82e4		       a0 10		      LDY	#tileHeight
   1672  82e6		       20 11 f4 	      jsr	div8
   1673  82e9		       85 fe		      STA	y
   1674  82eb				   .L096		;;  charValue	=  peekchar (  tileMap ,  x ,  y ,  255 ,  12  ) 
   1675  82eb
   1676  82eb		       a4 fe		      ldy	y
   1677  82ed		       b9 08 ef 	      lda	tileMap_mult_lo,y
   1678  82f0		       85 42		      sta	temp1
   1679  82f2		       b9 14 ef 	      lda	tileMap_mult_hi,y
   1680  82f5		       85 43		      sta	temp2
   1681  82f7		       a4 fd		      ldy	x
   1682  82f9		       b1 42		      lda	(temp1),y
   1683  82fb		       85 ea		      STA	charValue
   1684  82fd				   .L097		;;  if charValue  =  bgTile then goto hitLeftWall
   1685  82fd
   1686  82fd		       a5 ea		      LDA	charValue
   1687  82ff		       c9 06		      CMP	#bgTile
   1688  8301		       d0 03		      BNE	.skipL097
   1689  8303				   .condpart14
   1690  8303		       4c 09 83 	      jmp	.hitLeftWall
   1691  8306
   1692  8306				   .skipL097
   1693  8306				   .L098		;;  goto noLeftWall
   1694  8306
   1695  8306		       4c 28 83 	      jmp	.noLeftWall
   1696  8309
   1697  8309				   .
   1698  8309							;; 
   1699  8309
   1700  8309				   .hitLeftWall
   1701  8309							;; hitLeftWall
   1702  8309
   1703  8309				   .L099		;;  playerXInt  =  playerXInt	+   ( tileWidth  -  playerXInt	&  tileWidthMask ) 
   1704  8309
   1705  8309							; complex statement detected
   1706  8309		       a5 e6		      LDA	playerXInt
   1707  830b		       48		      PHA
   1708  830c		       a9 08		      LDA	#tileWidth
   1709  830e		       38		      SEC
   1710  830f		       e5 e6		      SBC	playerXInt
   1711  8311		       29 07		      AND	#tileWidthMask
   1712  8313		       ba		      TSX
   1713  8314		       e8		      INX
   1714  8315		       18		      CLC
   1715  8316		       7d 00 01 	      ADC	$100,x
   1716  8319		       9a		      TXS
   1717  831a		       85 e6		      STA	playerXInt
   1718  831c				   .
   1719  831c							;; 
   1720  831c
   1721  831c				   .L0100		;;  leftSlide	=  0
   1722  831c
   1723  831c		       a5 eb		      LDA	f
   1724  831e		       29 fe		      AND	#254
   1725  8320		       85 eb		      STA	f
   1726  8322				   .L0101		;;  playerVelocityXInt  =  0  :  playerVelocityXFrac  =  0
   1727  8322
   1728  8322		       a9 00		      LDA	#0
   1729  8324		       85 ee		      STA	playerVelocityXInt
   1730  8326		       85 ef		      STA	playerVelocityXFrac
   1731  8328				   .
   1732  8328							;; 
   1733  8328
   1734  8328				   .noLeftWall
   1735  8328							;; noLeftWall
   1736  8328
   1737  8328				   .L0102		;;  if playerXInt  +  8  <=  8 then scrollCounter  =  152  :  gosub scrollLeft
   1738  8328
   1739  8328							; complex condition detected
   1740  8328		       a5 e6		      LDA	playerXInt
   1741  832a		       18		      CLC
   1742  832b		       69 08		      ADC	#8
   1743  832d		       48		      PHA
   1744  832e		       ba		      TSX
   1745  832f		       68		      PLA
   1746  8330		       a9 08		      LDA	#8
   1747  8332		       dd 01 01 	      CMP	$101,x
   1748  8335		       90 07		      BCC	.skipL0102
   1749  8337				   .condpart15
   1750  8337		       a9 98		      LDA	#152
   1751  8339		       85 f4		      STA	scrollCounter
   1752  833b		       20 c5 85 	      jsr	.scrollLeft
   1753  833e
   1754  833e				   .skipL0102
   1755  833e				   .skipSlideLeft
   1756  833e							;; skipSlideLeft
   1757  833e
   1758  833e				   .skipLeft
   1759  833e							;; skipLeft
   1760  833e
   1761  833e				   .
   1762  833e							;; 
   1763  833e
   1764  833e				   .
   1765  833e							;; 
   1766  833e
   1767  833e				   .
   1768  833e							;; 
   1769  833e
   1770  833e				   .L0103		;;  temp1  =  enemy1XInt  +  windowX
   1771  833e
   1772  833e		       a5 f7		      LDA	enemy1XInt
   1773  8340		       18		      CLC
   1774  8341		       65 f5		      ADC	windowX
   1775  8343		       85 42		      STA	temp1
   1776  8345				   .L0104		;;  if temp1  =  200 then enemy1Left  =  1
   1777  8345
   1778  8345		       a5 42		      LDA	temp1
   1779  8347		       c9 c8		      CMP	#200
   1780  8349		       d0 06		      BNE	.skipL0104
   1781  834b				   .condpart16
   1782  834b		       a5 f9		      LDA	t
   1783  834d		       09 01		      ORA	#1
   1784  834f		       85 f9		      STA	t
   1785  8351				   .skipL0104
   1786  8351				   .L0105		;;  if temp1  =  16 then enemy1Left  =  0
   1787  8351
   1788  8351		       a5 42		      LDA	temp1
   1789  8353		       c9 10		      CMP	#16
   1790  8355		       d0 06		      BNE	.skipL0105
   1791  8357				   .condpart17
   1792  8357		       a5 f9		      LDA	t
   1793  8359		       29 fe		      AND	#254
   1794  835b		       85 f9		      STA	t
   1795  835d				   .skipL0105
   1796  835d				   .L0106		;;  if enemy1Left then enemy1X  =  enemy1X  -	0.00390625 else enemy1X  =  enemy1X  +	0.00390625
   1797  835d
   1798  835d		       a5 f9		      LDA	t
   1799  835f		       4a		      LSR
   1800  8360		       90 10		      BCC	.skipL0106
   1801  8362				   .condpart18
   1802  8362		       a5 f7		      LDA	r
   1803  8364		       38		      SEC
   1804  8365		       e9 01		      SBC	#1
   1805  8367		       85 f7		      STA	r
   1806  8369		       a5 f6		      LDA	enemy1X
   1807  836b		       e9 00		      SBC	#0
   1808  836d		       85 f6		      STA	enemy1X
   1809  836f		       4c 7f 83 	      jmp	.skipelse0
   1810  8372				   .skipL0106
   1811  8372		       a5 f7		      LDA	r
   1812  8374		       18		      CLC
   1813  8375		       69 01		      ADC	#1
   1814  8377		       85 f7		      STA	r
   1815  8379		       a5 f6		      LDA	enemy1X
   1816  837b		       69 00		      ADC	#0
   1817  837d		       85 f6		      STA	enemy1X
   1818  837f				   .skipelse0
   1819  837f				   .
   1820  837f							;; 
   1821  837f
   1822  837f				   .
   1823  837f							;; 
   1824  837f
   1825  837f				   .L0107		;;  fineScrollX  =  fineScrollX  &  7
   1826  837f
   1827  837f		       a5 f1		      LDA	fineScrollX
   1828  8381		       29 07		      AND	#7
   1829  8383		       85 f1		      STA	fineScrollX
   1830  8385				   .
   1831  8385							;; 
   1832  8385
   1833  8385				   .L0108		;;  if !jumpRestrainer  &&  joy0fire0 then jumpRestrainer  =  1  :  movingUp  =  1  :	playerVelocityY  =  4.25
   1834  8385
   1835  8385		       a5 eb		      LDA	f
   1836  8387		       29 08		      AND	#8
   1837  8389		       d0 19		      BNE	.skipL0108
   1838  838b				   .condpart19
   1839  838b		       2c 02 21 	      bit	sINPT1
   1840  838e		       50 14		      BVC	.skip19then
   1841  8390				   .condpart20
   1842  8390		       a5 eb		      LDA	f
   1843  8392		       09 08		      ORA	#8
   1844  8394		       85 eb		      STA	f
   1845  8396		       a5 eb		      LDA	f
   1846  8398		       09 04		      ORA	#4
   1847  839a		       85 eb		      STA	f
   1848  839c		       a2 40		      LDX	#64
   1849  839e		       86 ed		      STX	h
   1850  83a0		       a9 04		      LDA	#4
   1851  83a2		       85 ec		      STA	playerVelocityY
   1852  83a4				   .skip19then
   1853  83a4				   .skipL0108
   1854  83a4				   .L0109		;;  if !movingUp then gosub __down else gosub __up
   1855  83a4
   1856  83a4		       a5 eb		      LDA	f
   1857  83a6		       29 04		      AND	#4
   1858  83a8		       d0 06		      BNE	.skipL0109
   1859  83aa				   .condpart21
   1860  83aa		       20 49 84 	      jsr	.__down
   1861  83ad		       4c b3 83 	      jmp	.skipelse1
   1862  83b0				   .skipL0109
   1863  83b0		       20 fd 84 	      jsr	.__up
   1864  83b3
   1865  83b3				   .skipelse1
   1866  83b3				   .
   1867  83b3							;; 
   1868  83b3
   1869  83b3				   .
   1870  83b3							;; 
   1871  83b3
   1872  83b3				   .L0110		;;  restorescreen
   1873  83b3
   1874  83b3		       20 99 f0 	      jsr	restorescreen
   1875  83b6				   .
   1876  83b6							;; 
   1877  83b6
   1878  83b6				   .
   1879  83b6							;; 
   1880  83b6
   1881  83b6				   .
   1882  83b6							;; 
   1883  83b6
   1884  83b6				   .L0111		;;  if enemy1Visible  =  0  &&  enemy1XInt  +	8  >=  0  &&  enemy1XInt  <=  168 then x  =  enemy1XInt  -  8  :  plotsprite enemySprite 4 x enemy1Y 0 1
   1885  83b6
   1886  83b6		       a5 f6		      LDA	enemy1Visible
   1887  83b8		       c9 00		      CMP	#0
   1888  83ba		       d0 31		      BNE	.skipL0111
   1889  83bc				   .condpart22
   1890  83bc							; complex condition detected
   1891  83bc		       a5 f7		      LDA	enemy1XInt
   1892  83be		       18		      CLC
   1893  83bf		       69 08		      ADC	#8
   1894  83c1							; todo: this LDA is spurious and should be prevented ->	LDA  $101,x
   1895  83c1		       c9 00		      CMP	#0
   1896  83c3		       90 28		      BCC	.skip22then
   1897  83c5				   .condpart23
   1898  83c5		       a9 a8		      LDA	#168
   1899  83c7		       c5 f7		      CMP	enemy1XInt
   1900  83c9		       90 22		      BCC	.skip23then
   1901  83cb				   .condpart24
   1902  83cb		       a5 f7		      LDA	enemy1XInt
   1903  83cd		       38		      SEC
   1904  83ce		       e9 08		      SBC	#8
   1905  83d0		       85 fd		      STA	x
   1906  83d2		       a9 02		      lda	#<enemySprite
   1907  83d4		       85 42		      sta	temp1
   1908  83d6
   1909  83d6		       a9 e0		      lda	#>enemySprite
   1910  83d8		       85 43		      sta	temp2
   1911  83da
   1912  83da		       a9 9e		      lda	#(128|enemySprite_width_twoscompliment)
   1913  83dc		       85 44		      sta	temp3
   1914  83de
   1915  83de		       a5 fd		      lda	x
   1916  83e0		       85 45		      sta	temp4
   1917  83e2
   1918  83e2		       a5 f8		      lda	enemy1Y
   1919  83e4		       85 46		      sta	temp5
   1920  83e6
   1921  83e6		       a9 40		      lda	#(enemySprite_mode|%01000000)
   1922  83e8		       85 47		      sta	temp6
   1923  83ea
   1924  83ea		       20 dc f2 	      jsr	plotsprite
   1925  83ed				   .skip23then
   1926  83ed				   .skip22then
   1927  83ed				   .skipL0111
   1928  83ed				   .L0112		;;  plotsprite playerSprite 3 playerXInt playerYInt 0 1
   1929  83ed
   1930  83ed		       a9 00		      lda	#<playerSprite
   1931  83ef		       85 42		      sta	temp1
   1932  83f1
   1933  83f1		       a9 e0		      lda	#>playerSprite
   1934  83f3		       85 43		      sta	temp2
   1935  83f5
   1936  83f5		       a9 7e		      lda	#(96|playerSprite_width_twoscompliment)
   1937  83f7		       85 44		      sta	temp3
   1938  83f9
   1939  83f9		       a5 e6		      lda	playerXInt
   1940  83fb		       85 45		      sta	temp4
   1941  83fd
   1942  83fd		       a5 e8		      lda	playerYInt
   1943  83ff		       85 46		      sta	temp5
   1944  8401
   1945  8401		       a9 40		      lda	#(playerSprite_mode|%01000000)
   1946  8403		       85 47		      sta	temp6
   1947  8405
   1948  8405		       20 dc f2 	      jsr	plotsprite
   1949  8408				   .
   1950  8408							;; 
   1951  8408
   1952  8408				   .L0113		;;  doublebuffer flip
   1953  8408
   1954  8408		       20 45 f5 	      jsr	flipdisplaybuffer
   1955  840b				   .
   1956  840b							;; 
   1957  840b
   1958  840b				   .L0114		;;  goto main
   1959  840b
   1960  840b		       4c 51 81 	      jmp	.main
   1961  840e
   1962  840e				   .
   1963  840e							;; 
   1964  840e
   1965  840e				   .clearPalettes
   1966  840e							;; clearPalettes
   1967  840e
   1968  840e				   .L0115		;;  BACKGRND  =  $00
   1969  840e
   1970  840e		       a9 00		      LDA	#$00
   1971  8410		       85 20		      STA	BACKGRND
   1972  8412				   .
   1973  8412							;; 
   1974  8412
   1975  8412				   .L0116		;;  P0C1  =  $00  :  P0C2  =  $00  :  P0C3  =	$00  :	P1C1  =  $00  :  P1C2  =  $00  :  P1C3	=  $00	:  P2C1  =  $00  :  P2C2  =  $00  :  P2C3  =  $00
   1976  8412
   1977  8412		       a9 00		      LDA	#$00
   1978  8414		       85 21		      STA	P0C1
   1979  8416		       85 22		      STA	P0C2
   1980  8418		       85 23		      STA	P0C3
   1981  841a		       85 25		      STA	P1C1
   1982  841c		       85 26		      STA	P1C2
   1983  841e		       85 27		      STA	P1C3
   1984  8420		       85 29		      STA	P2C1
   1985  8422		       85 2a		      STA	P2C2
   1986  8424		       85 2b		      STA	P2C3
   1987  8426				   .L0117		;;  P3C1  =  $00  :  P3C2  =  $00  :  P3C3  =	$00  :	P4C1  =  $00  :  P4C2  =  $00  :  P4C3	=  $00	:  P5C1  =  $00  :  P5C2  =  $00  :  P5C3  =  $00
   1988  8426
   1989  8426		       a9 00		      LDA	#$00
   1990  8428		       85 2d		      STA	P3C1
   1991  842a		       85 2e		      STA	P3C2
   1992  842c		       85 2f		      STA	P3C3
   1993  842e		       85 31		      STA	P4C1
   1994  8430		       85 32		      STA	P4C2
   1995  8432		       85 33		      STA	P4C3
   1996  8434		       85 35		      STA	P5C1
   1997  8436		       85 36		      STA	P5C2
   1998  8438		       85 37		      STA	P5C3
   1999  843a				   .L0118		;;  P6C1  =  $00  :  P6C2  =  $00  :  P6C3  =	$00  :	P7C1  =  $00  :  P7C2  =  $00  :  P7C3	=  $00
   2000  843a
   2001  843a		       a9 00		      LDA	#$00
   2002  843c		       85 39		      STA	P6C1
   2003  843e		       85 3a		      STA	P6C2
   2004  8440		       85 3b		      STA	P6C3
   2005  8442		       85 3d		      STA	P7C1
   2006  8444		       85 3e		      STA	P7C2
   2007  8446		       85 3f		      STA	P7C3
   2008  8448				   .
   2009  8448							;; 
   2010  8448
   2011  8448				   .L0119		;;  return thisbank
   2012  8448
   2013  8448		       60		      RTS
   2014  8449				   .
   2015  8449							;; 
   2016  8449
   2017  8449				   .
   2018  8449							;; 
   2019  8449
   2020  8449				   .__down
   2021  8449							;; __down
   2022  8449
   2023  8449				   .L0120		;;  playerVelocityY  =  playerVelocityY  -  accelerationY
   2024  8449
   2025  8449		       a5 ed		      LDA	h
   2026  844b		       38		      SEC
   2027  844c		       e9 40		      SBC	#64
   2028  844e		       85 ed		      STA	h
   2029  8450		       a5 ec		      LDA	playerVelocityY
   2030  8452		       e9 00		      SBC	#0
   2031  8454		       85 ec		      STA	playerVelocityY
   2032  8456				   .L0121		;;  playerY  =  playerY  -  playerVelocityY
   2033  8456
   2034  8456		       a5 e9		      LDA	d
   2035  8458		       38		      SEC
   2036  8459		       e5 ed		      SBC	h
   2037  845b		       85 e9		      STA	d
   2038  845d		       a5 e8		      LDA	playerY
   2039  845f		       e5 ec		      SBC	playerVelocityY
   2040  8461		       85 e8		      STA	playerY
   2041  8463				   .
   2042  8463							;; 
   2043  8463
   2044  8463				   .
   2045  8463							;; 
   2046  8463
   2047  8463				   .
   2048  8463							;; 
   2049  8463
   2050  8463				   .L0122		;;  y	=  _bottom
   2051  8463
   2052  8463							; complex statement detected
   2053  8463		       a5 e8		      LDA	playerYInt
   2054  8465		       38		      SEC
   2055  8466		       e9 20		      SBC	#screenOffsetY
   2056  8468		       18		      CLC
   2057  8469		       69 0f		      ADC	#playerHeightMinusOne
   2058  846b		       a0 10		      LDY	#tileHeight
   2059  846d		       20 11 f4 	      jsr	div8
   2060  8470		       85 fe		      STA	y
   2061  8472				   .L0123		;;  x	=  _left
   2062  8472
   2063  8472							; complex statement detected
   2064  8472		       a5 e6		      LDA	playerXInt
   2065  8474		       38		      SEC
   2066  8475		       e5 f1		      SBC	fineScrollX
   2067  8477		       38		      SEC
   2068  8478		       e9 f8		      SBC	#screenOffsetX
   2069  847a		       a0 08		      LDY	#tileWidth
   2070  847c		       20 11 f4 	      jsr	div8
   2071  847f		       18		      CLC
   2072  8480		       65 f0		      ADC	coarseScrollX
   2073  8482		       85 fd		      STA	x
   2074  8484				   .L0124		;;  charValue	=  peekchar (  tileMap ,  x ,  y ,  255 ,  12  ) 
   2075  8484
   2076  8484		       a4 fe		      ldy	y
   2077  8486		       b9 08 ef 	      lda	tileMap_mult_lo,y
   2078  8489		       85 42		      sta	temp1
   2079  848b		       b9 14 ef 	      lda	tileMap_mult_hi,y
   2080  848e		       85 43		      sta	temp2
   2081  8490		       a4 fd		      ldy	x
   2082  8492		       b1 42		      lda	(temp1),y
   2083  8494		       85 ea		      STA	charValue
   2084  8496				   .L0125		;;  if charValue  =  bgTile then goto skipMovingDown
   2085  8496
   2086  8496		       a5 ea		      LDA	charValue
   2087  8498		       c9 06		      CMP	#bgTile
   2088  849a		       d0 03		      BNE	.skipL0125
   2089  849c				   .condpart25
   2090  849c		       4c d9 84 	      jmp	.skipMovingDown
   2091  849f
   2092  849f				   .skipL0125
   2093  849f				   .
   2094  849f							;; 
   2095  849f
   2096  849f				   .L0126		;;  x	=  _right
   2097  849f
   2098  849f							; complex statement detected
   2099  849f		       a5 e6		      LDA	playerXInt
   2100  84a1		       38		      SEC
   2101  84a2		       e5 f1		      SBC	fineScrollX
   2102  84a4		       38		      SEC
   2103  84a5		       e9 f8		      SBC	#screenOffsetX
   2104  84a7		       18		      CLC
   2105  84a8		       69 07		      ADC	#playerWidthMinusOne
   2106  84aa		       a0 08		      LDY	#tileWidth
   2107  84ac		       20 11 f4 	      jsr	div8
   2108  84af		       18		      CLC
   2109  84b0		       65 f0		      ADC	coarseScrollX
   2110  84b2		       85 fd		      STA	x
   2111  84b4				   .L0127		;;  charValue	=  peekchar (  tileMap ,  x ,  y ,  255 ,  12  ) 
   2112  84b4
   2113  84b4		       a4 fe		      ldy	y
   2114  84b6		       b9 08 ef 	      lda	tileMap_mult_lo,y
   2115  84b9		       85 42		      sta	temp1
   2116  84bb		       b9 14 ef 	      lda	tileMap_mult_hi,y
   2117  84be		       85 43		      sta	temp2
   2118  84c0		       a4 fd		      ldy	x
   2119  84c2		       b1 42		      lda	(temp1),y
   2120  84c4		       85 ea		      STA	charValue
   2121  84c6				   .L0128		;;  if charValue  =  bgTile then goto skipMovingDown
   2122  84c6
   2123  84c6		       a5 ea		      LDA	charValue
   2124  84c8		       c9 06		      CMP	#bgTile
   2125  84ca		       d0 03		      BNE	.skipL0128
   2126  84cc				   .condpart26
   2127  84cc		       4c d9 84 	      jmp	.skipMovingDown
   2128  84cf
   2129  84cf				   .skipL0128
   2130  84cf				   .L0129		;;  return
   2131  84cf
   2132  84cf		       ba		      tsx
   2133  84d0		       bd 02 01 	      lda	$102,x
   2134  84d3		       f0 01		      beq	bankswitchret16
   2135  84d5		       60		      RTS
   2136  84d6				   bankswitchret16
   2137  84d6		       4c 5a f4 	      JMP	BS_return
   2138  84d9				   .
   2139  84d9							;; 
   2140  84d9
   2141  84d9				   .skipMovingDown
   2142  84d9							;; skipMovingDown
   2143  84d9
   2144  84d9				   .L0130		;;  playerYInt  =  playerYInt	-   ( playerYInt  &  tileHeightMask ) 
   2145  84d9
   2146  84d9							; complex statement detected
   2147  84d9		       a5 e8		      LDA	playerYInt
   2148  84db		       48		      PHA
   2149  84dc		       29 0f		      AND	#tileHeightMask
   2150  84de		       a8		      TAY
   2151  84df		       68		      PLA
   2152  84e0		       84 5a		      STY	tempmath
   2153  84e2		       38		      SEC
   2154  84e3		       e5 5a		      SBC	tempmath
   2155  84e5		       85 e8		      STA	playerYInt
   2156  84e7				   .
   2157  84e7							;; 
   2158  84e7
   2159  84e7				   .L0131		;;  playerVelocityYInt  =  0  :  playerVelocityYFrac  =  0
   2160  84e7
   2161  84e7		       a9 00		      LDA	#0
   2162  84e9		       85 ec		      STA	playerVelocityYInt
   2163  84eb		       85 ed		      STA	playerVelocityYFrac
   2164  84ed				   .L0132		;;  jumpRestrainer  =	0
   2165  84ed
   2166  84ed		       a5 eb		      LDA	f
   2167  84ef		       29 f7		      AND	#247
   2168  84f1		       85 eb		      STA	f
   2169  84f3				   .L0133		;;  return
   2170  84f3
   2171  84f3		       ba		      tsx
   2172  84f4		       bd 02 01 	      lda	$102,x
   2173  84f7		       f0 01		      beq	bankswitchret17
   2174  84f9		       60		      RTS
   2175  84fa				   bankswitchret17
   2176  84fa		       4c 5a f4 	      JMP	BS_return
   2177  84fd				   .
   2178  84fd							;; 
   2179  84fd
   2180  84fd				   .
   2181  84fd							;; 
   2182  84fd
   2183  84fd				   .__up
   2184  84fd							;; __up
   2185  84fd
   2186  84fd				   .L0134		;;  playerVelocityY  =  playerVelocityY  -  accelerationY
   2187  84fd
   2188  84fd		       a5 ed		      LDA	h
   2189  84ff		       38		      SEC
   2190  8500		       e9 40		      SBC	#64
   2191  8502		       85 ed		      STA	h
   2192  8504		       a5 ec		      LDA	playerVelocityY
   2193  8506		       e9 00		      SBC	#0
   2194  8508		       85 ec		      STA	playerVelocityY
   2195  850a				   .L0135		;;  playerY  =  playerY  -  playerVelocityY
   2196  850a
   2197  850a		       a5 e9		      LDA	d
   2198  850c		       38		      SEC
   2199  850d		       e5 ed		      SBC	h
   2200  850f		       85 e9		      STA	d
   2201  8511		       a5 e8		      LDA	playerY
   2202  8513		       e5 ec		      SBC	playerVelocityY
   2203  8515		       85 e8		      STA	playerY
   2204  8517				   .L0136		;;  if playerVelocityYInt  =  0  &&  playerVelocityYFrac  =  0 then movingUp  =  0
   2205  8517
   2206  8517		       a5 ec		      LDA	playerVelocityYInt
   2207  8519		       c9 00		      CMP	#0
   2208  851b		       d0 0c		      BNE	.skipL0136
   2209  851d				   .condpart27
   2210  851d		       a5 ed		      LDA	playerVelocityYFrac
   2211  851f		       c9 00		      CMP	#0
   2212  8521		       d0 06		      BNE	.skip27then
   2213  8523				   .condpart28
   2214  8523		       a5 eb		      LDA	f
   2215  8525		       29 fb		      AND	#251
   2216  8527		       85 eb		      STA	f
   2217  8529				   .skip27then
   2218  8529				   .skipL0136
   2219  8529				   .
   2220  8529							;; 
   2221  8529
   2222  8529				   .
   2223  8529							;; 
   2224  8529
   2225  8529				   .
   2226  8529							;; 
   2227  8529
   2228  8529				   .L0137		;;  y	=  _top
   2229  8529
   2230  8529							; complex statement detected
   2231  8529		       a5 e8		      LDA	playerYInt
   2232  852b		       38		      SEC
   2233  852c		       e9 20		      SBC	#screenOffsetY
   2234  852e		       a0 10		      LDY	#tileHeight
   2235  8530		       20 11 f4 	      jsr	div8
   2236  8533		       85 fe		      STA	y
   2237  8535				   .L0138		;;  x	=  _left
   2238  8535
   2239  8535							; complex statement detected
   2240  8535		       a5 e6		      LDA	playerXInt
   2241  8537		       38		      SEC
   2242  8538		       e5 f1		      SBC	fineScrollX
   2243  853a		       38		      SEC
   2244  853b		       e9 f8		      SBC	#screenOffsetX
   2245  853d		       a0 08		      LDY	#tileWidth
   2246  853f		       20 11 f4 	      jsr	div8
   2247  8542		       18		      CLC
   2248  8543		       65 f0		      ADC	coarseScrollX
   2249  8545		       85 fd		      STA	x
   2250  8547				   .L0139		;;  charValue	=  peekchar (  tileMap ,  x ,  y ,  255 ,  12  ) 
   2251  8547
   2252  8547		       a4 fe		      ldy	y
   2253  8549		       b9 08 ef 	      lda	tileMap_mult_lo,y
   2254  854c		       85 42		      sta	temp1
   2255  854e		       b9 14 ef 	      lda	tileMap_mult_hi,y
   2256  8551		       85 43		      sta	temp2
   2257  8553		       a4 fd		      ldy	x
   2258  8555		       b1 42		      lda	(temp1),y
   2259  8557		       85 ea		      STA	charValue
   2260  8559				   .L0140		;;  if charValue  =  bgTile then goto skipMovingUp
   2261  8559
   2262  8559		       a5 ea		      LDA	charValue
   2263  855b		       c9 06		      CMP	#bgTile
   2264  855d		       d0 03		      BNE	.skipL0140
   2265  855f				   .condpart29
   2266  855f		       4c 9c 85 	      jmp	.skipMovingUp
   2267  8562
   2268  8562				   .skipL0140
   2269  8562				   .
   2270  8562							;; 
   2271  8562
   2272  8562				   .L0141		;;  x	=  _right
   2273  8562
   2274  8562							; complex statement detected
   2275  8562		       a5 e6		      LDA	playerXInt
   2276  8564		       38		      SEC
   2277  8565		       e5 f1		      SBC	fineScrollX
   2278  8567		       38		      SEC
   2279  8568		       e9 f8		      SBC	#screenOffsetX
   2280  856a		       18		      CLC
   2281  856b		       69 07		      ADC	#playerWidthMinusOne
   2282  856d		       a0 08		      LDY	#tileWidth
   2283  856f		       20 11 f4 	      jsr	div8
   2284  8572		       18		      CLC
   2285  8573		       65 f0		      ADC	coarseScrollX
   2286  8575		       85 fd		      STA	x
   2287  8577				   .L0142		;;  charValue	=  peekchar (  tileMap ,  x ,  y ,  255 ,  12  ) 
   2288  8577
   2289  8577		       a4 fe		      ldy	y
   2290  8579		       b9 08 ef 	      lda	tileMap_mult_lo,y
   2291  857c		       85 42		      sta	temp1
   2292  857e		       b9 14 ef 	      lda	tileMap_mult_hi,y
   2293  8581		       85 43		      sta	temp2
   2294  8583		       a4 fd		      ldy	x
   2295  8585		       b1 42		      lda	(temp1),y
   2296  8587		       85 ea		      STA	charValue
   2297  8589				   .L0143		;;  if charValue  =  bgTile then goto skipMovingUp
   2298  8589
   2299  8589		       a5 ea		      LDA	charValue
   2300  858b		       c9 06		      CMP	#bgTile
   2301  858d		       d0 03		      BNE	.skipL0143
   2302  858f				   .condpart30
   2303  858f		       4c 9c 85 	      jmp	.skipMovingUp
   2304  8592
   2305  8592				   .skipL0143
   2306  8592				   .L0144		;;  return
   2307  8592
   2308  8592		       ba		      tsx
   2309  8593		       bd 02 01 	      lda	$102,x
   2310  8596		       f0 01		      beq	bankswitchret18
   2311  8598		       60		      RTS
   2312  8599				   bankswitchret18
   2313  8599		       4c 5a f4 	      JMP	BS_return
   2314  859c				   .
   2315  859c							;; 
   2316  859c
   2317  859c				   .skipMovingUp
   2318  859c							;; skipMovingUp
   2319  859c
   2320  859c				   .L0145		;;  playerYInt  =  playerYInt	+   ( tileHeight  -  playerYInt  &  tileHeightMask ) 
   2321  859c
   2322  859c							; complex statement detected
   2323  859c		       a5 e8		      LDA	playerYInt
   2324  859e		       48		      PHA
   2325  859f		       a9 10		      LDA	#tileHeight
   2326  85a1		       38		      SEC
   2327  85a2		       e5 e8		      SBC	playerYInt
   2328  85a4		       29 0f		      AND	#tileHeightMask
   2329  85a6		       ba		      TSX
   2330  85a7		       e8		      INX
   2331  85a8		       18		      CLC
   2332  85a9		       7d 00 01 	      ADC	$100,x
   2333  85ac		       9a		      TXS
   2334  85ad		       85 e8		      STA	playerYInt
   2335  85af				   .
   2336  85af							;; 
   2337  85af
   2338  85af				   .L0146		;;  playerVelocityYInt  =  0  :  playerVelocityYFrac  =  0
   2339  85af
   2340  85af		       a9 00		      LDA	#0
   2341  85b1		       85 ec		      STA	playerVelocityYInt
   2342  85b3		       85 ed		      STA	playerVelocityYFrac
   2343  85b5				   .L0147		;;  movingUp  =  0
   2344  85b5
   2345  85b5		       a5 eb		      LDA	f
   2346  85b7		       29 fb		      AND	#251
   2347  85b9		       85 eb		      STA	f
   2348  85bb				   .L0148		;;  return
   2349  85bb
   2350  85bb		       ba		      tsx
   2351  85bc		       bd 02 01 	      lda	$102,x
   2352  85bf		       f0 01		      beq	bankswitchret19
   2353  85c1		       60		      RTS
   2354  85c2				   bankswitchret19
   2355  85c2		       4c 5a f4 	      JMP	BS_return
   2356  85c5				   .
   2357  85c5							;; 
   2358  85c5
   2359  85c5				   .
   2360  85c5							;; 
   2361  85c5
   2362  85c5				   .scrollLeft
   2363  85c5							;; scrollLeft
   2364  85c5
   2365  85c5				   .L0149		;;  if coarseScrollX  =  0 then return
   2366  85c5
   2367  85c5		       a5 f0		      LDA	coarseScrollX
   2368  85c7		       c9 00		      CMP	#0
   2369  85c9		       d0 0a		      BNE	.skipL0149
   2370  85cb				   .condpart31
   2371  85cb		       ba		      tsx
   2372  85cc		       bd 02 01 	      lda	$102,x
   2373  85cf		       f0 01		      beq	bankswitchret20
   2374  85d1		       60		      RTS
   2375  85d2				   bankswitchret20
   2376  85d2		       4c 5a f4 	      JMP	BS_return
   2377  85d5				   .skipL0149
   2378  85d5				   .L0150		;;  windowX  =  windowX  -  1
   2379  85d5
   2380  85d5		       a5 f5		      LDA	windowX
   2381  85d7		       38		      SEC
   2382  85d8		       e9 01		      SBC	#1
   2383  85da		       85 f5		      STA	windowX
   2384  85dc				   .L0151		;;  if fineScrollX  =	7 then fineScrollX  =  0  :  coarseScrollX  =  coarseScrollX  -  1 else fineScrollX  =	fineScrollX  +	1
   2385  85dc
   2386  85dc		       a5 f1		      LDA	fineScrollX
   2387  85de		       c9 07		      CMP	#7
   2388  85e0		       d0 0e		      BNE	.skipL0151
   2389  85e2				   .condpart32
   2390  85e2		       a9 00		      LDA	#0
   2391  85e4		       85 f1		      STA	fineScrollX
   2392  85e6		       a5 f0		      LDA	coarseScrollX
   2393  85e8		       38		      SEC
   2394  85e9		       e9 01		      SBC	#1
   2395  85eb		       85 f0		      STA	coarseScrollX
   2396  85ed		       4c f7 85 	      jmp	.skipelse2
   2397  85f0				   .skipL0151
   2398  85f0		       a5 f1		      LDA	fineScrollX
   2399  85f2		       18		      CLC
   2400  85f3		       69 01		      ADC	#1
   2401  85f5		       85 f1		      STA	fineScrollX
   2402  85f7				   .skipelse2
   2403  85f7				   .
   2404  85f7							;; 
   2405  85f7
   2406  85f7				   .L0152		;;  playerXInt  =  playerXInt	+  1
   2407  85f7
   2408  85f7		       a5 e6		      LDA	playerXInt
   2409  85f9		       18		      CLC
   2410  85fa		       69 01		      ADC	#1
   2411  85fc		       85 e6		      STA	playerXInt
   2412  85fe				   .L0153		;;  enemy1X  =  enemy1X  +  0.00390625
   2413  85fe
   2414  85fe		       a5 f7		      LDA	r
   2415  8600		       18		      CLC
   2416  8601		       69 01		      ADC	#1
   2417  8603		       85 f7		      STA	r
   2418  8605		       a5 f6		      LDA	enemy1X
   2419  8607		       69 00		      ADC	#0
   2420  8609		       85 f6		      STA	enemy1X
   2421  860b				   .
   2422  860b							;; 
   2423  860b
   2424  860b				   .L0154		;;  temp1  =  fineScrollX  -  8
   2425  860b
   2426  860b		       a5 f1		      LDA	fineScrollX
   2427  860d		       38		      SEC
   2428  860e		       e9 08		      SBC	#8
   2429  8610		       85 42		      STA	temp1
   2430  8612				   .
   2431  8612							;; 
   2432  8612
   2433  8612				   .L0155		;;  clearscreen
   2434  8612
   2435  8612		       20 87 f0 	      jsr	clearscreen
   2436  8615				   .L0156		;;  plotmap tileMap 0 temp1 2 21 12 coarseScrollX 0 mapSize
   2437  8615
   2438  8615		       a9 0b		      lda	#11	; width in two's complement
   2439  8617		       85 44		      sta	temp3
   2440  8619		       09 00		      ora	#0	; palette left shifted 5 bits
   2441  861b		       85 44		      sta	temp3
   2442  861d		       a5 42		      lda	temp1
   2443  861f		       85 45		      sta	temp4
   2444  8621
   2445  8621		       a9 02		      lda	#2
   2446  8623		       85 46		      sta	temp5
   2447  8625
   2448  8625		       a9 0c		      lda	#12
   2449  8627		       85 47		      sta	temp6
   2450  8629		       a9 00		      lda	#<tileMap
   2451  862b		       85 42		      sta	temp1
   2452  862d
   2453  862d		       a9 40		      lda	#>tileMap
   2454  862f		       85 43		      sta	temp2
   2455  8631
   2456  8631		       a0 00		      ldy	#0
   2457  8633		       c0 00		      cpy	#0
   2458  8635		       f0 14		      beq	skipmapyadjust20
   2459  8637		       a5 f2		      lda	mapSize
   2460  8639
   2461  8639		       20 20 f4 	      jsr	mul16
   2462  863c							;result is in A, temp1 contains overflow
   2463  863c		       85 43		      sta	temp2
   2464  863e		       18		      clc
   2465  863f		       a9 00		      lda	#<tileMap
   2466  8641		       65 42		      adc	temp1
   2467  8643		       85 42		      sta	temp1
   2468  8645		       a9 40		      lda	#>tileMap
   2469  8647		       65 43		      adc	temp2
   2470  8649		       85 43		      sta	temp2
   2471  864b				   skipmapyadjust20
   2472  864b		       18		      clc
   2473  864c		       a5 f0		      lda	coarseScrollX
   2474  864e		       65 42		      adc	temp1
   2475  8650		       85 42		      sta	temp1
   2476  8652		       a9 00		      lda	#0
   2477  8654		       65 43		      adc	temp2
   2478  8656		       85 43		      sta	temp2
   2479  8658				   plotcharactersloop21
   2480  8658		       20 9f f3 	      jsr	plotcharacters
   2481  865b		       18		      clc
   2482  865c		       a5 f2		      lda	mapSize
   2483  865e
   2484  865e		       65 42		      adc	temp1
   2485  8660		       85 42		      sta	temp1
   2486  8662		       a9 00		      lda	#0
   2487  8664		       65 43		      adc	temp2
   2488  8666		       85 43		      sta	temp2
   2489  8668		       e6 46		      inc	temp5
   2490  866a		       c6 47		      dec	temp6
   2491  866c		       d0 ea		      bne	plotcharactersloop21
   2492  866e				   .L0157		;;  if enemy1Visible  =  0  &&  enemy1XInt  +	8  >=  0  &&  enemy1XInt  <=  168 then x  =  enemy1XInt  -  8  :  plotsprite enemySprite 4 x enemy1Y 0 1
   2493  866e
   2494  866e		       a5 f6		      LDA	enemy1Visible
   2495  8670		       c9 00		      CMP	#0
   2496  8672		       d0 31		      BNE	.skipL0157
   2497  8674				   .condpart33
   2498  8674							; complex condition detected
   2499  8674		       a5 f7		      LDA	enemy1XInt
   2500  8676		       18		      CLC
   2501  8677		       69 08		      ADC	#8
   2502  8679							; todo: this LDA is spurious and should be prevented ->	LDA  $101,x
   2503  8679		       c9 00		      CMP	#0
   2504  867b		       90 28		      BCC	.skip33then
   2505  867d				   .condpart34
   2506  867d		       a9 a8		      LDA	#168
   2507  867f		       c5 f7		      CMP	enemy1XInt
   2508  8681		       90 22		      BCC	.skip34then
   2509  8683				   .condpart35
   2510  8683		       a5 f7		      LDA	enemy1XInt
   2511  8685		       38		      SEC
   2512  8686		       e9 08		      SBC	#8
   2513  8688		       85 fd		      STA	x
   2514  868a		       a9 02		      lda	#<enemySprite
   2515  868c		       85 42		      sta	temp1
   2516  868e
   2517  868e		       a9 e0		      lda	#>enemySprite
   2518  8690		       85 43		      sta	temp2
   2519  8692
   2520  8692		       a9 9e		      lda	#(128|enemySprite_width_twoscompliment)
   2521  8694		       85 44		      sta	temp3
   2522  8696
   2523  8696		       a5 fd		      lda	x
   2524  8698		       85 45		      sta	temp4
   2525  869a
   2526  869a		       a5 f8		      lda	enemy1Y
   2527  869c		       85 46		      sta	temp5
   2528  869e
   2529  869e		       a9 40		      lda	#(enemySprite_mode|%01000000)
   2530  86a0		       85 47		      sta	temp6
   2531  86a2
   2532  86a2		       20 dc f2 	      jsr	plotsprite
   2533  86a5				   .skip34then
   2534  86a5				   .skip33then
   2535  86a5				   .skipL0157
   2536  86a5				   .L0158		;;  plotsprite playerSprite 3 playerXInt playerYInt 0 1
   2537  86a5
   2538  86a5		       a9 00		      lda	#<playerSprite
   2539  86a7		       85 42		      sta	temp1
   2540  86a9
   2541  86a9		       a9 e0		      lda	#>playerSprite
   2542  86ab		       85 43		      sta	temp2
   2543  86ad
   2544  86ad		       a9 7e		      lda	#(96|playerSprite_width_twoscompliment)
   2545  86af		       85 44		      sta	temp3
   2546  86b1
   2547  86b1		       a5 e6		      lda	playerXInt
   2548  86b3		       85 45		      sta	temp4
   2549  86b5
   2550  86b5		       a5 e8		      lda	playerYInt
   2551  86b7		       85 46		      sta	temp5
   2552  86b9
   2553  86b9		       a9 40		      lda	#(playerSprite_mode|%01000000)
   2554  86bb		       85 47		      sta	temp6
   2555  86bd
   2556  86bd		       20 dc f2 	      jsr	plotsprite
   2557  86c0				   .
   2558  86c0							;; 
   2559  86c0
   2560  86c0				   .L0159		;;  doublebuffer flip
   2561  86c0
   2562  86c0		       20 45 f5 	      jsr	flipdisplaybuffer
   2563  86c3				   .
   2564  86c3							;; 
   2565  86c3
   2566  86c3				   .L0160		;;  scrollCounter  =  scrollCounter  -  1
   2567  86c3
   2568  86c3		       a5 f4		      LDA	scrollCounter
   2569  86c5		       38		      SEC
   2570  86c6		       e9 01		      SBC	#1
   2571  86c8		       85 f4		      STA	scrollCounter
   2572  86ca				   .L0161		;;  if scrollCounter  >  0 then goto scrollLeft
   2573  86ca
   2574  86ca		       a9 00		      LDA	#0
   2575  86cc		       c5 f4		      CMP	scrollCounter
   2576  86ce		       b0 03		      BCS	.skipL0161
   2577  86d0				   .condpart36
   2578  86d0		       4c c5 85 	      jmp	.scrollLeft
   2579  86d3
   2580  86d3				   .skipL0161
   2581  86d3				   .
   2582  86d3							;; 
   2583  86d3
   2584  86d3				   .
   2585  86d3							;; 
   2586  86d3
   2587  86d3				   .L0162		;;  temp1  =  fineScrollX  -  8
   2588  86d3
   2589  86d3		       a5 f1		      LDA	fineScrollX
   2590  86d5		       38		      SEC
   2591  86d6		       e9 08		      SBC	#8
   2592  86d8		       85 42		      STA	temp1
   2593  86da				   .L0163		;;  clearscreen
   2594  86da
   2595  86da		       20 87 f0 	      jsr	clearscreen
   2596  86dd				   .L0164		;;  plotmap tileMap 0 temp1 2 21 12 coarseScrollX 0 mapSize
   2597  86dd
   2598  86dd		       a9 0b		      lda	#11	; width in two's complement
   2599  86df		       85 44		      sta	temp3
   2600  86e1		       09 00		      ora	#0	; palette left shifted 5 bits
   2601  86e3		       85 44		      sta	temp3
   2602  86e5		       a5 42		      lda	temp1
   2603  86e7		       85 45		      sta	temp4
   2604  86e9
   2605  86e9		       a9 02		      lda	#2
   2606  86eb		       85 46		      sta	temp5
   2607  86ed
   2608  86ed		       a9 0c		      lda	#12
   2609  86ef		       85 47		      sta	temp6
   2610  86f1		       a9 00		      lda	#<tileMap
   2611  86f3		       85 42		      sta	temp1
   2612  86f5
   2613  86f5		       a9 40		      lda	#>tileMap
   2614  86f7		       85 43		      sta	temp2
   2615  86f9
   2616  86f9		       a0 00		      ldy	#0
   2617  86fb		       c0 00		      cpy	#0
   2618  86fd		       f0 14		      beq	skipmapyadjust22
   2619  86ff		       a5 f2		      lda	mapSize
   2620  8701
   2621  8701		       20 20 f4 	      jsr	mul16
   2622  8704							;result is in A, temp1 contains overflow
   2623  8704		       85 43		      sta	temp2
   2624  8706		       18		      clc
   2625  8707		       a9 00		      lda	#<tileMap
   2626  8709		       65 42		      adc	temp1
   2627  870b		       85 42		      sta	temp1
   2628  870d		       a9 40		      lda	#>tileMap
   2629  870f		       65 43		      adc	temp2
   2630  8711		       85 43		      sta	temp2
   2631  8713				   skipmapyadjust22
   2632  8713		       18		      clc
   2633  8714		       a5 f0		      lda	coarseScrollX
   2634  8716		       65 42		      adc	temp1
   2635  8718		       85 42		      sta	temp1
   2636  871a		       a9 00		      lda	#0
   2637  871c		       65 43		      adc	temp2
   2638  871e		       85 43		      sta	temp2
   2639  8720				   plotcharactersloop23
   2640  8720		       20 9f f3 	      jsr	plotcharacters
   2641  8723		       18		      clc
   2642  8724		       a5 f2		      lda	mapSize
   2643  8726
   2644  8726		       65 42		      adc	temp1
   2645  8728		       85 42		      sta	temp1
   2646  872a		       a9 00		      lda	#0
   2647  872c		       65 43		      adc	temp2
   2648  872e		       85 43		      sta	temp2
   2649  8730		       e6 46		      inc	temp5
   2650  8732		       c6 47		      dec	temp6
   2651  8734		       d0 ea		      bne	plotcharactersloop23
   2652  8736				   .
   2653  8736							;; 
   2654  8736
   2655  8736				   .L0165		;;  savescreen
   2656  8736
   2657  8736		       20 ab f0 	      jsr	savescreen
   2658  8739				   .L0166		;;  if enemy1Visible  =  0  &&  enemy1XInt  +	8  >=  0  &&  enemy1XInt  <=  168 then x  =  enemy1XInt  -  8  :  plotsprite enemySprite 4 x enemy1Y 0 1
   2659  8739
   2660  8739		       a5 f6		      LDA	enemy1Visible
   2661  873b		       c9 00		      CMP	#0
   2662  873d		       d0 31		      BNE	.skipL0166
   2663  873f				   .condpart37
   2664  873f							; complex condition detected
   2665  873f		       a5 f7		      LDA	enemy1XInt
   2666  8741		       18		      CLC
   2667  8742		       69 08		      ADC	#8
   2668  8744							; todo: this LDA is spurious and should be prevented ->	LDA  $101,x
   2669  8744		       c9 00		      CMP	#0
   2670  8746		       90 28		      BCC	.skip37then
   2671  8748				   .condpart38
   2672  8748		       a9 a8		      LDA	#168
   2673  874a		       c5 f7		      CMP	enemy1XInt
   2674  874c		       90 22		      BCC	.skip38then
   2675  874e				   .condpart39
   2676  874e		       a5 f7		      LDA	enemy1XInt
   2677  8750		       38		      SEC
   2678  8751		       e9 08		      SBC	#8
   2679  8753		       85 fd		      STA	x
   2680  8755		       a9 02		      lda	#<enemySprite
   2681  8757		       85 42		      sta	temp1
   2682  8759
   2683  8759		       a9 e0		      lda	#>enemySprite
   2684  875b		       85 43		      sta	temp2
   2685  875d
   2686  875d		       a9 9e		      lda	#(128|enemySprite_width_twoscompliment)
   2687  875f		       85 44		      sta	temp3
   2688  8761
   2689  8761		       a5 fd		      lda	x
   2690  8763		       85 45		      sta	temp4
   2691  8765
   2692  8765		       a5 f8		      lda	enemy1Y
   2693  8767		       85 46		      sta	temp5
   2694  8769
   2695  8769		       a9 40		      lda	#(enemySprite_mode|%01000000)
   2696  876b		       85 47		      sta	temp6
   2697  876d
   2698  876d		       20 dc f2 	      jsr	plotsprite
   2699  8770				   .skip38then
   2700  8770				   .skip37then
   2701  8770				   .skipL0166
   2702  8770				   .L0167		;;  plotsprite playerSprite 3 playerXInt playerYInt 0 1
   2703  8770
   2704  8770		       a9 00		      lda	#<playerSprite
   2705  8772		       85 42		      sta	temp1
   2706  8774
   2707  8774		       a9 e0		      lda	#>playerSprite
   2708  8776		       85 43		      sta	temp2
   2709  8778
   2710  8778		       a9 7e		      lda	#(96|playerSprite_width_twoscompliment)
   2711  877a		       85 44		      sta	temp3
   2712  877c
   2713  877c		       a5 e6		      lda	playerXInt
   2714  877e		       85 45		      sta	temp4
   2715  8780
   2716  8780		       a5 e8		      lda	playerYInt
   2717  8782		       85 46		      sta	temp5
   2718  8784
   2719  8784		       a9 40		      lda	#(playerSprite_mode|%01000000)
   2720  8786		       85 47		      sta	temp6
   2721  8788
   2722  8788		       20 dc f2 	      jsr	plotsprite
   2723  878b				   .
   2724  878b							;; 
   2725  878b
   2726  878b				   .L0168		;;  return
   2727  878b
   2728  878b		       ba		      tsx
   2729  878c		       bd 02 01 	      lda	$102,x
   2730  878f		       f0 01		      beq	bankswitchret25
   2731  8791		       60		      RTS
   2732  8792				   bankswitchret25
   2733  8792		       4c 5a f4 	      JMP	BS_return
   2734  8795				   .
   2735  8795							;; 
   2736  8795
   2737  8795				   .scrollRight
   2738  8795							;; scrollRight
   2739  8795
   2740  8795				   .L0169		;;  windowX  =  windowX  +  1
   2741  8795
   2742  8795		       a5 f5		      LDA	windowX
   2743  8797		       18		      CLC
   2744  8798		       69 01		      ADC	#1
   2745  879a		       85 f5		      STA	windowX
   2746  879c				   .L0170		;;  if coarseScrollX  =  mapSize  -  20 then return
   2747  879c
   2748  879c							; complex condition detected
   2749  879c		       a5 f2		      LDA	mapSize
   2750  879e		       38		      SEC
   2751  879f		       e9 14		      SBC	#20
   2752  87a1		       48		      PHA
   2753  87a2		       ba		      TSX
   2754  87a3		       68		      PLA
   2755  87a4		       a5 f0		      LDA	coarseScrollX
   2756  87a6		       dd 01 01 	      CMP	$101,x
   2757  87a9		       d0 0a		      BNE	.skipL0170
   2758  87ab				   .condpart40
   2759  87ab		       ba		      tsx
   2760  87ac		       bd 02 01 	      lda	$102,x
   2761  87af		       f0 01		      beq	bankswitchret26
   2762  87b1		       60		      RTS
   2763  87b2				   bankswitchret26
   2764  87b2		       4c 5a f4 	      JMP	BS_return
   2765  87b5				   .skipL0170
   2766  87b5				   .L0171		;;  if fineScrollX  =	0 then fineScrollX  =  7  :  coarseScrollX  =  coarseScrollX  +  1 else fineScrollX  =	fineScrollX  -	1
   2767  87b5
   2768  87b5		       a5 f1		      LDA	fineScrollX
   2769  87b7		       c9 00		      CMP	#0
   2770  87b9		       d0 0e		      BNE	.skipL0171
   2771  87bb				   .condpart41
   2772  87bb		       a9 07		      LDA	#7
   2773  87bd		       85 f1		      STA	fineScrollX
   2774  87bf		       a5 f0		      LDA	coarseScrollX
   2775  87c1		       18		      CLC
   2776  87c2		       69 01		      ADC	#1
   2777  87c4		       85 f0		      STA	coarseScrollX
   2778  87c6		       4c d0 87 	      jmp	.skipelse3
   2779  87c9				   .skipL0171
   2780  87c9		       a5 f1		      LDA	fineScrollX
   2781  87cb		       38		      SEC
   2782  87cc		       e9 01		      SBC	#1
   2783  87ce		       85 f1		      STA	fineScrollX
   2784  87d0				   .skipelse3
   2785  87d0				   .
   2786  87d0							;; 
   2787  87d0
   2788  87d0				   .L0172		;;  playerXInt  =  playerXInt	-  1
   2789  87d0
   2790  87d0		       a5 e6		      LDA	playerXInt
   2791  87d2		       38		      SEC
   2792  87d3		       e9 01		      SBC	#1
   2793  87d5		       85 e6		      STA	playerXInt
   2794  87d7				   .L0173		;;  enemy1X  =  enemy1X  -  0.00390625
   2795  87d7
   2796  87d7		       a5 f7		      LDA	r
   2797  87d9		       38		      SEC
   2798  87da		       e9 01		      SBC	#1
   2799  87dc		       85 f7		      STA	r
   2800  87de		       a5 f6		      LDA	enemy1X
   2801  87e0		       e9 00		      SBC	#0
   2802  87e2		       85 f6		      STA	enemy1X
   2803  87e4				   .
   2804  87e4							;; 
   2805  87e4
   2806  87e4				   .L0174		;;  temp1  =  fineScrollX  -  8
   2807  87e4
   2808  87e4		       a5 f1		      LDA	fineScrollX
   2809  87e6		       38		      SEC
   2810  87e7		       e9 08		      SBC	#8
   2811  87e9		       85 42		      STA	temp1
   2812  87eb				   .
   2813  87eb							;; 
   2814  87eb
   2815  87eb				   .L0175		;;  clearscreen
   2816  87eb
   2817  87eb		       20 87 f0 	      jsr	clearscreen
   2818  87ee				   .L0176		;;  plotmap tileMap 0 temp1 2 21 12 coarseScrollX 0 mapSize
   2819  87ee
   2820  87ee		       a9 0b		      lda	#11	; width in two's complement
   2821  87f0		       85 44		      sta	temp3
   2822  87f2		       09 00		      ora	#0	; palette left shifted 5 bits
   2823  87f4		       85 44		      sta	temp3
   2824  87f6		       a5 42		      lda	temp1
   2825  87f8		       85 45		      sta	temp4
   2826  87fa
   2827  87fa		       a9 02		      lda	#2
   2828  87fc		       85 46		      sta	temp5
   2829  87fe
   2830  87fe		       a9 0c		      lda	#12
   2831  8800		       85 47		      sta	temp6
   2832  8802		       a9 00		      lda	#<tileMap
   2833  8804		       85 42		      sta	temp1
   2834  8806
   2835  8806		       a9 40		      lda	#>tileMap
   2836  8808		       85 43		      sta	temp2
   2837  880a
   2838  880a		       a0 00		      ldy	#0
   2839  880c		       c0 00		      cpy	#0
   2840  880e		       f0 14		      beq	skipmapyadjust26
   2841  8810		       a5 f2		      lda	mapSize
   2842  8812
   2843  8812		       20 20 f4 	      jsr	mul16
   2844  8815							;result is in A, temp1 contains overflow
   2845  8815		       85 43		      sta	temp2
   2846  8817		       18		      clc
   2847  8818		       a9 00		      lda	#<tileMap
   2848  881a		       65 42		      adc	temp1
   2849  881c		       85 42		      sta	temp1
   2850  881e		       a9 40		      lda	#>tileMap
   2851  8820		       65 43		      adc	temp2
   2852  8822		       85 43		      sta	temp2
   2853  8824				   skipmapyadjust26
   2854  8824		       18		      clc
   2855  8825		       a5 f0		      lda	coarseScrollX
   2856  8827		       65 42		      adc	temp1
   2857  8829		       85 42		      sta	temp1
   2858  882b		       a9 00		      lda	#0
   2859  882d		       65 43		      adc	temp2
   2860  882f		       85 43		      sta	temp2
   2861  8831				   plotcharactersloop27
   2862  8831		       20 9f f3 	      jsr	plotcharacters
   2863  8834		       18		      clc
   2864  8835		       a5 f2		      lda	mapSize
   2865  8837
   2866  8837		       65 42		      adc	temp1
   2867  8839		       85 42		      sta	temp1
   2868  883b		       a9 00		      lda	#0
   2869  883d		       65 43		      adc	temp2
   2870  883f		       85 43		      sta	temp2
   2871  8841		       e6 46		      inc	temp5
   2872  8843		       c6 47		      dec	temp6
   2873  8845		       d0 ea		      bne	plotcharactersloop27
   2874  8847				   .L0177		;;  if enemy1Visible  =  0  &&  enemy1XInt  +	8  >=  0  &&  enemy1XInt  <=  168 then x  =  enemy1XInt  -  8  :  plotsprite enemySprite 4 x enemy1Y 0 1
   2875  8847
   2876  8847		       a5 f6		      LDA	enemy1Visible
   2877  8849		       c9 00		      CMP	#0
   2878  884b		       d0 31		      BNE	.skipL0177
   2879  884d				   .condpart42
   2880  884d							; complex condition detected
   2881  884d		       a5 f7		      LDA	enemy1XInt
   2882  884f		       18		      CLC
   2883  8850		       69 08		      ADC	#8
   2884  8852							; todo: this LDA is spurious and should be prevented ->	LDA  $101,x
   2885  8852		       c9 00		      CMP	#0
   2886  8854		       90 28		      BCC	.skip42then
   2887  8856				   .condpart43
   2888  8856		       a9 a8		      LDA	#168
   2889  8858		       c5 f7		      CMP	enemy1XInt
   2890  885a		       90 22		      BCC	.skip43then
   2891  885c				   .condpart44
   2892  885c		       a5 f7		      LDA	enemy1XInt
   2893  885e		       38		      SEC
   2894  885f		       e9 08		      SBC	#8
   2895  8861		       85 fd		      STA	x
   2896  8863		       a9 02		      lda	#<enemySprite
   2897  8865		       85 42		      sta	temp1
   2898  8867
   2899  8867		       a9 e0		      lda	#>enemySprite
   2900  8869		       85 43		      sta	temp2
   2901  886b
   2902  886b		       a9 9e		      lda	#(128|enemySprite_width_twoscompliment)
   2903  886d		       85 44		      sta	temp3
   2904  886f
   2905  886f		       a5 fd		      lda	x
   2906  8871		       85 45		      sta	temp4
   2907  8873
   2908  8873		       a5 f8		      lda	enemy1Y
   2909  8875		       85 46		      sta	temp5
   2910  8877
   2911  8877		       a9 40		      lda	#(enemySprite_mode|%01000000)
   2912  8879		       85 47		      sta	temp6
   2913  887b
   2914  887b		       20 dc f2 	      jsr	plotsprite
   2915  887e				   .skip43then
   2916  887e				   .skip42then
   2917  887e				   .skipL0177
   2918  887e				   .L0178		;;  plotsprite playerSprite 3 playerXInt playerYInt 0 1
   2919  887e
   2920  887e		       a9 00		      lda	#<playerSprite
   2921  8880		       85 42		      sta	temp1
   2922  8882
   2923  8882		       a9 e0		      lda	#>playerSprite
   2924  8884		       85 43		      sta	temp2
   2925  8886
   2926  8886		       a9 7e		      lda	#(96|playerSprite_width_twoscompliment)
   2927  8888		       85 44		      sta	temp3
   2928  888a
   2929  888a		       a5 e6		      lda	playerXInt
   2930  888c		       85 45		      sta	temp4
   2931  888e
   2932  888e		       a5 e8		      lda	playerYInt
   2933  8890		       85 46		      sta	temp5
   2934  8892
   2935  8892		       a9 40		      lda	#(playerSprite_mode|%01000000)
   2936  8894		       85 47		      sta	temp6
   2937  8896
   2938  8896		       20 dc f2 	      jsr	plotsprite
   2939  8899				   .
   2940  8899							;; 
   2941  8899
   2942  8899				   .L0179		;;  doublebuffer flip
   2943  8899
   2944  8899		       20 45 f5 	      jsr	flipdisplaybuffer
   2945  889c				   .
   2946  889c							;; 
   2947  889c
   2948  889c				   .L0180		;;  scrollCounter  =  scrollCounter  -  1
   2949  889c
   2950  889c		       a5 f4		      LDA	scrollCounter
   2951  889e		       38		      SEC
   2952  889f		       e9 01		      SBC	#1
   2953  88a1		       85 f4		      STA	scrollCounter
   2954  88a3				   .L0181		;;  if scrollCounter  >  0 then goto scrollRight
   2955  88a3
   2956  88a3		       a9 00		      LDA	#0
   2957  88a5		       c5 f4		      CMP	scrollCounter
   2958  88a7		       b0 03		      BCS	.skipL0181
   2959  88a9				   .condpart45
   2960  88a9		       4c 95 87 	      jmp	.scrollRight
   2961  88ac
   2962  88ac				   .skipL0181
   2963  88ac				   .
   2964  88ac							;; 
   2965  88ac
   2966  88ac				   .
   2967  88ac							;; 
   2968  88ac
   2969  88ac				   .L0182		;;  temp1  =  fineScrollX  -  8
   2970  88ac
   2971  88ac		       a5 f1		      LDA	fineScrollX
   2972  88ae		       38		      SEC
   2973  88af		       e9 08		      SBC	#8
   2974  88b1		       85 42		      STA	temp1
   2975  88b3				   .L0183		;;  clearscreen
   2976  88b3
   2977  88b3		       20 87 f0 	      jsr	clearscreen
   2978  88b6				   .L0184		;;  plotmap tileMap 0 temp1 2 21 12 coarseScrollX 0 mapSize
   2979  88b6
   2980  88b6		       a9 0b		      lda	#11	; width in two's complement
   2981  88b8		       85 44		      sta	temp3
   2982  88ba		       09 00		      ora	#0	; palette left shifted 5 bits
   2983  88bc		       85 44		      sta	temp3
   2984  88be		       a5 42		      lda	temp1
   2985  88c0		       85 45		      sta	temp4
   2986  88c2
   2987  88c2		       a9 02		      lda	#2
   2988  88c4		       85 46		      sta	temp5
   2989  88c6
   2990  88c6		       a9 0c		      lda	#12
   2991  88c8		       85 47		      sta	temp6
   2992  88ca		       a9 00		      lda	#<tileMap
   2993  88cc		       85 42		      sta	temp1
   2994  88ce
   2995  88ce		       a9 40		      lda	#>tileMap
   2996  88d0		       85 43		      sta	temp2
   2997  88d2
   2998  88d2		       a0 00		      ldy	#0
   2999  88d4		       c0 00		      cpy	#0
   3000  88d6		       f0 14		      beq	skipmapyadjust28
   3001  88d8		       a5 f2		      lda	mapSize
   3002  88da
   3003  88da		       20 20 f4 	      jsr	mul16
   3004  88dd							;result is in A, temp1 contains overflow
   3005  88dd		       85 43		      sta	temp2
   3006  88df		       18		      clc
   3007  88e0		       a9 00		      lda	#<tileMap
   3008  88e2		       65 42		      adc	temp1
   3009  88e4		       85 42		      sta	temp1
   3010  88e6		       a9 40		      lda	#>tileMap
   3011  88e8		       65 43		      adc	temp2
   3012  88ea		       85 43		      sta	temp2
   3013  88ec				   skipmapyadjust28
   3014  88ec		       18		      clc
   3015  88ed		       a5 f0		      lda	coarseScrollX
   3016  88ef		       65 42		      adc	temp1
   3017  88f1		       85 42		      sta	temp1
   3018  88f3		       a9 00		      lda	#0
   3019  88f5		       65 43		      adc	temp2
   3020  88f7		       85 43		      sta	temp2
   3021  88f9				   plotcharactersloop29
   3022  88f9		       20 9f f3 	      jsr	plotcharacters
   3023  88fc		       18		      clc
   3024  88fd		       a5 f2		      lda	mapSize
   3025  88ff
   3026  88ff		       65 42		      adc	temp1
   3027  8901		       85 42		      sta	temp1
   3028  8903		       a9 00		      lda	#0
   3029  8905		       65 43		      adc	temp2
   3030  8907		       85 43		      sta	temp2
   3031  8909		       e6 46		      inc	temp5
   3032  890b		       c6 47		      dec	temp6
   3033  890d		       d0 ea		      bne	plotcharactersloop29
   3034  890f				   .
   3035  890f							;; 
   3036  890f
   3037  890f				   .L0185		;;  savescreen
   3038  890f
   3039  890f		       20 ab f0 	      jsr	savescreen
   3040  8912				   .L0186		;;  if enemy1Visible  =  0  &&  enemy1XInt  +	8  >=  0  &&  enemy1XInt  <=  168 then x  =  enemy1XInt  -  8  :  plotsprite enemySprite 4 x enemy1Y 0 1
   3041  8912
   3042  8912		       a5 f6		      LDA	enemy1Visible
   3043  8914		       c9 00		      CMP	#0
   3044  8916		       d0 31		      BNE	.skipL0186
   3045  8918				   .condpart46
   3046  8918							; complex condition detected
   3047  8918		       a5 f7		      LDA	enemy1XInt
   3048  891a		       18		      CLC
   3049  891b		       69 08		      ADC	#8
   3050  891d							; todo: this LDA is spurious and should be prevented ->	LDA  $101,x
   3051  891d		       c9 00		      CMP	#0
   3052  891f		       90 28		      BCC	.skip46then
   3053  8921				   .condpart47
   3054  8921		       a9 a8		      LDA	#168
   3055  8923		       c5 f7		      CMP	enemy1XInt
   3056  8925		       90 22		      BCC	.skip47then
   3057  8927				   .condpart48
   3058  8927		       a5 f7		      LDA	enemy1XInt
   3059  8929		       38		      SEC
   3060  892a		       e9 08		      SBC	#8
   3061  892c		       85 fd		      STA	x
   3062  892e		       a9 02		      lda	#<enemySprite
   3063  8930		       85 42		      sta	temp1
   3064  8932
   3065  8932		       a9 e0		      lda	#>enemySprite
   3066  8934		       85 43		      sta	temp2
   3067  8936
   3068  8936		       a9 9e		      lda	#(128|enemySprite_width_twoscompliment)
   3069  8938		       85 44		      sta	temp3
   3070  893a
   3071  893a		       a5 fd		      lda	x
   3072  893c		       85 45		      sta	temp4
   3073  893e
   3074  893e		       a5 f8		      lda	enemy1Y
   3075  8940		       85 46		      sta	temp5
   3076  8942
   3077  8942		       a9 40		      lda	#(enemySprite_mode|%01000000)
   3078  8944		       85 47		      sta	temp6
   3079  8946
   3080  8946		       20 dc f2 	      jsr	plotsprite
   3081  8949				   .skip47then
   3082  8949				   .skip46then
   3083  8949				   .skipL0186
   3084  8949				   .L0187		;;  plotsprite playerSprite 3 playerXInt playerYInt 0 1
   3085  8949
   3086  8949		       a9 00		      lda	#<playerSprite
   3087  894b		       85 42		      sta	temp1
   3088  894d
   3089  894d		       a9 e0		      lda	#>playerSprite
   3090  894f		       85 43		      sta	temp2
   3091  8951
   3092  8951		       a9 7e		      lda	#(96|playerSprite_width_twoscompliment)
   3093  8953		       85 44		      sta	temp3
   3094  8955
   3095  8955		       a5 e6		      lda	playerXInt
   3096  8957		       85 45		      sta	temp4
   3097  8959
   3098  8959		       a5 e8		      lda	playerYInt
   3099  895b		       85 46		      sta	temp5
   3100  895d
   3101  895d		       a9 40		      lda	#(playerSprite_mode|%01000000)
   3102  895f		       85 47		      sta	temp6
   3103  8961
   3104  8961		       20 dc f2 	      jsr	plotsprite
   3105  8964				   .
   3106  8964							;; 
   3107  8964
   3108  8964				   .L0188		;;  return
   3109  8964
   3110  8964		       ba		      tsx
   3111  8965		       bd 02 01 	      lda	$102,x
   3112  8968		       f0 01		      beq	bankswitchret31
   3113  896a		       60		      RTS
   3114  896b				   bankswitchret31
   3115  896b		       4c 5a f4 	      JMP	BS_return
   3116  896e				   .
   3117  896e							;; 
   3118  896e
   3119  896e				   .L0189		;;  bank 2
   3120  896e
   3121  896e				   DMAHOLEEND0 SET	.
   13969 bytes of ROM space left in the main area of bank 1.
   3122  896e					      echo	" ",[($BFFF - .)]d , "bytes of ROM space left in the main area of bank 1."
   3123  896e				  -	      if	($BFFF - .) < 0
   3124  896e				  -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
   3125  896e					      endif
   3126  c000					      ORG	$C000,0
   3127  c000					      RORG	$8000
   3128  c000				   .L0190		;;  bank 3
   3129  c000
   3130  c000				   DMAHOLEEND0 SET	.
   16383 bytes of ROM space left in the main area of bank 2.
   3131  c000					      echo	" ",[($BFFF - .)]d , "bytes of ROM space left in the main area of bank 2."
   3132  c000				  -	      if	($BFFF - .) < 0
   3133  c000				  -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
   3134  c000					      endif
   3135  10000					       ORG	$10000,0
   3136  10000					       RORG	$8000
   3137  10000				    .L0191		;;  bank 4
   3138  10000
   3139  10000				    DMAHOLEEND0 SET	.
   16383 bytes of ROM space left in the main area of bank 3.
   3140  10000					       echo	" ",[($BFFF - .)]d , "bytes of ROM space left in the main area of bank 3."
   3141  10000				   -	       if	($BFFF - .) < 0
   3142  10000				   -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
   3143  10000					       endif
   3144  14000					       ORG	$14000,0
   3145  14000					       RORG	$8000
   3146  14000				    .L0192		;;  bank 5
   3147  14000
   3148  14000				    DMAHOLEEND0 SET	.
   16383 bytes of ROM space left in the main area of bank 4.
   3149  14000					       echo	" ",[($BFFF - .)]d , "bytes of ROM space left in the main area of bank 4."
   3150  14000				   -	       if	($BFFF - .) < 0
   3151  14000				   -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
   3152  14000					       endif
   3153  18000					       ORG	$18000,0
   3154  18000					       RORG	$8000
   3155  18000				    .L0193		;;  bank 6
   3156  18000
   3157  18000				    DMAHOLEEND0 SET	.
   16383 bytes of ROM space left in the main area of bank 5.
   3158  18000					       echo	" ",[($BFFF - .)]d , "bytes of ROM space left in the main area of bank 5."
   3159  18000				   -	       if	($BFFF - .) < 0
   3160  18000				   -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
   3161  18000					       endif
   3162  1c000					       ORG	$1C000,0
   3163  1c000					       RORG	$8000
   3164  1c000				    .L0194		;;  bank 7
   3165  1c000
   3166  1c000				    DMAHOLEEND0 SET	.
   16383 bytes of ROM space left in the main area of bank 6.
   3167  1c000					       echo	" ",[($BFFF - .)]d , "bytes of ROM space left in the main area of bank 6."
   3168  1c000				   -	       if	($BFFF - .) < 0
   3169  1c000				   -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
   3170  1c000					       endif
   3171  20000					       ORG	$20000,0
   3172  20000					       RORG	$8000
   3173  20000				    .L0195		;;  bank 8
   3174  20000
   3175  20000				    DMAHOLEEND0 SET	.
   16383 bytes of ROM space left in the main area of bank 7.
   3176  20000					       echo	" ",[($BFFF - .)]d , "bytes of ROM space left in the main area of bank 7."
   3177  20000				   -	       if	($BFFF - .) < 0
   3178  20000				   -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
   3179  20000					       endif
   3180  24000					       ORG	$24000,0
   3181  24000					       RORG	$C000
   3182  24000				    .
   3183  24000							;; 
   3184  24000
   3185  24000				    .L0196		;;  incgraphic playerSprite.png 160A 0 2 3 1
   3186  24000
   3187  24000				    .L0197		;;  incgraphic enemySprite.png 160A 0 2 3 4
   3188  24000
   3189  24000				    .
   3190  24000							;; 
   3191  24000
   3192  24000				    .
   3193  24000							;; 
   3194  24000
   3195  24000				    .L0198		;;  incgraphic tiles0.png 160A 0 1 2 3 0
   3196  24000
   3197  24000				    .
   3198  24000							;; 
   3199  24000
   3200  24000				    .
   3201  24000							;; 
   3202  24000
   3203  24000				    .L0199		;;  incgraphic tiles2.png 160A 0 1 2 3 0
   3204  24000
   3205  24000				    .
   3206  24000							;; 
   3207  24000
   3208  24000				    .
   3209  24000							;; 
   3210  24000
   3211  24000				    .L0200		;;  incmapfile level1bigger.tmx
   3212  24000			4c f7 cb	       JMP	skipmapdata31
   3213  24003				    level1bigger
   3214  24003			04		       .byte.b	<(tiles0+0)
   3215  24004			06		       .byte.b	<(tiles2+0)
   3216  24005			06		       .byte.b	<(tiles2+0)
   3217  24006			06		       .byte.b	<(tiles2+0)
   3218  24007			06		       .byte.b	<(tiles2+0)
   3219  24008			06		       .byte.b	<(tiles2+0)
   3220  24009			06		       .byte.b	<(tiles2+0)
   3221  2400a			06		       .byte.b	<(tiles2+0)
   3222  2400b			06		       .byte.b	<(tiles2+0)
   3223  2400c			06		       .byte.b	<(tiles2+0)
   3224  2400d			06		       .byte.b	<(tiles2+0)
   3225  2400e			06		       .byte.b	<(tiles2+0)
   3226  2400f			06		       .byte.b	<(tiles2+0)
   3227  24010			06		       .byte.b	<(tiles2+0)
   3228  24011			06		       .byte.b	<(tiles2+0)
   3229  24012			06		       .byte.b	<(tiles2+0)
   3230  24013			06		       .byte.b	<(tiles2+0)
   3231  24014			06		       .byte.b	<(tiles2+0)
   3232  24015			06		       .byte.b	<(tiles2+0)
   3233  24016			06		       .byte.b	<(tiles2+0)
   3234  24017			06		       .byte.b	<(tiles2+0)
   3235  24018			06		       .byte.b	<(tiles2+0)
   3236  24019			06		       .byte.b	<(tiles2+0)
   3237  2401a			06		       .byte.b	<(tiles2+0)
   3238  2401b			06		       .byte.b	<(tiles2+0)
   3239  2401c			06		       .byte.b	<(tiles2+0)
   3240  2401d			06		       .byte.b	<(tiles2+0)
   3241  2401e			06		       .byte.b	<(tiles2+0)
   3242  2401f			06		       .byte.b	<(tiles2+0)
   3243  24020			06		       .byte.b	<(tiles2+0)
   3244  24021			06		       .byte.b	<(tiles2+0)
   3245  24022			06		       .byte.b	<(tiles2+0)
   3246  24023			06		       .byte.b	<(tiles2+0)
   3247  24024			06		       .byte.b	<(tiles2+0)
   3248  24025			06		       .byte.b	<(tiles2+0)
   3249  24026			06		       .byte.b	<(tiles2+0)
   3250  24027			06		       .byte.b	<(tiles2+0)
   3251  24028			06		       .byte.b	<(tiles2+0)
   3252  24029			06		       .byte.b	<(tiles2+0)
   3253  2402a			06		       .byte.b	<(tiles2+0)
   3254  2402b			06		       .byte.b	<(tiles2+0)
   3255  2402c			06		       .byte.b	<(tiles2+0)
   3256  2402d			06		       .byte.b	<(tiles2+0)
   3257  2402e			06		       .byte.b	<(tiles2+0)
   3258  2402f			06		       .byte.b	<(tiles2+0)
   3259  24030			06		       .byte.b	<(tiles2+0)
   3260  24031			06		       .byte.b	<(tiles2+0)
   3261  24032			06		       .byte.b	<(tiles2+0)
   3262  24033			06		       .byte.b	<(tiles2+0)
   3263  24034			06		       .byte.b	<(tiles2+0)
   3264  24035			06		       .byte.b	<(tiles2+0)
   3265  24036			06		       .byte.b	<(tiles2+0)
   3266  24037			06		       .byte.b	<(tiles2+0)
   3267  24038			06		       .byte.b	<(tiles2+0)
   3268  24039			06		       .byte.b	<(tiles2+0)
   3269  2403a			06		       .byte.b	<(tiles2+0)
   3270  2403b			06		       .byte.b	<(tiles2+0)
   3271  2403c			06		       .byte.b	<(tiles2+0)
   3272  2403d			06		       .byte.b	<(tiles2+0)
   3273  2403e			06		       .byte.b	<(tiles2+0)
   3274  2403f			06		       .byte.b	<(tiles2+0)
   3275  24040			06		       .byte.b	<(tiles2+0)
   3276  24041			06		       .byte.b	<(tiles2+0)
   3277  24042			06		       .byte.b	<(tiles2+0)
   3278  24043			06		       .byte.b	<(tiles2+0)
   3279  24044			06		       .byte.b	<(tiles2+0)
   3280  24045			06		       .byte.b	<(tiles2+0)
   3281  24046			06		       .byte.b	<(tiles2+0)
   3282  24047			06		       .byte.b	<(tiles2+0)
   3283  24048			06		       .byte.b	<(tiles2+0)
   3284  24049			06		       .byte.b	<(tiles2+0)
   3285  2404a			06		       .byte.b	<(tiles2+0)
   3286  2404b			06		       .byte.b	<(tiles2+0)
   3287  2404c			06		       .byte.b	<(tiles2+0)
   3288  2404d			06		       .byte.b	<(tiles2+0)
   3289  2404e			06		       .byte.b	<(tiles2+0)
   3290  2404f			06		       .byte.b	<(tiles2+0)
   3291  24050			06		       .byte.b	<(tiles2+0)
   3292  24051			06		       .byte.b	<(tiles2+0)
   3293  24052			06		       .byte.b	<(tiles2+0)
   3294  24053			06		       .byte.b	<(tiles2+0)
   3295  24054			06		       .byte.b	<(tiles2+0)
   3296  24055			06		       .byte.b	<(tiles2+0)
   3297  24056			06		       .byte.b	<(tiles2+0)
   3298  24057			06		       .byte.b	<(tiles2+0)
   3299  24058			06		       .byte.b	<(tiles2+0)
   3300  24059			06		       .byte.b	<(tiles2+0)
   3301  2405a			06		       .byte.b	<(tiles2+0)
   3302  2405b			06		       .byte.b	<(tiles2+0)
   3303  2405c			06		       .byte.b	<(tiles2+0)
   3304  2405d			06		       .byte.b	<(tiles2+0)
   3305  2405e			06		       .byte.b	<(tiles2+0)
   3306  2405f			06		       .byte.b	<(tiles2+0)
   3307  24060			06		       .byte.b	<(tiles2+0)
   3308  24061			06		       .byte.b	<(tiles2+0)
   3309  24062			06		       .byte.b	<(tiles2+0)
   3310  24063			06		       .byte.b	<(tiles2+0)
   3311  24064			06		       .byte.b	<(tiles2+0)
   3312  24065			06		       .byte.b	<(tiles2+0)
   3313  24066			06		       .byte.b	<(tiles2+0)
   3314  24067			06		       .byte.b	<(tiles2+0)
   3315  24068			06		       .byte.b	<(tiles2+0)
   3316  24069			06		       .byte.b	<(tiles2+0)
   3317  2406a			06		       .byte.b	<(tiles2+0)
   3318  2406b			06		       .byte.b	<(tiles2+0)
   3319  2406c			06		       .byte.b	<(tiles2+0)
   3320  2406d			06		       .byte.b	<(tiles2+0)
   3321  2406e			06		       .byte.b	<(tiles2+0)
   3322  2406f			06		       .byte.b	<(tiles2+0)
   3323  24070			06		       .byte.b	<(tiles2+0)
   3324  24071			06		       .byte.b	<(tiles2+0)
   3325  24072			06		       .byte.b	<(tiles2+0)
   3326  24073			06		       .byte.b	<(tiles2+0)
   3327  24074			06		       .byte.b	<(tiles2+0)
   3328  24075			06		       .byte.b	<(tiles2+0)
   3329  24076			06		       .byte.b	<(tiles2+0)
   3330  24077			06		       .byte.b	<(tiles2+0)
   3331  24078			06		       .byte.b	<(tiles2+0)
   3332  24079			06		       .byte.b	<(tiles2+0)
   3333  2407a			06		       .byte.b	<(tiles2+0)
   3334  2407b			06		       .byte.b	<(tiles2+0)
   3335  2407c			06		       .byte.b	<(tiles2+0)
   3336  2407d			06		       .byte.b	<(tiles2+0)
   3337  2407e			06		       .byte.b	<(tiles2+0)
   3338  2407f			06		       .byte.b	<(tiles2+0)
   3339  24080			06		       .byte.b	<(tiles2+0)
   3340  24081			06		       .byte.b	<(tiles2+0)
   3341  24082			06		       .byte.b	<(tiles2+0)
   3342  24083			06		       .byte.b	<(tiles2+0)
   3343  24084			06		       .byte.b	<(tiles2+0)
   3344  24085			06		       .byte.b	<(tiles2+0)
   3345  24086			06		       .byte.b	<(tiles2+0)
   3346  24087			06		       .byte.b	<(tiles2+0)
   3347  24088			06		       .byte.b	<(tiles2+0)
   3348  24089			06		       .byte.b	<(tiles2+0)
   3349  2408a			06		       .byte.b	<(tiles2+0)
   3350  2408b			06		       .byte.b	<(tiles2+0)
   3351  2408c			06		       .byte.b	<(tiles2+0)
   3352  2408d			06		       .byte.b	<(tiles2+0)
   3353  2408e			06		       .byte.b	<(tiles2+0)
   3354  2408f			06		       .byte.b	<(tiles2+0)
   3355  24090			06		       .byte.b	<(tiles2+0)
   3356  24091			06		       .byte.b	<(tiles2+0)
   3357  24092			06		       .byte.b	<(tiles2+0)
   3358  24093			06		       .byte.b	<(tiles2+0)
   3359  24094			06		       .byte.b	<(tiles2+0)
   3360  24095			06		       .byte.b	<(tiles2+0)
   3361  24096			06		       .byte.b	<(tiles2+0)
   3362  24097			06		       .byte.b	<(tiles2+0)
   3363  24098			06		       .byte.b	<(tiles2+0)
   3364  24099			06		       .byte.b	<(tiles2+0)
   3365  2409a			06		       .byte.b	<(tiles2+0)
   3366  2409b			06		       .byte.b	<(tiles2+0)
   3367  2409c			06		       .byte.b	<(tiles2+0)
   3368  2409d			06		       .byte.b	<(tiles2+0)
   3369  2409e			06		       .byte.b	<(tiles2+0)
   3370  2409f			06		       .byte.b	<(tiles2+0)
   3371  240a0			06		       .byte.b	<(tiles2+0)
   3372  240a1			06		       .byte.b	<(tiles2+0)
   3373  240a2			06		       .byte.b	<(tiles2+0)
   3374  240a3			06		       .byte.b	<(tiles2+0)
   3375  240a4			06		       .byte.b	<(tiles2+0)
   3376  240a5			06		       .byte.b	<(tiles2+0)
   3377  240a6			06		       .byte.b	<(tiles2+0)
   3378  240a7			06		       .byte.b	<(tiles2+0)
   3379  240a8			06		       .byte.b	<(tiles2+0)
   3380  240a9			06		       .byte.b	<(tiles2+0)
   3381  240aa			06		       .byte.b	<(tiles2+0)
   3382  240ab			06		       .byte.b	<(tiles2+0)
   3383  240ac			06		       .byte.b	<(tiles2+0)
   3384  240ad			06		       .byte.b	<(tiles2+0)
   3385  240ae			06		       .byte.b	<(tiles2+0)
   3386  240af			06		       .byte.b	<(tiles2+0)
   3387  240b0			06		       .byte.b	<(tiles2+0)
   3388  240b1			06		       .byte.b	<(tiles2+0)
   3389  240b2			06		       .byte.b	<(tiles2+0)
   3390  240b3			06		       .byte.b	<(tiles2+0)
   3391  240b4			06		       .byte.b	<(tiles2+0)
   3392  240b5			06		       .byte.b	<(tiles2+0)
   3393  240b6			06		       .byte.b	<(tiles2+0)
   3394  240b7			06		       .byte.b	<(tiles2+0)
   3395  240b8			06		       .byte.b	<(tiles2+0)
   3396  240b9			06		       .byte.b	<(tiles2+0)
   3397  240ba			06		       .byte.b	<(tiles2+0)
   3398  240bb			06		       .byte.b	<(tiles2+0)
   3399  240bc			06		       .byte.b	<(tiles2+0)
   3400  240bd			06		       .byte.b	<(tiles2+0)
   3401  240be			06		       .byte.b	<(tiles2+0)
   3402  240bf			06		       .byte.b	<(tiles2+0)
   3403  240c0			06		       .byte.b	<(tiles2+0)
   3404  240c1			06		       .byte.b	<(tiles2+0)
   3405  240c2			06		       .byte.b	<(tiles2+0)
   3406  240c3			06		       .byte.b	<(tiles2+0)
   3407  240c4			06		       .byte.b	<(tiles2+0)
   3408  240c5			06		       .byte.b	<(tiles2+0)
   3409  240c6			06		       .byte.b	<(tiles2+0)
   3410  240c7			06		       .byte.b	<(tiles2+0)
   3411  240c8			06		       .byte.b	<(tiles2+0)
   3412  240c9			06		       .byte.b	<(tiles2+0)
   3413  240ca			06		       .byte.b	<(tiles2+0)
   3414  240cb			06		       .byte.b	<(tiles2+0)
   3415  240cc			06		       .byte.b	<(tiles2+0)
   3416  240cd			06		       .byte.b	<(tiles2+0)
   3417  240ce			06		       .byte.b	<(tiles2+0)
   3418  240cf			06		       .byte.b	<(tiles2+0)
   3419  240d0			06		       .byte.b	<(tiles2+0)
   3420  240d1			06		       .byte.b	<(tiles2+0)
   3421  240d2			06		       .byte.b	<(tiles2+0)
   3422  240d3			06		       .byte.b	<(tiles2+0)
   3423  240d4			06		       .byte.b	<(tiles2+0)
   3424  240d5			06		       .byte.b	<(tiles2+0)
   3425  240d6			06		       .byte.b	<(tiles2+0)
   3426  240d7			06		       .byte.b	<(tiles2+0)
   3427  240d8			06		       .byte.b	<(tiles2+0)
   3428  240d9			06		       .byte.b	<(tiles2+0)
   3429  240da			06		       .byte.b	<(tiles2+0)
   3430  240db			06		       .byte.b	<(tiles2+0)
   3431  240dc			06		       .byte.b	<(tiles2+0)
   3432  240dd			06		       .byte.b	<(tiles2+0)
   3433  240de			06		       .byte.b	<(tiles2+0)
   3434  240df			06		       .byte.b	<(tiles2+0)
   3435  240e0			06		       .byte.b	<(tiles2+0)
   3436  240e1			06		       .byte.b	<(tiles2+0)
   3437  240e2			06		       .byte.b	<(tiles2+0)
   3438  240e3			06		       .byte.b	<(tiles2+0)
   3439  240e4			06		       .byte.b	<(tiles2+0)
   3440  240e5			06		       .byte.b	<(tiles2+0)
   3441  240e6			06		       .byte.b	<(tiles2+0)
   3442  240e7			06		       .byte.b	<(tiles2+0)
   3443  240e8			06		       .byte.b	<(tiles2+0)
   3444  240e9			06		       .byte.b	<(tiles2+0)
   3445  240ea			06		       .byte.b	<(tiles2+0)
   3446  240eb			06		       .byte.b	<(tiles2+0)
   3447  240ec			06		       .byte.b	<(tiles2+0)
   3448  240ed			06		       .byte.b	<(tiles2+0)
   3449  240ee			06		       .byte.b	<(tiles2+0)
   3450  240ef			06		       .byte.b	<(tiles2+0)
   3451  240f0			06		       .byte.b	<(tiles2+0)
   3452  240f1			06		       .byte.b	<(tiles2+0)
   3453  240f2			06		       .byte.b	<(tiles2+0)
   3454  240f3			06		       .byte.b	<(tiles2+0)
   3455  240f4			06		       .byte.b	<(tiles2+0)
   3456  240f5			06		       .byte.b	<(tiles2+0)
   3457  240f6			06		       .byte.b	<(tiles2+0)
   3458  240f7			06		       .byte.b	<(tiles2+0)
   3459  240f8			06		       .byte.b	<(tiles2+0)
   3460  240f9			06		       .byte.b	<(tiles2+0)
   3461  240fa			06		       .byte.b	<(tiles2+0)
   3462  240fb			06		       .byte.b	<(tiles2+0)
   3463  240fc			04		       .byte.b	<(tiles0+0)
   3464  240fd			04		       .byte.b	<(tiles0+0)
   3465  240fe			04		       .byte.b	<(tiles0+0)
   3466  240ff			04		       .byte.b	<(tiles0+0)
   3467  24100			04		       .byte.b	<(tiles0+0)
   3468  24101			04		       .byte.b	<(tiles0+0)
   3469  24102			04		       .byte.b	<(tiles0+0)
   3470  24103			06		       .byte.b	<(tiles2+0)
   3471  24104			04		       .byte.b	<(tiles0+0)
   3472  24105			04		       .byte.b	<(tiles0+0)
   3473  24106			04		       .byte.b	<(tiles0+0)
   3474  24107			04		       .byte.b	<(tiles0+0)
   3475  24108			04		       .byte.b	<(tiles0+0)
   3476  24109			04		       .byte.b	<(tiles0+0)
   3477  2410a			04		       .byte.b	<(tiles0+0)
   3478  2410b			04		       .byte.b	<(tiles0+0)
   3479  2410c			04		       .byte.b	<(tiles0+0)
   3480  2410d			04		       .byte.b	<(tiles0+0)
   3481  2410e			04		       .byte.b	<(tiles0+0)
   3482  2410f			04		       .byte.b	<(tiles0+0)
   3483  24110			04		       .byte.b	<(tiles0+0)
   3484  24111			04		       .byte.b	<(tiles0+0)
   3485  24112			04		       .byte.b	<(tiles0+0)
   3486  24113			04		       .byte.b	<(tiles0+0)
   3487  24114			04		       .byte.b	<(tiles0+0)
   3488  24115			04		       .byte.b	<(tiles0+0)
   3489  24116			04		       .byte.b	<(tiles0+0)
   3490  24117			04		       .byte.b	<(tiles0+0)
   3491  24118			04		       .byte.b	<(tiles0+0)
   3492  24119			04		       .byte.b	<(tiles0+0)
   3493  2411a			04		       .byte.b	<(tiles0+0)
   3494  2411b			04		       .byte.b	<(tiles0+0)
   3495  2411c			04		       .byte.b	<(tiles0+0)
   3496  2411d			04		       .byte.b	<(tiles0+0)
   3497  2411e			04		       .byte.b	<(tiles0+0)
   3498  2411f			04		       .byte.b	<(tiles0+0)
   3499  24120			04		       .byte.b	<(tiles0+0)
   3500  24121			04		       .byte.b	<(tiles0+0)
   3501  24122			04		       .byte.b	<(tiles0+0)
   3502  24123			04		       .byte.b	<(tiles0+0)
   3503  24124			04		       .byte.b	<(tiles0+0)
   3504  24125			04		       .byte.b	<(tiles0+0)
   3505  24126			04		       .byte.b	<(tiles0+0)
   3506  24127			04		       .byte.b	<(tiles0+0)
   3507  24128			04		       .byte.b	<(tiles0+0)
   3508  24129			04		       .byte.b	<(tiles0+0)
   3509  2412a			04		       .byte.b	<(tiles0+0)
   3510  2412b			04		       .byte.b	<(tiles0+0)
   3511  2412c			04		       .byte.b	<(tiles0+0)
   3512  2412d			04		       .byte.b	<(tiles0+0)
   3513  2412e			04		       .byte.b	<(tiles0+0)
   3514  2412f			04		       .byte.b	<(tiles0+0)
   3515  24130			04		       .byte.b	<(tiles0+0)
   3516  24131			04		       .byte.b	<(tiles0+0)
   3517  24132			04		       .byte.b	<(tiles0+0)
   3518  24133			04		       .byte.b	<(tiles0+0)
   3519  24134			04		       .byte.b	<(tiles0+0)
   3520  24135			04		       .byte.b	<(tiles0+0)
   3521  24136			04		       .byte.b	<(tiles0+0)
   3522  24137			04		       .byte.b	<(tiles0+0)
   3523  24138			04		       .byte.b	<(tiles0+0)
   3524  24139			04		       .byte.b	<(tiles0+0)
   3525  2413a			04		       .byte.b	<(tiles0+0)
   3526  2413b			04		       .byte.b	<(tiles0+0)
   3527  2413c			04		       .byte.b	<(tiles0+0)
   3528  2413d			04		       .byte.b	<(tiles0+0)
   3529  2413e			04		       .byte.b	<(tiles0+0)
   3530  2413f			04		       .byte.b	<(tiles0+0)
   3531  24140			04		       .byte.b	<(tiles0+0)
   3532  24141			04		       .byte.b	<(tiles0+0)
   3533  24142			04		       .byte.b	<(tiles0+0)
   3534  24143			04		       .byte.b	<(tiles0+0)
   3535  24144			04		       .byte.b	<(tiles0+0)
   3536  24145			04		       .byte.b	<(tiles0+0)
   3537  24146			04		       .byte.b	<(tiles0+0)
   3538  24147			04		       .byte.b	<(tiles0+0)
   3539  24148			04		       .byte.b	<(tiles0+0)
   3540  24149			04		       .byte.b	<(tiles0+0)
   3541  2414a			04		       .byte.b	<(tiles0+0)
   3542  2414b			04		       .byte.b	<(tiles0+0)
   3543  2414c			04		       .byte.b	<(tiles0+0)
   3544  2414d			04		       .byte.b	<(tiles0+0)
   3545  2414e			04		       .byte.b	<(tiles0+0)
   3546  2414f			04		       .byte.b	<(tiles0+0)
   3547  24150			04		       .byte.b	<(tiles0+0)
   3548  24151			04		       .byte.b	<(tiles0+0)
   3549  24152			04		       .byte.b	<(tiles0+0)
   3550  24153			04		       .byte.b	<(tiles0+0)
   3551  24154			04		       .byte.b	<(tiles0+0)
   3552  24155			04		       .byte.b	<(tiles0+0)
   3553  24156			04		       .byte.b	<(tiles0+0)
   3554  24157			04		       .byte.b	<(tiles0+0)
   3555  24158			04		       .byte.b	<(tiles0+0)
   3556  24159			04		       .byte.b	<(tiles0+0)
   3557  2415a			04		       .byte.b	<(tiles0+0)
   3558  2415b			04		       .byte.b	<(tiles0+0)
   3559  2415c			04		       .byte.b	<(tiles0+0)
   3560  2415d			04		       .byte.b	<(tiles0+0)
   3561  2415e			04		       .byte.b	<(tiles0+0)
   3562  2415f			04		       .byte.b	<(tiles0+0)
   3563  24160			04		       .byte.b	<(tiles0+0)
   3564  24161			04		       .byte.b	<(tiles0+0)
   3565  24162			04		       .byte.b	<(tiles0+0)
   3566  24163			04		       .byte.b	<(tiles0+0)
   3567  24164			04		       .byte.b	<(tiles0+0)
   3568  24165			04		       .byte.b	<(tiles0+0)
   3569  24166			04		       .byte.b	<(tiles0+0)
   3570  24167			04		       .byte.b	<(tiles0+0)
   3571  24168			04		       .byte.b	<(tiles0+0)
   3572  24169			04		       .byte.b	<(tiles0+0)
   3573  2416a			04		       .byte.b	<(tiles0+0)
   3574  2416b			04		       .byte.b	<(tiles0+0)
   3575  2416c			04		       .byte.b	<(tiles0+0)
   3576  2416d			04		       .byte.b	<(tiles0+0)
   3577  2416e			04		       .byte.b	<(tiles0+0)
   3578  2416f			04		       .byte.b	<(tiles0+0)
   3579  24170			04		       .byte.b	<(tiles0+0)
   3580  24171			04		       .byte.b	<(tiles0+0)
   3581  24172			04		       .byte.b	<(tiles0+0)
   3582  24173			04		       .byte.b	<(tiles0+0)
   3583  24174			04		       .byte.b	<(tiles0+0)
   3584  24175			04		       .byte.b	<(tiles0+0)
   3585  24176			04		       .byte.b	<(tiles0+0)
   3586  24177			04		       .byte.b	<(tiles0+0)
   3587  24178			04		       .byte.b	<(tiles0+0)
   3588  24179			04		       .byte.b	<(tiles0+0)
   3589  2417a			04		       .byte.b	<(tiles0+0)
   3590  2417b			04		       .byte.b	<(tiles0+0)
   3591  2417c			04		       .byte.b	<(tiles0+0)
   3592  2417d			04		       .byte.b	<(tiles0+0)
   3593  2417e			04		       .byte.b	<(tiles0+0)
   3594  2417f			04		       .byte.b	<(tiles0+0)
   3595  24180			04		       .byte.b	<(tiles0+0)
   3596  24181			04		       .byte.b	<(tiles0+0)
   3597  24182			04		       .byte.b	<(tiles0+0)
   3598  24183			04		       .byte.b	<(tiles0+0)
   3599  24184			04		       .byte.b	<(tiles0+0)
   3600  24185			04		       .byte.b	<(tiles0+0)
   3601  24186			04		       .byte.b	<(tiles0+0)
   3602  24187			04		       .byte.b	<(tiles0+0)
   3603  24188			04		       .byte.b	<(tiles0+0)
   3604  24189			04		       .byte.b	<(tiles0+0)
   3605  2418a			04		       .byte.b	<(tiles0+0)
   3606  2418b			04		       .byte.b	<(tiles0+0)
   3607  2418c			04		       .byte.b	<(tiles0+0)
   3608  2418d			04		       .byte.b	<(tiles0+0)
   3609  2418e			04		       .byte.b	<(tiles0+0)
   3610  2418f			04		       .byte.b	<(tiles0+0)
   3611  24190			04		       .byte.b	<(tiles0+0)
   3612  24191			04		       .byte.b	<(tiles0+0)
   3613  24192			04		       .byte.b	<(tiles0+0)
   3614  24193			04		       .byte.b	<(tiles0+0)
   3615  24194			04		       .byte.b	<(tiles0+0)
   3616  24195			04		       .byte.b	<(tiles0+0)
   3617  24196			04		       .byte.b	<(tiles0+0)
   3618  24197			04		       .byte.b	<(tiles0+0)
   3619  24198			04		       .byte.b	<(tiles0+0)
   3620  24199			04		       .byte.b	<(tiles0+0)
   3621  2419a			04		       .byte.b	<(tiles0+0)
   3622  2419b			04		       .byte.b	<(tiles0+0)
   3623  2419c			04		       .byte.b	<(tiles0+0)
   3624  2419d			04		       .byte.b	<(tiles0+0)
   3625  2419e			04		       .byte.b	<(tiles0+0)
   3626  2419f			04		       .byte.b	<(tiles0+0)
   3627  241a0			04		       .byte.b	<(tiles0+0)
   3628  241a1			04		       .byte.b	<(tiles0+0)
   3629  241a2			04		       .byte.b	<(tiles0+0)
   3630  241a3			04		       .byte.b	<(tiles0+0)
   3631  241a4			04		       .byte.b	<(tiles0+0)
   3632  241a5			04		       .byte.b	<(tiles0+0)
   3633  241a6			04		       .byte.b	<(tiles0+0)
   3634  241a7			04		       .byte.b	<(tiles0+0)
   3635  241a8			04		       .byte.b	<(tiles0+0)
   3636  241a9			04		       .byte.b	<(tiles0+0)
   3637  241aa			04		       .byte.b	<(tiles0+0)
   3638  241ab			04		       .byte.b	<(tiles0+0)
   3639  241ac			04		       .byte.b	<(tiles0+0)
   3640  241ad			04		       .byte.b	<(tiles0+0)
   3641  241ae			04		       .byte.b	<(tiles0+0)
   3642  241af			04		       .byte.b	<(tiles0+0)
   3643  241b0			04		       .byte.b	<(tiles0+0)
   3644  241b1			04		       .byte.b	<(tiles0+0)
   3645  241b2			04		       .byte.b	<(tiles0+0)
   3646  241b3			04		       .byte.b	<(tiles0+0)
   3647  241b4			04		       .byte.b	<(tiles0+0)
   3648  241b5			04		       .byte.b	<(tiles0+0)
   3649  241b6			04		       .byte.b	<(tiles0+0)
   3650  241b7			04		       .byte.b	<(tiles0+0)
   3651  241b8			04		       .byte.b	<(tiles0+0)
   3652  241b9			04		       .byte.b	<(tiles0+0)
   3653  241ba			04		       .byte.b	<(tiles0+0)
   3654  241bb			04		       .byte.b	<(tiles0+0)
   3655  241bc			04		       .byte.b	<(tiles0+0)
   3656  241bd			04		       .byte.b	<(tiles0+0)
   3657  241be			04		       .byte.b	<(tiles0+0)
   3658  241bf			04		       .byte.b	<(tiles0+0)
   3659  241c0			04		       .byte.b	<(tiles0+0)
   3660  241c1			04		       .byte.b	<(tiles0+0)
   3661  241c2			04		       .byte.b	<(tiles0+0)
   3662  241c3			04		       .byte.b	<(tiles0+0)
   3663  241c4			04		       .byte.b	<(tiles0+0)
   3664  241c5			04		       .byte.b	<(tiles0+0)
   3665  241c6			04		       .byte.b	<(tiles0+0)
   3666  241c7			04		       .byte.b	<(tiles0+0)
   3667  241c8			04		       .byte.b	<(tiles0+0)
   3668  241c9			04		       .byte.b	<(tiles0+0)
   3669  241ca			04		       .byte.b	<(tiles0+0)
   3670  241cb			04		       .byte.b	<(tiles0+0)
   3671  241cc			04		       .byte.b	<(tiles0+0)
   3672  241cd			04		       .byte.b	<(tiles0+0)
   3673  241ce			04		       .byte.b	<(tiles0+0)
   3674  241cf			04		       .byte.b	<(tiles0+0)
   3675  241d0			04		       .byte.b	<(tiles0+0)
   3676  241d1			04		       .byte.b	<(tiles0+0)
   3677  241d2			04		       .byte.b	<(tiles0+0)
   3678  241d3			04		       .byte.b	<(tiles0+0)
   3679  241d4			04		       .byte.b	<(tiles0+0)
   3680  241d5			04		       .byte.b	<(tiles0+0)
   3681  241d6			04		       .byte.b	<(tiles0+0)
   3682  241d7			04		       .byte.b	<(tiles0+0)
   3683  241d8			04		       .byte.b	<(tiles0+0)
   3684  241d9			04		       .byte.b	<(tiles0+0)
   3685  241da			04		       .byte.b	<(tiles0+0)
   3686  241db			04		       .byte.b	<(tiles0+0)
   3687  241dc			04		       .byte.b	<(tiles0+0)
   3688  241dd			04		       .byte.b	<(tiles0+0)
   3689  241de			04		       .byte.b	<(tiles0+0)
   3690  241df			04		       .byte.b	<(tiles0+0)
   3691  241e0			04		       .byte.b	<(tiles0+0)
   3692  241e1			04		       .byte.b	<(tiles0+0)
   3693  241e2			04		       .byte.b	<(tiles0+0)
   3694  241e3			04		       .byte.b	<(tiles0+0)
   3695  241e4			04		       .byte.b	<(tiles0+0)
   3696  241e5			04		       .byte.b	<(tiles0+0)
   3697  241e6			04		       .byte.b	<(tiles0+0)
   3698  241e7			04		       .byte.b	<(tiles0+0)
   3699  241e8			04		       .byte.b	<(tiles0+0)
   3700  241e9			04		       .byte.b	<(tiles0+0)
   3701  241ea			04		       .byte.b	<(tiles0+0)
   3702  241eb			04		       .byte.b	<(tiles0+0)
   3703  241ec			04		       .byte.b	<(tiles0+0)
   3704  241ed			04		       .byte.b	<(tiles0+0)
   3705  241ee			04		       .byte.b	<(tiles0+0)
   3706  241ef			04		       .byte.b	<(tiles0+0)
   3707  241f0			04		       .byte.b	<(tiles0+0)
   3708  241f1			04		       .byte.b	<(tiles0+0)
   3709  241f2			04		       .byte.b	<(tiles0+0)
   3710  241f3			04		       .byte.b	<(tiles0+0)
   3711  241f4			04		       .byte.b	<(tiles0+0)
   3712  241f5			04		       .byte.b	<(tiles0+0)
   3713  241f6			04		       .byte.b	<(tiles0+0)
   3714  241f7			04		       .byte.b	<(tiles0+0)
   3715  241f8			04		       .byte.b	<(tiles0+0)
   3716  241f9			04		       .byte.b	<(tiles0+0)
   3717  241fa			06		       .byte.b	<(tiles2+0)
   3718  241fb			04		       .byte.b	<(tiles0+0)
   3719  241fc			04		       .byte.b	<(tiles0+0)
   3720  241fd			04		       .byte.b	<(tiles0+0)
   3721  241fe			04		       .byte.b	<(tiles0+0)
   3722  241ff			04		       .byte.b	<(tiles0+0)
   3723  24200			04		       .byte.b	<(tiles0+0)
   3724  24201			04		       .byte.b	<(tiles0+0)
   3725  24202			06		       .byte.b	<(tiles2+0)
   3726  24203			04		       .byte.b	<(tiles0+0)
   3727  24204			04		       .byte.b	<(tiles0+0)
   3728  24205			04		       .byte.b	<(tiles0+0)
   3729  24206			04		       .byte.b	<(tiles0+0)
   3730  24207			04		       .byte.b	<(tiles0+0)
   3731  24208			04		       .byte.b	<(tiles0+0)
   3732  24209			04		       .byte.b	<(tiles0+0)
   3733  2420a			04		       .byte.b	<(tiles0+0)
   3734  2420b			04		       .byte.b	<(tiles0+0)
   3735  2420c			04		       .byte.b	<(tiles0+0)
   3736  2420d			04		       .byte.b	<(tiles0+0)
   3737  2420e			04		       .byte.b	<(tiles0+0)
   3738  2420f			04		       .byte.b	<(tiles0+0)
   3739  24210			04		       .byte.b	<(tiles0+0)
   3740  24211			04		       .byte.b	<(tiles0+0)
   3741  24212			04		       .byte.b	<(tiles0+0)
   3742  24213			04		       .byte.b	<(tiles0+0)
   3743  24214			04		       .byte.b	<(tiles0+0)
   3744  24215			04		       .byte.b	<(tiles0+0)
   3745  24216			04		       .byte.b	<(tiles0+0)
   3746  24217			04		       .byte.b	<(tiles0+0)
   3747  24218			04		       .byte.b	<(tiles0+0)
   3748  24219			04		       .byte.b	<(tiles0+0)
   3749  2421a			04		       .byte.b	<(tiles0+0)
   3750  2421b			04		       .byte.b	<(tiles0+0)
   3751  2421c			04		       .byte.b	<(tiles0+0)
   3752  2421d			04		       .byte.b	<(tiles0+0)
   3753  2421e			04		       .byte.b	<(tiles0+0)
   3754  2421f			04		       .byte.b	<(tiles0+0)
   3755  24220			04		       .byte.b	<(tiles0+0)
   3756  24221			04		       .byte.b	<(tiles0+0)
   3757  24222			04		       .byte.b	<(tiles0+0)
   3758  24223			04		       .byte.b	<(tiles0+0)
   3759  24224			04		       .byte.b	<(tiles0+0)
   3760  24225			04		       .byte.b	<(tiles0+0)
   3761  24226			04		       .byte.b	<(tiles0+0)
   3762  24227			04		       .byte.b	<(tiles0+0)
   3763  24228			04		       .byte.b	<(tiles0+0)
   3764  24229			04		       .byte.b	<(tiles0+0)
   3765  2422a			04		       .byte.b	<(tiles0+0)
   3766  2422b			04		       .byte.b	<(tiles0+0)
   3767  2422c			04		       .byte.b	<(tiles0+0)
   3768  2422d			04		       .byte.b	<(tiles0+0)
   3769  2422e			04		       .byte.b	<(tiles0+0)
   3770  2422f			04		       .byte.b	<(tiles0+0)
   3771  24230			04		       .byte.b	<(tiles0+0)
   3772  24231			04		       .byte.b	<(tiles0+0)
   3773  24232			04		       .byte.b	<(tiles0+0)
   3774  24233			04		       .byte.b	<(tiles0+0)
   3775  24234			04		       .byte.b	<(tiles0+0)
   3776  24235			04		       .byte.b	<(tiles0+0)
   3777  24236			04		       .byte.b	<(tiles0+0)
   3778  24237			04		       .byte.b	<(tiles0+0)
   3779  24238			04		       .byte.b	<(tiles0+0)
   3780  24239			04		       .byte.b	<(tiles0+0)
   3781  2423a			04		       .byte.b	<(tiles0+0)
   3782  2423b			04		       .byte.b	<(tiles0+0)
   3783  2423c			04		       .byte.b	<(tiles0+0)
   3784  2423d			04		       .byte.b	<(tiles0+0)
   3785  2423e			04		       .byte.b	<(tiles0+0)
   3786  2423f			04		       .byte.b	<(tiles0+0)
   3787  24240			04		       .byte.b	<(tiles0+0)
   3788  24241			04		       .byte.b	<(tiles0+0)
   3789  24242			04		       .byte.b	<(tiles0+0)
   3790  24243			04		       .byte.b	<(tiles0+0)
   3791  24244			04		       .byte.b	<(tiles0+0)
   3792  24245			04		       .byte.b	<(tiles0+0)
   3793  24246			04		       .byte.b	<(tiles0+0)
   3794  24247			04		       .byte.b	<(tiles0+0)
   3795  24248			04		       .byte.b	<(tiles0+0)
   3796  24249			04		       .byte.b	<(tiles0+0)
   3797  2424a			04		       .byte.b	<(tiles0+0)
   3798  2424b			04		       .byte.b	<(tiles0+0)
   3799  2424c			04		       .byte.b	<(tiles0+0)
   3800  2424d			04		       .byte.b	<(tiles0+0)
   3801  2424e			04		       .byte.b	<(tiles0+0)
   3802  2424f			04		       .byte.b	<(tiles0+0)
   3803  24250			04		       .byte.b	<(tiles0+0)
   3804  24251			04		       .byte.b	<(tiles0+0)
   3805  24252			04		       .byte.b	<(tiles0+0)
   3806  24253			04		       .byte.b	<(tiles0+0)
   3807  24254			04		       .byte.b	<(tiles0+0)
   3808  24255			04		       .byte.b	<(tiles0+0)
   3809  24256			04		       .byte.b	<(tiles0+0)
   3810  24257			04		       .byte.b	<(tiles0+0)
   3811  24258			04		       .byte.b	<(tiles0+0)
   3812  24259			04		       .byte.b	<(tiles0+0)
   3813  2425a			04		       .byte.b	<(tiles0+0)
   3814  2425b			04		       .byte.b	<(tiles0+0)
   3815  2425c			04		       .byte.b	<(tiles0+0)
   3816  2425d			04		       .byte.b	<(tiles0+0)
   3817  2425e			04		       .byte.b	<(tiles0+0)
   3818  2425f			04		       .byte.b	<(tiles0+0)
   3819  24260			04		       .byte.b	<(tiles0+0)
   3820  24261			04		       .byte.b	<(tiles0+0)
   3821  24262			04		       .byte.b	<(tiles0+0)
   3822  24263			04		       .byte.b	<(tiles0+0)
   3823  24264			04		       .byte.b	<(tiles0+0)
   3824  24265			04		       .byte.b	<(tiles0+0)
   3825  24266			04		       .byte.b	<(tiles0+0)
   3826  24267			04		       .byte.b	<(tiles0+0)
   3827  24268			04		       .byte.b	<(tiles0+0)
   3828  24269			04		       .byte.b	<(tiles0+0)
   3829  2426a			04		       .byte.b	<(tiles0+0)
   3830  2426b			04		       .byte.b	<(tiles0+0)
   3831  2426c			04		       .byte.b	<(tiles0+0)
   3832  2426d			04		       .byte.b	<(tiles0+0)
   3833  2426e			04		       .byte.b	<(tiles0+0)
   3834  2426f			04		       .byte.b	<(tiles0+0)
   3835  24270			04		       .byte.b	<(tiles0+0)
   3836  24271			04		       .byte.b	<(tiles0+0)
   3837  24272			04		       .byte.b	<(tiles0+0)
   3838  24273			04		       .byte.b	<(tiles0+0)
   3839  24274			04		       .byte.b	<(tiles0+0)
   3840  24275			04		       .byte.b	<(tiles0+0)
   3841  24276			04		       .byte.b	<(tiles0+0)
   3842  24277			04		       .byte.b	<(tiles0+0)
   3843  24278			04		       .byte.b	<(tiles0+0)
   3844  24279			04		       .byte.b	<(tiles0+0)
   3845  2427a			04		       .byte.b	<(tiles0+0)
   3846  2427b			04		       .byte.b	<(tiles0+0)
   3847  2427c			04		       .byte.b	<(tiles0+0)
   3848  2427d			04		       .byte.b	<(tiles0+0)
   3849  2427e			04		       .byte.b	<(tiles0+0)
   3850  2427f			04		       .byte.b	<(tiles0+0)
   3851  24280			04		       .byte.b	<(tiles0+0)
   3852  24281			04		       .byte.b	<(tiles0+0)
   3853  24282			04		       .byte.b	<(tiles0+0)
   3854  24283			04		       .byte.b	<(tiles0+0)
   3855  24284			04		       .byte.b	<(tiles0+0)
   3856  24285			04		       .byte.b	<(tiles0+0)
   3857  24286			04		       .byte.b	<(tiles0+0)
   3858  24287			04		       .byte.b	<(tiles0+0)
   3859  24288			04		       .byte.b	<(tiles0+0)
   3860  24289			04		       .byte.b	<(tiles0+0)
   3861  2428a			04		       .byte.b	<(tiles0+0)
   3862  2428b			04		       .byte.b	<(tiles0+0)
   3863  2428c			04		       .byte.b	<(tiles0+0)
   3864  2428d			04		       .byte.b	<(tiles0+0)
   3865  2428e			04		       .byte.b	<(tiles0+0)
   3866  2428f			04		       .byte.b	<(tiles0+0)
   3867  24290			04		       .byte.b	<(tiles0+0)
   3868  24291			04		       .byte.b	<(tiles0+0)
   3869  24292			04		       .byte.b	<(tiles0+0)
   3870  24293			04		       .byte.b	<(tiles0+0)
   3871  24294			04		       .byte.b	<(tiles0+0)
   3872  24295			04		       .byte.b	<(tiles0+0)
   3873  24296			04		       .byte.b	<(tiles0+0)
   3874  24297			04		       .byte.b	<(tiles0+0)
   3875  24298			04		       .byte.b	<(tiles0+0)
   3876  24299			04		       .byte.b	<(tiles0+0)
   3877  2429a			04		       .byte.b	<(tiles0+0)
   3878  2429b			04		       .byte.b	<(tiles0+0)
   3879  2429c			04		       .byte.b	<(tiles0+0)
   3880  2429d			04		       .byte.b	<(tiles0+0)
   3881  2429e			04		       .byte.b	<(tiles0+0)
   3882  2429f			04		       .byte.b	<(tiles0+0)
   3883  242a0			04		       .byte.b	<(tiles0+0)
   3884  242a1			04		       .byte.b	<(tiles0+0)
   3885  242a2			04		       .byte.b	<(tiles0+0)
   3886  242a3			04		       .byte.b	<(tiles0+0)
   3887  242a4			04		       .byte.b	<(tiles0+0)
   3888  242a5			04		       .byte.b	<(tiles0+0)
   3889  242a6			04		       .byte.b	<(tiles0+0)
   3890  242a7			04		       .byte.b	<(tiles0+0)
   3891  242a8			04		       .byte.b	<(tiles0+0)
   3892  242a9			04		       .byte.b	<(tiles0+0)
   3893  242aa			04		       .byte.b	<(tiles0+0)
   3894  242ab			04		       .byte.b	<(tiles0+0)
   3895  242ac			04		       .byte.b	<(tiles0+0)
   3896  242ad			04		       .byte.b	<(tiles0+0)
   3897  242ae			04		       .byte.b	<(tiles0+0)
   3898  242af			04		       .byte.b	<(tiles0+0)
   3899  242b0			04		       .byte.b	<(tiles0+0)
   3900  242b1			04		       .byte.b	<(tiles0+0)
   3901  242b2			04		       .byte.b	<(tiles0+0)
   3902  242b3			04		       .byte.b	<(tiles0+0)
   3903  242b4			04		       .byte.b	<(tiles0+0)
   3904  242b5			04		       .byte.b	<(tiles0+0)
   3905  242b6			04		       .byte.b	<(tiles0+0)
   3906  242b7			04		       .byte.b	<(tiles0+0)
   3907  242b8			04		       .byte.b	<(tiles0+0)
   3908  242b9			04		       .byte.b	<(tiles0+0)
   3909  242ba			04		       .byte.b	<(tiles0+0)
   3910  242bb			04		       .byte.b	<(tiles0+0)
   3911  242bc			04		       .byte.b	<(tiles0+0)
   3912  242bd			04		       .byte.b	<(tiles0+0)
   3913  242be			04		       .byte.b	<(tiles0+0)
   3914  242bf			04		       .byte.b	<(tiles0+0)
   3915  242c0			04		       .byte.b	<(tiles0+0)
   3916  242c1			04		       .byte.b	<(tiles0+0)
   3917  242c2			04		       .byte.b	<(tiles0+0)
   3918  242c3			04		       .byte.b	<(tiles0+0)
   3919  242c4			04		       .byte.b	<(tiles0+0)
   3920  242c5			04		       .byte.b	<(tiles0+0)
   3921  242c6			04		       .byte.b	<(tiles0+0)
   3922  242c7			04		       .byte.b	<(tiles0+0)
   3923  242c8			04		       .byte.b	<(tiles0+0)
   3924  242c9			04		       .byte.b	<(tiles0+0)
   3925  242ca			04		       .byte.b	<(tiles0+0)
   3926  242cb			04		       .byte.b	<(tiles0+0)
   3927  242cc			04		       .byte.b	<(tiles0+0)
   3928  242cd			04		       .byte.b	<(tiles0+0)
   3929  242ce			04		       .byte.b	<(tiles0+0)
   3930  242cf			04		       .byte.b	<(tiles0+0)
   3931  242d0			04		       .byte.b	<(tiles0+0)
   3932  242d1			04		       .byte.b	<(tiles0+0)
   3933  242d2			04		       .byte.b	<(tiles0+0)
   3934  242d3			04		       .byte.b	<(tiles0+0)
   3935  242d4			04		       .byte.b	<(tiles0+0)
   3936  242d5			04		       .byte.b	<(tiles0+0)
   3937  242d6			04		       .byte.b	<(tiles0+0)
   3938  242d7			04		       .byte.b	<(tiles0+0)
   3939  242d8			04		       .byte.b	<(tiles0+0)
   3940  242d9			04		       .byte.b	<(tiles0+0)
   3941  242da			04		       .byte.b	<(tiles0+0)
   3942  242db			04		       .byte.b	<(tiles0+0)
   3943  242dc			04		       .byte.b	<(tiles0+0)
   3944  242dd			04		       .byte.b	<(tiles0+0)
   3945  242de			04		       .byte.b	<(tiles0+0)
   3946  242df			04		       .byte.b	<(tiles0+0)
   3947  242e0			04		       .byte.b	<(tiles0+0)
   3948  242e1			04		       .byte.b	<(tiles0+0)
   3949  242e2			04		       .byte.b	<(tiles0+0)
   3950  242e3			04		       .byte.b	<(tiles0+0)
   3951  242e4			04		       .byte.b	<(tiles0+0)
   3952  242e5			04		       .byte.b	<(tiles0+0)
   3953  242e6			04		       .byte.b	<(tiles0+0)
   3954  242e7			04		       .byte.b	<(tiles0+0)
   3955  242e8			04		       .byte.b	<(tiles0+0)
   3956  242e9			04		       .byte.b	<(tiles0+0)
   3957  242ea			04		       .byte.b	<(tiles0+0)
   3958  242eb			04		       .byte.b	<(tiles0+0)
   3959  242ec			04		       .byte.b	<(tiles0+0)
   3960  242ed			04		       .byte.b	<(tiles0+0)
   3961  242ee			04		       .byte.b	<(tiles0+0)
   3962  242ef			04		       .byte.b	<(tiles0+0)
   3963  242f0			04		       .byte.b	<(tiles0+0)
   3964  242f1			04		       .byte.b	<(tiles0+0)
   3965  242f2			04		       .byte.b	<(tiles0+0)
   3966  242f3			04		       .byte.b	<(tiles0+0)
   3967  242f4			04		       .byte.b	<(tiles0+0)
   3968  242f5			04		       .byte.b	<(tiles0+0)
   3969  242f6			04		       .byte.b	<(tiles0+0)
   3970  242f7			04		       .byte.b	<(tiles0+0)
   3971  242f8			04		       .byte.b	<(tiles0+0)
   3972  242f9			06		       .byte.b	<(tiles2+0)
   3973  242fa			04		       .byte.b	<(tiles0+0)
   3974  242fb			04		       .byte.b	<(tiles0+0)
   3975  242fc			04		       .byte.b	<(tiles0+0)
   3976  242fd			04		       .byte.b	<(tiles0+0)
   3977  242fe			04		       .byte.b	<(tiles0+0)
   3978  242ff			04		       .byte.b	<(tiles0+0)
   3979  24300			04		       .byte.b	<(tiles0+0)
   3980  24301			06		       .byte.b	<(tiles2+0)
   3981  24302			04		       .byte.b	<(tiles0+0)
   3982  24303			04		       .byte.b	<(tiles0+0)
   3983  24304			04		       .byte.b	<(tiles0+0)
   3984  24305			04		       .byte.b	<(tiles0+0)
   3985  24306			04		       .byte.b	<(tiles0+0)
   3986  24307			04		       .byte.b	<(tiles0+0)
   3987  24308			04		       .byte.b	<(tiles0+0)
   3988  24309			04		       .byte.b	<(tiles0+0)
   3989  2430a			04		       .byte.b	<(tiles0+0)
   3990  2430b			04		       .byte.b	<(tiles0+0)
   3991  2430c			04		       .byte.b	<(tiles0+0)
   3992  2430d			04		       .byte.b	<(tiles0+0)
   3993  2430e			04		       .byte.b	<(tiles0+0)
   3994  2430f			04		       .byte.b	<(tiles0+0)
   3995  24310			04		       .byte.b	<(tiles0+0)
   3996  24311			04		       .byte.b	<(tiles0+0)
   3997  24312			04		       .byte.b	<(tiles0+0)
   3998  24313			04		       .byte.b	<(tiles0+0)
   3999  24314			04		       .byte.b	<(tiles0+0)
   4000  24315			04		       .byte.b	<(tiles0+0)
   4001  24316			04		       .byte.b	<(tiles0+0)
   4002  24317			04		       .byte.b	<(tiles0+0)
   4003  24318			04		       .byte.b	<(tiles0+0)
   4004  24319			04		       .byte.b	<(tiles0+0)
   4005  2431a			04		       .byte.b	<(tiles0+0)
   4006  2431b			04		       .byte.b	<(tiles0+0)
   4007  2431c			04		       .byte.b	<(tiles0+0)
   4008  2431d			04		       .byte.b	<(tiles0+0)
   4009  2431e			04		       .byte.b	<(tiles0+0)
   4010  2431f			04		       .byte.b	<(tiles0+0)
   4011  24320			04		       .byte.b	<(tiles0+0)
   4012  24321			04		       .byte.b	<(tiles0+0)
   4013  24322			04		       .byte.b	<(tiles0+0)
   4014  24323			04		       .byte.b	<(tiles0+0)
   4015  24324			04		       .byte.b	<(tiles0+0)
   4016  24325			04		       .byte.b	<(tiles0+0)
   4017  24326			04		       .byte.b	<(tiles0+0)
   4018  24327			04		       .byte.b	<(tiles0+0)
   4019  24328			04		       .byte.b	<(tiles0+0)
   4020  24329			04		       .byte.b	<(tiles0+0)
   4021  2432a			04		       .byte.b	<(tiles0+0)
   4022  2432b			04		       .byte.b	<(tiles0+0)
   4023  2432c			04		       .byte.b	<(tiles0+0)
   4024  2432d			04		       .byte.b	<(tiles0+0)
   4025  2432e			04		       .byte.b	<(tiles0+0)
   4026  2432f			04		       .byte.b	<(tiles0+0)
   4027  24330			04		       .byte.b	<(tiles0+0)
   4028  24331			04		       .byte.b	<(tiles0+0)
   4029  24332			04		       .byte.b	<(tiles0+0)
   4030  24333			04		       .byte.b	<(tiles0+0)
   4031  24334			04		       .byte.b	<(tiles0+0)
   4032  24335			04		       .byte.b	<(tiles0+0)
   4033  24336			04		       .byte.b	<(tiles0+0)
   4034  24337			04		       .byte.b	<(tiles0+0)
   4035  24338			04		       .byte.b	<(tiles0+0)
   4036  24339			04		       .byte.b	<(tiles0+0)
   4037  2433a			04		       .byte.b	<(tiles0+0)
   4038  2433b			04		       .byte.b	<(tiles0+0)
   4039  2433c			04		       .byte.b	<(tiles0+0)
   4040  2433d			04		       .byte.b	<(tiles0+0)
   4041  2433e			04		       .byte.b	<(tiles0+0)
   4042  2433f			04		       .byte.b	<(tiles0+0)
   4043  24340			04		       .byte.b	<(tiles0+0)
   4044  24341			04		       .byte.b	<(tiles0+0)
   4045  24342			04		       .byte.b	<(tiles0+0)
   4046  24343			04		       .byte.b	<(tiles0+0)
   4047  24344			04		       .byte.b	<(tiles0+0)
   4048  24345			04		       .byte.b	<(tiles0+0)
   4049  24346			04		       .byte.b	<(tiles0+0)
   4050  24347			04		       .byte.b	<(tiles0+0)
   4051  24348			04		       .byte.b	<(tiles0+0)
   4052  24349			04		       .byte.b	<(tiles0+0)
   4053  2434a			04		       .byte.b	<(tiles0+0)
   4054  2434b			04		       .byte.b	<(tiles0+0)
   4055  2434c			04		       .byte.b	<(tiles0+0)
   4056  2434d			04		       .byte.b	<(tiles0+0)
   4057  2434e			04		       .byte.b	<(tiles0+0)
   4058  2434f			04		       .byte.b	<(tiles0+0)
   4059  24350			04		       .byte.b	<(tiles0+0)
   4060  24351			04		       .byte.b	<(tiles0+0)
   4061  24352			04		       .byte.b	<(tiles0+0)
   4062  24353			04		       .byte.b	<(tiles0+0)
   4063  24354			04		       .byte.b	<(tiles0+0)
   4064  24355			04		       .byte.b	<(tiles0+0)
   4065  24356			04		       .byte.b	<(tiles0+0)
   4066  24357			04		       .byte.b	<(tiles0+0)
   4067  24358			04		       .byte.b	<(tiles0+0)
   4068  24359			04		       .byte.b	<(tiles0+0)
   4069  2435a			04		       .byte.b	<(tiles0+0)
   4070  2435b			04		       .byte.b	<(tiles0+0)
   4071  2435c			04		       .byte.b	<(tiles0+0)
   4072  2435d			04		       .byte.b	<(tiles0+0)
   4073  2435e			04		       .byte.b	<(tiles0+0)
   4074  2435f			04		       .byte.b	<(tiles0+0)
   4075  24360			04		       .byte.b	<(tiles0+0)
   4076  24361			04		       .byte.b	<(tiles0+0)
   4077  24362			04		       .byte.b	<(tiles0+0)
   4078  24363			04		       .byte.b	<(tiles0+0)
   4079  24364			04		       .byte.b	<(tiles0+0)
   4080  24365			04		       .byte.b	<(tiles0+0)
   4081  24366			04		       .byte.b	<(tiles0+0)
   4082  24367			04		       .byte.b	<(tiles0+0)
   4083  24368			04		       .byte.b	<(tiles0+0)
   4084  24369			04		       .byte.b	<(tiles0+0)
   4085  2436a			04		       .byte.b	<(tiles0+0)
   4086  2436b			04		       .byte.b	<(tiles0+0)
   4087  2436c			04		       .byte.b	<(tiles0+0)
   4088  2436d			04		       .byte.b	<(tiles0+0)
   4089  2436e			04		       .byte.b	<(tiles0+0)
   4090  2436f			04		       .byte.b	<(tiles0+0)
   4091  24370			04		       .byte.b	<(tiles0+0)
   4092  24371			04		       .byte.b	<(tiles0+0)
   4093  24372			04		       .byte.b	<(tiles0+0)
   4094  24373			04		       .byte.b	<(tiles0+0)
   4095  24374			04		       .byte.b	<(tiles0+0)
   4096  24375			04		       .byte.b	<(tiles0+0)
   4097  24376			04		       .byte.b	<(tiles0+0)
   4098  24377			04		       .byte.b	<(tiles0+0)
   4099  24378			04		       .byte.b	<(tiles0+0)
   4100  24379			04		       .byte.b	<(tiles0+0)
   4101  2437a			04		       .byte.b	<(tiles0+0)
   4102  2437b			04		       .byte.b	<(tiles0+0)
   4103  2437c			04		       .byte.b	<(tiles0+0)
   4104  2437d			04		       .byte.b	<(tiles0+0)
   4105  2437e			04		       .byte.b	<(tiles0+0)
   4106  2437f			04		       .byte.b	<(tiles0+0)
   4107  24380			04		       .byte.b	<(tiles0+0)
   4108  24381			04		       .byte.b	<(tiles0+0)
   4109  24382			04		       .byte.b	<(tiles0+0)
   4110  24383			04		       .byte.b	<(tiles0+0)
   4111  24384			04		       .byte.b	<(tiles0+0)
   4112  24385			04		       .byte.b	<(tiles0+0)
   4113  24386			04		       .byte.b	<(tiles0+0)
   4114  24387			04		       .byte.b	<(tiles0+0)
   4115  24388			04		       .byte.b	<(tiles0+0)
   4116  24389			04		       .byte.b	<(tiles0+0)
   4117  2438a			04		       .byte.b	<(tiles0+0)
   4118  2438b			04		       .byte.b	<(tiles0+0)
   4119  2438c			04		       .byte.b	<(tiles0+0)
   4120  2438d			04		       .byte.b	<(tiles0+0)
   4121  2438e			04		       .byte.b	<(tiles0+0)
   4122  2438f			04		       .byte.b	<(tiles0+0)
   4123  24390			04		       .byte.b	<(tiles0+0)
   4124  24391			04		       .byte.b	<(tiles0+0)
   4125  24392			04		       .byte.b	<(tiles0+0)
   4126  24393			04		       .byte.b	<(tiles0+0)
   4127  24394			04		       .byte.b	<(tiles0+0)
   4128  24395			04		       .byte.b	<(tiles0+0)
   4129  24396			04		       .byte.b	<(tiles0+0)
   4130  24397			04		       .byte.b	<(tiles0+0)
   4131  24398			04		       .byte.b	<(tiles0+0)
   4132  24399			04		       .byte.b	<(tiles0+0)
   4133  2439a			04		       .byte.b	<(tiles0+0)
   4134  2439b			04		       .byte.b	<(tiles0+0)
   4135  2439c			04		       .byte.b	<(tiles0+0)
   4136  2439d			04		       .byte.b	<(tiles0+0)
   4137  2439e			04		       .byte.b	<(tiles0+0)
   4138  2439f			04		       .byte.b	<(tiles0+0)
   4139  243a0			04		       .byte.b	<(tiles0+0)
   4140  243a1			04		       .byte.b	<(tiles0+0)
   4141  243a2			04		       .byte.b	<(tiles0+0)
   4142  243a3			04		       .byte.b	<(tiles0+0)
   4143  243a4			04		       .byte.b	<(tiles0+0)
   4144  243a5			04		       .byte.b	<(tiles0+0)
   4145  243a6			04		       .byte.b	<(tiles0+0)
   4146  243a7			04		       .byte.b	<(tiles0+0)
   4147  243a8			04		       .byte.b	<(tiles0+0)
   4148  243a9			04		       .byte.b	<(tiles0+0)
   4149  243aa			04		       .byte.b	<(tiles0+0)
   4150  243ab			04		       .byte.b	<(tiles0+0)
   4151  243ac			04		       .byte.b	<(tiles0+0)
   4152  243ad			04		       .byte.b	<(tiles0+0)
   4153  243ae			04		       .byte.b	<(tiles0+0)
   4154  243af			04		       .byte.b	<(tiles0+0)
   4155  243b0			04		       .byte.b	<(tiles0+0)
   4156  243b1			04		       .byte.b	<(tiles0+0)
   4157  243b2			04		       .byte.b	<(tiles0+0)
   4158  243b3			04		       .byte.b	<(tiles0+0)
   4159  243b4			04		       .byte.b	<(tiles0+0)
   4160  243b5			04		       .byte.b	<(tiles0+0)
   4161  243b6			04		       .byte.b	<(tiles0+0)
   4162  243b7			04		       .byte.b	<(tiles0+0)
   4163  243b8			04		       .byte.b	<(tiles0+0)
   4164  243b9			04		       .byte.b	<(tiles0+0)
   4165  243ba			04		       .byte.b	<(tiles0+0)
   4166  243bb			04		       .byte.b	<(tiles0+0)
   4167  243bc			04		       .byte.b	<(tiles0+0)
   4168  243bd			04		       .byte.b	<(tiles0+0)
   4169  243be			04		       .byte.b	<(tiles0+0)
   4170  243bf			04		       .byte.b	<(tiles0+0)
   4171  243c0			04		       .byte.b	<(tiles0+0)
   4172  243c1			04		       .byte.b	<(tiles0+0)
   4173  243c2			04		       .byte.b	<(tiles0+0)
   4174  243c3			04		       .byte.b	<(tiles0+0)
   4175  243c4			04		       .byte.b	<(tiles0+0)
   4176  243c5			04		       .byte.b	<(tiles0+0)
   4177  243c6			04		       .byte.b	<(tiles0+0)
   4178  243c7			04		       .byte.b	<(tiles0+0)
   4179  243c8			04		       .byte.b	<(tiles0+0)
   4180  243c9			04		       .byte.b	<(tiles0+0)
   4181  243ca			04		       .byte.b	<(tiles0+0)
   4182  243cb			04		       .byte.b	<(tiles0+0)
   4183  243cc			04		       .byte.b	<(tiles0+0)
   4184  243cd			04		       .byte.b	<(tiles0+0)
   4185  243ce			04		       .byte.b	<(tiles0+0)
   4186  243cf			04		       .byte.b	<(tiles0+0)
   4187  243d0			04		       .byte.b	<(tiles0+0)
   4188  243d1			04		       .byte.b	<(tiles0+0)
   4189  243d2			04		       .byte.b	<(tiles0+0)
   4190  243d3			04		       .byte.b	<(tiles0+0)
   4191  243d4			04		       .byte.b	<(tiles0+0)
   4192  243d5			04		       .byte.b	<(tiles0+0)
   4193  243d6			04		       .byte.b	<(tiles0+0)
   4194  243d7			04		       .byte.b	<(tiles0+0)
   4195  243d8			04		       .byte.b	<(tiles0+0)
   4196  243d9			04		       .byte.b	<(tiles0+0)
   4197  243da			04		       .byte.b	<(tiles0+0)
   4198  243db			04		       .byte.b	<(tiles0+0)
   4199  243dc			04		       .byte.b	<(tiles0+0)
   4200  243dd			04		       .byte.b	<(tiles0+0)
   4201  243de			04		       .byte.b	<(tiles0+0)
   4202  243df			04		       .byte.b	<(tiles0+0)
   4203  243e0			04		       .byte.b	<(tiles0+0)
   4204  243e1			04		       .byte.b	<(tiles0+0)
   4205  243e2			04		       .byte.b	<(tiles0+0)
   4206  243e3			04		       .byte.b	<(tiles0+0)
   4207  243e4			04		       .byte.b	<(tiles0+0)
   4208  243e5			04		       .byte.b	<(tiles0+0)
   4209  243e6			04		       .byte.b	<(tiles0+0)
   4210  243e7			04		       .byte.b	<(tiles0+0)
   4211  243e8			04		       .byte.b	<(tiles0+0)
   4212  243e9			04		       .byte.b	<(tiles0+0)
   4213  243ea			04		       .byte.b	<(tiles0+0)
   4214  243eb			04		       .byte.b	<(tiles0+0)
   4215  243ec			04		       .byte.b	<(tiles0+0)
   4216  243ed			04		       .byte.b	<(tiles0+0)
   4217  243ee			04		       .byte.b	<(tiles0+0)
   4218  243ef			04		       .byte.b	<(tiles0+0)
   4219  243f0			04		       .byte.b	<(tiles0+0)
   4220  243f1			04		       .byte.b	<(tiles0+0)
   4221  243f2			04		       .byte.b	<(tiles0+0)
   4222  243f3			04		       .byte.b	<(tiles0+0)
   4223  243f4			04		       .byte.b	<(tiles0+0)
   4224  243f5			04		       .byte.b	<(tiles0+0)
   4225  243f6			04		       .byte.b	<(tiles0+0)
   4226  243f7			04		       .byte.b	<(tiles0+0)
   4227  243f8			06		       .byte.b	<(tiles2+0)
   4228  243f9			04		       .byte.b	<(tiles0+0)
   4229  243fa			04		       .byte.b	<(tiles0+0)
   4230  243fb			04		       .byte.b	<(tiles0+0)
   4231  243fc			04		       .byte.b	<(tiles0+0)
   4232  243fd			04		       .byte.b	<(tiles0+0)
   4233  243fe			04		       .byte.b	<(tiles0+0)
   4234  243ff			04		       .byte.b	<(tiles0+0)
   4235  24400			06		       .byte.b	<(tiles2+0)
   4236  24401			06		       .byte.b	<(tiles2+0)
   4237  24402			04		       .byte.b	<(tiles0+0)
   4238  24403			04		       .byte.b	<(tiles0+0)
   4239  24404			04		       .byte.b	<(tiles0+0)
   4240  24405			04		       .byte.b	<(tiles0+0)
   4241  24406			04		       .byte.b	<(tiles0+0)
   4242  24407			04		       .byte.b	<(tiles0+0)
   4243  24408			04		       .byte.b	<(tiles0+0)
   4244  24409			04		       .byte.b	<(tiles0+0)
   4245  2440a			04		       .byte.b	<(tiles0+0)
   4246  2440b			04		       .byte.b	<(tiles0+0)
   4247  2440c			04		       .byte.b	<(tiles0+0)
   4248  2440d			04		       .byte.b	<(tiles0+0)
   4249  2440e			04		       .byte.b	<(tiles0+0)
   4250  2440f			04		       .byte.b	<(tiles0+0)
   4251  24410			04		       .byte.b	<(tiles0+0)
   4252  24411			04		       .byte.b	<(tiles0+0)
   4253  24412			04		       .byte.b	<(tiles0+0)
   4254  24413			04		       .byte.b	<(tiles0+0)
   4255  24414			04		       .byte.b	<(tiles0+0)
   4256  24415			04		       .byte.b	<(tiles0+0)
   4257  24416			04		       .byte.b	<(tiles0+0)
   4258  24417			04		       .byte.b	<(tiles0+0)
   4259  24418			04		       .byte.b	<(tiles0+0)
   4260  24419			04		       .byte.b	<(tiles0+0)
   4261  2441a			04		       .byte.b	<(tiles0+0)
   4262  2441b			04		       .byte.b	<(tiles0+0)
   4263  2441c			04		       .byte.b	<(tiles0+0)
   4264  2441d			04		       .byte.b	<(tiles0+0)
   4265  2441e			04		       .byte.b	<(tiles0+0)
   4266  2441f			04		       .byte.b	<(tiles0+0)
   4267  24420			04		       .byte.b	<(tiles0+0)
   4268  24421			04		       .byte.b	<(tiles0+0)
   4269  24422			04		       .byte.b	<(tiles0+0)
   4270  24423			04		       .byte.b	<(tiles0+0)
   4271  24424			04		       .byte.b	<(tiles0+0)
   4272  24425			04		       .byte.b	<(tiles0+0)
   4273  24426			04		       .byte.b	<(tiles0+0)
   4274  24427			04		       .byte.b	<(tiles0+0)
   4275  24428			04		       .byte.b	<(tiles0+0)
   4276  24429			04		       .byte.b	<(tiles0+0)
   4277  2442a			04		       .byte.b	<(tiles0+0)
   4278  2442b			04		       .byte.b	<(tiles0+0)
   4279  2442c			04		       .byte.b	<(tiles0+0)
   4280  2442d			04		       .byte.b	<(tiles0+0)
   4281  2442e			04		       .byte.b	<(tiles0+0)
   4282  2442f			04		       .byte.b	<(tiles0+0)
   4283  24430			04		       .byte.b	<(tiles0+0)
   4284  24431			04		       .byte.b	<(tiles0+0)
   4285  24432			04		       .byte.b	<(tiles0+0)
   4286  24433			04		       .byte.b	<(tiles0+0)
   4287  24434			04		       .byte.b	<(tiles0+0)
   4288  24435			04		       .byte.b	<(tiles0+0)
   4289  24436			04		       .byte.b	<(tiles0+0)
   4290  24437			04		       .byte.b	<(tiles0+0)
   4291  24438			04		       .byte.b	<(tiles0+0)
   4292  24439			04		       .byte.b	<(tiles0+0)
   4293  2443a			04		       .byte.b	<(tiles0+0)
   4294  2443b			04		       .byte.b	<(tiles0+0)
   4295  2443c			04		       .byte.b	<(tiles0+0)
   4296  2443d			04		       .byte.b	<(tiles0+0)
   4297  2443e			04		       .byte.b	<(tiles0+0)
   4298  2443f			04		       .byte.b	<(tiles0+0)
   4299  24440			04		       .byte.b	<(tiles0+0)
   4300  24441			04		       .byte.b	<(tiles0+0)
   4301  24442			04		       .byte.b	<(tiles0+0)
   4302  24443			04		       .byte.b	<(tiles0+0)
   4303  24444			04		       .byte.b	<(tiles0+0)
   4304  24445			04		       .byte.b	<(tiles0+0)
   4305  24446			04		       .byte.b	<(tiles0+0)
   4306  24447			04		       .byte.b	<(tiles0+0)
   4307  24448			04		       .byte.b	<(tiles0+0)
   4308  24449			04		       .byte.b	<(tiles0+0)
   4309  2444a			04		       .byte.b	<(tiles0+0)
   4310  2444b			04		       .byte.b	<(tiles0+0)
   4311  2444c			04		       .byte.b	<(tiles0+0)
   4312  2444d			04		       .byte.b	<(tiles0+0)
   4313  2444e			04		       .byte.b	<(tiles0+0)
   4314  2444f			04		       .byte.b	<(tiles0+0)
   4315  24450			04		       .byte.b	<(tiles0+0)
   4316  24451			04		       .byte.b	<(tiles0+0)
   4317  24452			04		       .byte.b	<(tiles0+0)
   4318  24453			04		       .byte.b	<(tiles0+0)
   4319  24454			04		       .byte.b	<(tiles0+0)
   4320  24455			04		       .byte.b	<(tiles0+0)
   4321  24456			04		       .byte.b	<(tiles0+0)
   4322  24457			04		       .byte.b	<(tiles0+0)
   4323  24458			04		       .byte.b	<(tiles0+0)
   4324  24459			04		       .byte.b	<(tiles0+0)
   4325  2445a			04		       .byte.b	<(tiles0+0)
   4326  2445b			04		       .byte.b	<(tiles0+0)
   4327  2445c			04		       .byte.b	<(tiles0+0)
   4328  2445d			04		       .byte.b	<(tiles0+0)
   4329  2445e			04		       .byte.b	<(tiles0+0)
   4330  2445f			04		       .byte.b	<(tiles0+0)
   4331  24460			04		       .byte.b	<(tiles0+0)
   4332  24461			04		       .byte.b	<(tiles0+0)
   4333  24462			04		       .byte.b	<(tiles0+0)
   4334  24463			04		       .byte.b	<(tiles0+0)
   4335  24464			04		       .byte.b	<(tiles0+0)
   4336  24465			04		       .byte.b	<(tiles0+0)
   4337  24466			04		       .byte.b	<(tiles0+0)
   4338  24467			04		       .byte.b	<(tiles0+0)
   4339  24468			04		       .byte.b	<(tiles0+0)
   4340  24469			04		       .byte.b	<(tiles0+0)
   4341  2446a			04		       .byte.b	<(tiles0+0)
   4342  2446b			04		       .byte.b	<(tiles0+0)
   4343  2446c			04		       .byte.b	<(tiles0+0)
   4344  2446d			04		       .byte.b	<(tiles0+0)
   4345  2446e			04		       .byte.b	<(tiles0+0)
   4346  2446f			04		       .byte.b	<(tiles0+0)
   4347  24470			04		       .byte.b	<(tiles0+0)
   4348  24471			04		       .byte.b	<(tiles0+0)
   4349  24472			04		       .byte.b	<(tiles0+0)
   4350  24473			04		       .byte.b	<(tiles0+0)
   4351  24474			04		       .byte.b	<(tiles0+0)
   4352  24475			04		       .byte.b	<(tiles0+0)
   4353  24476			04		       .byte.b	<(tiles0+0)
   4354  24477			04		       .byte.b	<(tiles0+0)
   4355  24478			04		       .byte.b	<(tiles0+0)
   4356  24479			04		       .byte.b	<(tiles0+0)
   4357  2447a			04		       .byte.b	<(tiles0+0)
   4358  2447b			04		       .byte.b	<(tiles0+0)
   4359  2447c			04		       .byte.b	<(tiles0+0)
   4360  2447d			04		       .byte.b	<(tiles0+0)
   4361  2447e			04		       .byte.b	<(tiles0+0)
   4362  2447f			04		       .byte.b	<(tiles0+0)
   4363  24480			04		       .byte.b	<(tiles0+0)
   4364  24481			04		       .byte.b	<(tiles0+0)
   4365  24482			04		       .byte.b	<(tiles0+0)
   4366  24483			04		       .byte.b	<(tiles0+0)
   4367  24484			04		       .byte.b	<(tiles0+0)
   4368  24485			04		       .byte.b	<(tiles0+0)
   4369  24486			04		       .byte.b	<(tiles0+0)
   4370  24487			04		       .byte.b	<(tiles0+0)
   4371  24488			04		       .byte.b	<(tiles0+0)
   4372  24489			04		       .byte.b	<(tiles0+0)
   4373  2448a			04		       .byte.b	<(tiles0+0)
   4374  2448b			04		       .byte.b	<(tiles0+0)
   4375  2448c			04		       .byte.b	<(tiles0+0)
   4376  2448d			04		       .byte.b	<(tiles0+0)
   4377  2448e			04		       .byte.b	<(tiles0+0)
   4378  2448f			04		       .byte.b	<(tiles0+0)
   4379  24490			04		       .byte.b	<(tiles0+0)
   4380  24491			04		       .byte.b	<(tiles0+0)
   4381  24492			04		       .byte.b	<(tiles0+0)
   4382  24493			04		       .byte.b	<(tiles0+0)
   4383  24494			04		       .byte.b	<(tiles0+0)
   4384  24495			04		       .byte.b	<(tiles0+0)
   4385  24496			04		       .byte.b	<(tiles0+0)
   4386  24497			04		       .byte.b	<(tiles0+0)
   4387  24498			04		       .byte.b	<(tiles0+0)
   4388  24499			04		       .byte.b	<(tiles0+0)
   4389  2449a			04		       .byte.b	<(tiles0+0)
   4390  2449b			04		       .byte.b	<(tiles0+0)
   4391  2449c			04		       .byte.b	<(tiles0+0)
   4392  2449d			04		       .byte.b	<(tiles0+0)
   4393  2449e			04		       .byte.b	<(tiles0+0)
   4394  2449f			04		       .byte.b	<(tiles0+0)
   4395  244a0			04		       .byte.b	<(tiles0+0)
   4396  244a1			04		       .byte.b	<(tiles0+0)
   4397  244a2			04		       .byte.b	<(tiles0+0)
   4398  244a3			04		       .byte.b	<(tiles0+0)
   4399  244a4			04		       .byte.b	<(tiles0+0)
   4400  244a5			04		       .byte.b	<(tiles0+0)
   4401  244a6			04		       .byte.b	<(tiles0+0)
   4402  244a7			04		       .byte.b	<(tiles0+0)
   4403  244a8			04		       .byte.b	<(tiles0+0)
   4404  244a9			04		       .byte.b	<(tiles0+0)
   4405  244aa			04		       .byte.b	<(tiles0+0)
   4406  244ab			04		       .byte.b	<(tiles0+0)
   4407  244ac			04		       .byte.b	<(tiles0+0)
   4408  244ad			04		       .byte.b	<(tiles0+0)
   4409  244ae			04		       .byte.b	<(tiles0+0)
   4410  244af			04		       .byte.b	<(tiles0+0)
   4411  244b0			04		       .byte.b	<(tiles0+0)
   4412  244b1			04		       .byte.b	<(tiles0+0)
   4413  244b2			04		       .byte.b	<(tiles0+0)
   4414  244b3			04		       .byte.b	<(tiles0+0)
   4415  244b4			04		       .byte.b	<(tiles0+0)
   4416  244b5			04		       .byte.b	<(tiles0+0)
   4417  244b6			04		       .byte.b	<(tiles0+0)
   4418  244b7			04		       .byte.b	<(tiles0+0)
   4419  244b8			04		       .byte.b	<(tiles0+0)
   4420  244b9			04		       .byte.b	<(tiles0+0)
   4421  244ba			04		       .byte.b	<(tiles0+0)
   4422  244bb			04		       .byte.b	<(tiles0+0)
   4423  244bc			04		       .byte.b	<(tiles0+0)
   4424  244bd			04		       .byte.b	<(tiles0+0)
   4425  244be			04		       .byte.b	<(tiles0+0)
   4426  244bf			04		       .byte.b	<(tiles0+0)
   4427  244c0			04		       .byte.b	<(tiles0+0)
   4428  244c1			04		       .byte.b	<(tiles0+0)
   4429  244c2			04		       .byte.b	<(tiles0+0)
   4430  244c3			04		       .byte.b	<(tiles0+0)
   4431  244c4			04		       .byte.b	<(tiles0+0)
   4432  244c5			04		       .byte.b	<(tiles0+0)
   4433  244c6			04		       .byte.b	<(tiles0+0)
   4434  244c7			04		       .byte.b	<(tiles0+0)
   4435  244c8			04		       .byte.b	<(tiles0+0)
   4436  244c9			04		       .byte.b	<(tiles0+0)
   4437  244ca			04		       .byte.b	<(tiles0+0)
   4438  244cb			04		       .byte.b	<(tiles0+0)
   4439  244cc			04		       .byte.b	<(tiles0+0)
   4440  244cd			04		       .byte.b	<(tiles0+0)
   4441  244ce			04		       .byte.b	<(tiles0+0)
   4442  244cf			04		       .byte.b	<(tiles0+0)
   4443  244d0			04		       .byte.b	<(tiles0+0)
   4444  244d1			04		       .byte.b	<(tiles0+0)
   4445  244d2			04		       .byte.b	<(tiles0+0)
   4446  244d3			04		       .byte.b	<(tiles0+0)
   4447  244d4			04		       .byte.b	<(tiles0+0)
   4448  244d5			04		       .byte.b	<(tiles0+0)
   4449  244d6			04		       .byte.b	<(tiles0+0)
   4450  244d7			04		       .byte.b	<(tiles0+0)
   4451  244d8			04		       .byte.b	<(tiles0+0)
   4452  244d9			04		       .byte.b	<(tiles0+0)
   4453  244da			04		       .byte.b	<(tiles0+0)
   4454  244db			04		       .byte.b	<(tiles0+0)
   4455  244dc			04		       .byte.b	<(tiles0+0)
   4456  244dd			04		       .byte.b	<(tiles0+0)
   4457  244de			04		       .byte.b	<(tiles0+0)
   4458  244df			04		       .byte.b	<(tiles0+0)
   4459  244e0			04		       .byte.b	<(tiles0+0)
   4460  244e1			04		       .byte.b	<(tiles0+0)
   4461  244e2			04		       .byte.b	<(tiles0+0)
   4462  244e3			04		       .byte.b	<(tiles0+0)
   4463  244e4			04		       .byte.b	<(tiles0+0)
   4464  244e5			04		       .byte.b	<(tiles0+0)
   4465  244e6			04		       .byte.b	<(tiles0+0)
   4466  244e7			04		       .byte.b	<(tiles0+0)
   4467  244e8			04		       .byte.b	<(tiles0+0)
   4468  244e9			04		       .byte.b	<(tiles0+0)
   4469  244ea			04		       .byte.b	<(tiles0+0)
   4470  244eb			04		       .byte.b	<(tiles0+0)
   4471  244ec			04		       .byte.b	<(tiles0+0)
   4472  244ed			04		       .byte.b	<(tiles0+0)
   4473  244ee			04		       .byte.b	<(tiles0+0)
   4474  244ef			04		       .byte.b	<(tiles0+0)
   4475  244f0			04		       .byte.b	<(tiles0+0)
   4476  244f1			04		       .byte.b	<(tiles0+0)
   4477  244f2			04		       .byte.b	<(tiles0+0)
   4478  244f3			04		       .byte.b	<(tiles0+0)
   4479  244f4			04		       .byte.b	<(tiles0+0)
   4480  244f5			04		       .byte.b	<(tiles0+0)
   4481  244f6			04		       .byte.b	<(tiles0+0)
   4482  244f7			06		       .byte.b	<(tiles2+0)
   4483  244f8			04		       .byte.b	<(tiles0+0)
   4484  244f9			04		       .byte.b	<(tiles0+0)
   4485  244fa			04		       .byte.b	<(tiles0+0)
   4486  244fb			04		       .byte.b	<(tiles0+0)
   4487  244fc			04		       .byte.b	<(tiles0+0)
   4488  244fd			04		       .byte.b	<(tiles0+0)
   4489  244fe			04		       .byte.b	<(tiles0+0)
   4490  244ff			06		       .byte.b	<(tiles2+0)
   4491  24500			06		       .byte.b	<(tiles2+0)
   4492  24501			04		       .byte.b	<(tiles0+0)
   4493  24502			04		       .byte.b	<(tiles0+0)
   4494  24503			04		       .byte.b	<(tiles0+0)
   4495  24504			04		       .byte.b	<(tiles0+0)
   4496  24505			04		       .byte.b	<(tiles0+0)
   4497  24506			04		       .byte.b	<(tiles0+0)
   4498  24507			04		       .byte.b	<(tiles0+0)
   4499  24508			04		       .byte.b	<(tiles0+0)
   4500  24509			04		       .byte.b	<(tiles0+0)
   4501  2450a			04		       .byte.b	<(tiles0+0)
   4502  2450b			04		       .byte.b	<(tiles0+0)
   4503  2450c			04		       .byte.b	<(tiles0+0)
   4504  2450d			04		       .byte.b	<(tiles0+0)
   4505  2450e			04		       .byte.b	<(tiles0+0)
   4506  2450f			04		       .byte.b	<(tiles0+0)
   4507  24510			04		       .byte.b	<(tiles0+0)
   4508  24511			04		       .byte.b	<(tiles0+0)
   4509  24512			04		       .byte.b	<(tiles0+0)
   4510  24513			04		       .byte.b	<(tiles0+0)
   4511  24514			04		       .byte.b	<(tiles0+0)
   4512  24515			04		       .byte.b	<(tiles0+0)
   4513  24516			04		       .byte.b	<(tiles0+0)
   4514  24517			04		       .byte.b	<(tiles0+0)
   4515  24518			04		       .byte.b	<(tiles0+0)
   4516  24519			04		       .byte.b	<(tiles0+0)
   4517  2451a			04		       .byte.b	<(tiles0+0)
   4518  2451b			04		       .byte.b	<(tiles0+0)
   4519  2451c			04		       .byte.b	<(tiles0+0)
   4520  2451d			04		       .byte.b	<(tiles0+0)
   4521  2451e			04		       .byte.b	<(tiles0+0)
   4522  2451f			04		       .byte.b	<(tiles0+0)
   4523  24520			04		       .byte.b	<(tiles0+0)
   4524  24521			04		       .byte.b	<(tiles0+0)
   4525  24522			04		       .byte.b	<(tiles0+0)
   4526  24523			04		       .byte.b	<(tiles0+0)
   4527  24524			04		       .byte.b	<(tiles0+0)
   4528  24525			04		       .byte.b	<(tiles0+0)
   4529  24526			04		       .byte.b	<(tiles0+0)
   4530  24527			04		       .byte.b	<(tiles0+0)
   4531  24528			04		       .byte.b	<(tiles0+0)
   4532  24529			04		       .byte.b	<(tiles0+0)
   4533  2452a			04		       .byte.b	<(tiles0+0)
   4534  2452b			04		       .byte.b	<(tiles0+0)
   4535  2452c			04		       .byte.b	<(tiles0+0)
   4536  2452d			04		       .byte.b	<(tiles0+0)
   4537  2452e			04		       .byte.b	<(tiles0+0)
   4538  2452f			04		       .byte.b	<(tiles0+0)
   4539  24530			04		       .byte.b	<(tiles0+0)
   4540  24531			04		       .byte.b	<(tiles0+0)
   4541  24532			04		       .byte.b	<(tiles0+0)
   4542  24533			04		       .byte.b	<(tiles0+0)
   4543  24534			04		       .byte.b	<(tiles0+0)
   4544  24535			04		       .byte.b	<(tiles0+0)
   4545  24536			04		       .byte.b	<(tiles0+0)
   4546  24537			04		       .byte.b	<(tiles0+0)
   4547  24538			04		       .byte.b	<(tiles0+0)
   4548  24539			04		       .byte.b	<(tiles0+0)
   4549  2453a			04		       .byte.b	<(tiles0+0)
   4550  2453b			04		       .byte.b	<(tiles0+0)
   4551  2453c			04		       .byte.b	<(tiles0+0)
   4552  2453d			04		       .byte.b	<(tiles0+0)
   4553  2453e			04		       .byte.b	<(tiles0+0)
   4554  2453f			04		       .byte.b	<(tiles0+0)
   4555  24540			04		       .byte.b	<(tiles0+0)
   4556  24541			04		       .byte.b	<(tiles0+0)
   4557  24542			04		       .byte.b	<(tiles0+0)
   4558  24543			04		       .byte.b	<(tiles0+0)
   4559  24544			04		       .byte.b	<(tiles0+0)
   4560  24545			04		       .byte.b	<(tiles0+0)
   4561  24546			04		       .byte.b	<(tiles0+0)
   4562  24547			04		       .byte.b	<(tiles0+0)
   4563  24548			04		       .byte.b	<(tiles0+0)
   4564  24549			04		       .byte.b	<(tiles0+0)
   4565  2454a			04		       .byte.b	<(tiles0+0)
   4566  2454b			04		       .byte.b	<(tiles0+0)
   4567  2454c			04		       .byte.b	<(tiles0+0)
   4568  2454d			04		       .byte.b	<(tiles0+0)
   4569  2454e			04		       .byte.b	<(tiles0+0)
   4570  2454f			04		       .byte.b	<(tiles0+0)
   4571  24550			04		       .byte.b	<(tiles0+0)
   4572  24551			04		       .byte.b	<(tiles0+0)
   4573  24552			04		       .byte.b	<(tiles0+0)
   4574  24553			04		       .byte.b	<(tiles0+0)
   4575  24554			04		       .byte.b	<(tiles0+0)
   4576  24555			04		       .byte.b	<(tiles0+0)
   4577  24556			04		       .byte.b	<(tiles0+0)
   4578  24557			04		       .byte.b	<(tiles0+0)
   4579  24558			04		       .byte.b	<(tiles0+0)
   4580  24559			04		       .byte.b	<(tiles0+0)
   4581  2455a			04		       .byte.b	<(tiles0+0)
   4582  2455b			04		       .byte.b	<(tiles0+0)
   4583  2455c			04		       .byte.b	<(tiles0+0)
   4584  2455d			04		       .byte.b	<(tiles0+0)
   4585  2455e			04		       .byte.b	<(tiles0+0)
   4586  2455f			04		       .byte.b	<(tiles0+0)
   4587  24560			04		       .byte.b	<(tiles0+0)
   4588  24561			04		       .byte.b	<(tiles0+0)
   4589  24562			04		       .byte.b	<(tiles0+0)
   4590  24563			04		       .byte.b	<(tiles0+0)
   4591  24564			04		       .byte.b	<(tiles0+0)
   4592  24565			04		       .byte.b	<(tiles0+0)
   4593  24566			04		       .byte.b	<(tiles0+0)
   4594  24567			04		       .byte.b	<(tiles0+0)
   4595  24568			04		       .byte.b	<(tiles0+0)
   4596  24569			04		       .byte.b	<(tiles0+0)
   4597  2456a			04		       .byte.b	<(tiles0+0)
   4598  2456b			04		       .byte.b	<(tiles0+0)
   4599  2456c			04		       .byte.b	<(tiles0+0)
   4600  2456d			04		       .byte.b	<(tiles0+0)
   4601  2456e			04		       .byte.b	<(tiles0+0)
   4602  2456f			04		       .byte.b	<(tiles0+0)
   4603  24570			04		       .byte.b	<(tiles0+0)
   4604  24571			04		       .byte.b	<(tiles0+0)
   4605  24572			04		       .byte.b	<(tiles0+0)
   4606  24573			04		       .byte.b	<(tiles0+0)
   4607  24574			04		       .byte.b	<(tiles0+0)
   4608  24575			04		       .byte.b	<(tiles0+0)
   4609  24576			04		       .byte.b	<(tiles0+0)
   4610  24577			04		       .byte.b	<(tiles0+0)
   4611  24578			04		       .byte.b	<(tiles0+0)
   4612  24579			04		       .byte.b	<(tiles0+0)
   4613  2457a			04		       .byte.b	<(tiles0+0)
   4614  2457b			04		       .byte.b	<(tiles0+0)
   4615  2457c			04		       .byte.b	<(tiles0+0)
   4616  2457d			04		       .byte.b	<(tiles0+0)
   4617  2457e			04		       .byte.b	<(tiles0+0)
   4618  2457f			04		       .byte.b	<(tiles0+0)
   4619  24580			04		       .byte.b	<(tiles0+0)
   4620  24581			04		       .byte.b	<(tiles0+0)
   4621  24582			04		       .byte.b	<(tiles0+0)
   4622  24583			04		       .byte.b	<(tiles0+0)
   4623  24584			04		       .byte.b	<(tiles0+0)
   4624  24585			04		       .byte.b	<(tiles0+0)
   4625  24586			04		       .byte.b	<(tiles0+0)
   4626  24587			04		       .byte.b	<(tiles0+0)
   4627  24588			04		       .byte.b	<(tiles0+0)
   4628  24589			04		       .byte.b	<(tiles0+0)
   4629  2458a			04		       .byte.b	<(tiles0+0)
   4630  2458b			04		       .byte.b	<(tiles0+0)
   4631  2458c			04		       .byte.b	<(tiles0+0)
   4632  2458d			04		       .byte.b	<(tiles0+0)
   4633  2458e			04		       .byte.b	<(tiles0+0)
   4634  2458f			04		       .byte.b	<(tiles0+0)
   4635  24590			04		       .byte.b	<(tiles0+0)
   4636  24591			04		       .byte.b	<(tiles0+0)
   4637  24592			04		       .byte.b	<(tiles0+0)
   4638  24593			04		       .byte.b	<(tiles0+0)
   4639  24594			04		       .byte.b	<(tiles0+0)
   4640  24595			04		       .byte.b	<(tiles0+0)
   4641  24596			04		       .byte.b	<(tiles0+0)
   4642  24597			04		       .byte.b	<(tiles0+0)
   4643  24598			04		       .byte.b	<(tiles0+0)
   4644  24599			04		       .byte.b	<(tiles0+0)
   4645  2459a			04		       .byte.b	<(tiles0+0)
   4646  2459b			04		       .byte.b	<(tiles0+0)
   4647  2459c			04		       .byte.b	<(tiles0+0)
   4648  2459d			04		       .byte.b	<(tiles0+0)
   4649  2459e			04		       .byte.b	<(tiles0+0)
   4650  2459f			04		       .byte.b	<(tiles0+0)
   4651  245a0			04		       .byte.b	<(tiles0+0)
   4652  245a1			04		       .byte.b	<(tiles0+0)
   4653  245a2			04		       .byte.b	<(tiles0+0)
   4654  245a3			04		       .byte.b	<(tiles0+0)
   4655  245a4			04		       .byte.b	<(tiles0+0)
   4656  245a5			04		       .byte.b	<(tiles0+0)
   4657  245a6			04		       .byte.b	<(tiles0+0)
   4658  245a7			04		       .byte.b	<(tiles0+0)
   4659  245a8			04		       .byte.b	<(tiles0+0)
   4660  245a9			04		       .byte.b	<(tiles0+0)
   4661  245aa			04		       .byte.b	<(tiles0+0)
   4662  245ab			04		       .byte.b	<(tiles0+0)
   4663  245ac			04		       .byte.b	<(tiles0+0)
   4664  245ad			04		       .byte.b	<(tiles0+0)
   4665  245ae			04		       .byte.b	<(tiles0+0)
   4666  245af			04		       .byte.b	<(tiles0+0)
   4667  245b0			04		       .byte.b	<(tiles0+0)
   4668  245b1			04		       .byte.b	<(tiles0+0)
   4669  245b2			04		       .byte.b	<(tiles0+0)
   4670  245b3			04		       .byte.b	<(tiles0+0)
   4671  245b4			04		       .byte.b	<(tiles0+0)
   4672  245b5			04		       .byte.b	<(tiles0+0)
   4673  245b6			04		       .byte.b	<(tiles0+0)
   4674  245b7			04		       .byte.b	<(tiles0+0)
   4675  245b8			04		       .byte.b	<(tiles0+0)
   4676  245b9			04		       .byte.b	<(tiles0+0)
   4677  245ba			04		       .byte.b	<(tiles0+0)
   4678  245bb			04		       .byte.b	<(tiles0+0)
   4679  245bc			04		       .byte.b	<(tiles0+0)
   4680  245bd			04		       .byte.b	<(tiles0+0)
   4681  245be			04		       .byte.b	<(tiles0+0)
   4682  245bf			04		       .byte.b	<(tiles0+0)
   4683  245c0			04		       .byte.b	<(tiles0+0)
   4684  245c1			04		       .byte.b	<(tiles0+0)
   4685  245c2			04		       .byte.b	<(tiles0+0)
   4686  245c3			04		       .byte.b	<(tiles0+0)
   4687  245c4			04		       .byte.b	<(tiles0+0)
   4688  245c5			04		       .byte.b	<(tiles0+0)
   4689  245c6			04		       .byte.b	<(tiles0+0)
   4690  245c7			04		       .byte.b	<(tiles0+0)
   4691  245c8			04		       .byte.b	<(tiles0+0)
   4692  245c9			04		       .byte.b	<(tiles0+0)
   4693  245ca			04		       .byte.b	<(tiles0+0)
   4694  245cb			04		       .byte.b	<(tiles0+0)
   4695  245cc			04		       .byte.b	<(tiles0+0)
   4696  245cd			04		       .byte.b	<(tiles0+0)
   4697  245ce			04		       .byte.b	<(tiles0+0)
   4698  245cf			04		       .byte.b	<(tiles0+0)
   4699  245d0			04		       .byte.b	<(tiles0+0)
   4700  245d1			04		       .byte.b	<(tiles0+0)
   4701  245d2			04		       .byte.b	<(tiles0+0)
   4702  245d3			04		       .byte.b	<(tiles0+0)
   4703  245d4			04		       .byte.b	<(tiles0+0)
   4704  245d5			04		       .byte.b	<(tiles0+0)
   4705  245d6			04		       .byte.b	<(tiles0+0)
   4706  245d7			04		       .byte.b	<(tiles0+0)
   4707  245d8			04		       .byte.b	<(tiles0+0)
   4708  245d9			04		       .byte.b	<(tiles0+0)
   4709  245da			04		       .byte.b	<(tiles0+0)
   4710  245db			04		       .byte.b	<(tiles0+0)
   4711  245dc			04		       .byte.b	<(tiles0+0)
   4712  245dd			04		       .byte.b	<(tiles0+0)
   4713  245de			04		       .byte.b	<(tiles0+0)
   4714  245df			04		       .byte.b	<(tiles0+0)
   4715  245e0			04		       .byte.b	<(tiles0+0)
   4716  245e1			04		       .byte.b	<(tiles0+0)
   4717  245e2			04		       .byte.b	<(tiles0+0)
   4718  245e3			04		       .byte.b	<(tiles0+0)
   4719  245e4			04		       .byte.b	<(tiles0+0)
   4720  245e5			04		       .byte.b	<(tiles0+0)
   4721  245e6			04		       .byte.b	<(tiles0+0)
   4722  245e7			04		       .byte.b	<(tiles0+0)
   4723  245e8			04		       .byte.b	<(tiles0+0)
   4724  245e9			04		       .byte.b	<(tiles0+0)
   4725  245ea			04		       .byte.b	<(tiles0+0)
   4726  245eb			04		       .byte.b	<(tiles0+0)
   4727  245ec			04		       .byte.b	<(tiles0+0)
   4728  245ed			04		       .byte.b	<(tiles0+0)
   4729  245ee			04		       .byte.b	<(tiles0+0)
   4730  245ef			04		       .byte.b	<(tiles0+0)
   4731  245f0			04		       .byte.b	<(tiles0+0)
   4732  245f1			04		       .byte.b	<(tiles0+0)
   4733  245f2			04		       .byte.b	<(tiles0+0)
   4734  245f3			04		       .byte.b	<(tiles0+0)
   4735  245f4			04		       .byte.b	<(tiles0+0)
   4736  245f5			04		       .byte.b	<(tiles0+0)
   4737  245f6			06		       .byte.b	<(tiles2+0)
   4738  245f7			04		       .byte.b	<(tiles0+0)
   4739  245f8			04		       .byte.b	<(tiles0+0)
   4740  245f9			04		       .byte.b	<(tiles0+0)
   4741  245fa			04		       .byte.b	<(tiles0+0)
   4742  245fb			04		       .byte.b	<(tiles0+0)
   4743  245fc			04		       .byte.b	<(tiles0+0)
   4744  245fd			04		       .byte.b	<(tiles0+0)
   4745  245fe			06		       .byte.b	<(tiles2+0)
   4746  245ff			04		       .byte.b	<(tiles0+0)
   4747  24600			04		       .byte.b	<(tiles0+0)
   4748  24601			04		       .byte.b	<(tiles0+0)
   4749  24602			04		       .byte.b	<(tiles0+0)
   4750  24603			04		       .byte.b	<(tiles0+0)
   4751  24604			04		       .byte.b	<(tiles0+0)
   4752  24605			04		       .byte.b	<(tiles0+0)
   4753  24606			04		       .byte.b	<(tiles0+0)
   4754  24607			04		       .byte.b	<(tiles0+0)
   4755  24608			04		       .byte.b	<(tiles0+0)
   4756  24609			04		       .byte.b	<(tiles0+0)
   4757  2460a			04		       .byte.b	<(tiles0+0)
   4758  2460b			04		       .byte.b	<(tiles0+0)
   4759  2460c			04		       .byte.b	<(tiles0+0)
   4760  2460d			04		       .byte.b	<(tiles0+0)
   4761  2460e			04		       .byte.b	<(tiles0+0)
   4762  2460f			04		       .byte.b	<(tiles0+0)
   4763  24610			04		       .byte.b	<(tiles0+0)
   4764  24611			04		       .byte.b	<(tiles0+0)
   4765  24612			04		       .byte.b	<(tiles0+0)
   4766  24613			04		       .byte.b	<(tiles0+0)
   4767  24614			04		       .byte.b	<(tiles0+0)
   4768  24615			04		       .byte.b	<(tiles0+0)
   4769  24616			04		       .byte.b	<(tiles0+0)
   4770  24617			04		       .byte.b	<(tiles0+0)
   4771  24618			04		       .byte.b	<(tiles0+0)
   4772  24619			04		       .byte.b	<(tiles0+0)
   4773  2461a			04		       .byte.b	<(tiles0+0)
   4774  2461b			04		       .byte.b	<(tiles0+0)
   4775  2461c			04		       .byte.b	<(tiles0+0)
   4776  2461d			04		       .byte.b	<(tiles0+0)
   4777  2461e			04		       .byte.b	<(tiles0+0)
   4778  2461f			04		       .byte.b	<(tiles0+0)
   4779  24620			04		       .byte.b	<(tiles0+0)
   4780  24621			04		       .byte.b	<(tiles0+0)
   4781  24622			04		       .byte.b	<(tiles0+0)
   4782  24623			04		       .byte.b	<(tiles0+0)
   4783  24624			04		       .byte.b	<(tiles0+0)
   4784  24625			04		       .byte.b	<(tiles0+0)
   4785  24626			04		       .byte.b	<(tiles0+0)
   4786  24627			04		       .byte.b	<(tiles0+0)
   4787  24628			04		       .byte.b	<(tiles0+0)
   4788  24629			04		       .byte.b	<(tiles0+0)
   4789  2462a			04		       .byte.b	<(tiles0+0)
   4790  2462b			04		       .byte.b	<(tiles0+0)
   4791  2462c			04		       .byte.b	<(tiles0+0)
   4792  2462d			04		       .byte.b	<(tiles0+0)
   4793  2462e			04		       .byte.b	<(tiles0+0)
   4794  2462f			04		       .byte.b	<(tiles0+0)
   4795  24630			04		       .byte.b	<(tiles0+0)
   4796  24631			04		       .byte.b	<(tiles0+0)
   4797  24632			04		       .byte.b	<(tiles0+0)
   4798  24633			04		       .byte.b	<(tiles0+0)
   4799  24634			04		       .byte.b	<(tiles0+0)
   4800  24635			04		       .byte.b	<(tiles0+0)
   4801  24636			04		       .byte.b	<(tiles0+0)
   4802  24637			04		       .byte.b	<(tiles0+0)
   4803  24638			04		       .byte.b	<(tiles0+0)
   4804  24639			04		       .byte.b	<(tiles0+0)
   4805  2463a			04		       .byte.b	<(tiles0+0)
   4806  2463b			04		       .byte.b	<(tiles0+0)
   4807  2463c			04		       .byte.b	<(tiles0+0)
   4808  2463d			04		       .byte.b	<(tiles0+0)
   4809  2463e			04		       .byte.b	<(tiles0+0)
   4810  2463f			04		       .byte.b	<(tiles0+0)
   4811  24640			04		       .byte.b	<(tiles0+0)
   4812  24641			04		       .byte.b	<(tiles0+0)
   4813  24642			04		       .byte.b	<(tiles0+0)
   4814  24643			04		       .byte.b	<(tiles0+0)
   4815  24644			04		       .byte.b	<(tiles0+0)
   4816  24645			04		       .byte.b	<(tiles0+0)
   4817  24646			04		       .byte.b	<(tiles0+0)
   4818  24647			04		       .byte.b	<(tiles0+0)
   4819  24648			04		       .byte.b	<(tiles0+0)
   4820  24649			04		       .byte.b	<(tiles0+0)
   4821  2464a			04		       .byte.b	<(tiles0+0)
   4822  2464b			04		       .byte.b	<(tiles0+0)
   4823  2464c			04		       .byte.b	<(tiles0+0)
   4824  2464d			04		       .byte.b	<(tiles0+0)
   4825  2464e			04		       .byte.b	<(tiles0+0)
   4826  2464f			04		       .byte.b	<(tiles0+0)
   4827  24650			04		       .byte.b	<(tiles0+0)
   4828  24651			04		       .byte.b	<(tiles0+0)
   4829  24652			04		       .byte.b	<(tiles0+0)
   4830  24653			04		       .byte.b	<(tiles0+0)
   4831  24654			04		       .byte.b	<(tiles0+0)
   4832  24655			04		       .byte.b	<(tiles0+0)
   4833  24656			04		       .byte.b	<(tiles0+0)
   4834  24657			04		       .byte.b	<(tiles0+0)
   4835  24658			04		       .byte.b	<(tiles0+0)
   4836  24659			04		       .byte.b	<(tiles0+0)
   4837  2465a			04		       .byte.b	<(tiles0+0)
   4838  2465b			04		       .byte.b	<(tiles0+0)
   4839  2465c			04		       .byte.b	<(tiles0+0)
   4840  2465d			04		       .byte.b	<(tiles0+0)
   4841  2465e			04		       .byte.b	<(tiles0+0)
   4842  2465f			04		       .byte.b	<(tiles0+0)
   4843  24660			04		       .byte.b	<(tiles0+0)
   4844  24661			04		       .byte.b	<(tiles0+0)
   4845  24662			04		       .byte.b	<(tiles0+0)
   4846  24663			04		       .byte.b	<(tiles0+0)
   4847  24664			04		       .byte.b	<(tiles0+0)
   4848  24665			04		       .byte.b	<(tiles0+0)
   4849  24666			04		       .byte.b	<(tiles0+0)
   4850  24667			04		       .byte.b	<(tiles0+0)
   4851  24668			04		       .byte.b	<(tiles0+0)
   4852  24669			04		       .byte.b	<(tiles0+0)
   4853  2466a			04		       .byte.b	<(tiles0+0)
   4854  2466b			04		       .byte.b	<(tiles0+0)
   4855  2466c			04		       .byte.b	<(tiles0+0)
   4856  2466d			04		       .byte.b	<(tiles0+0)
   4857  2466e			04		       .byte.b	<(tiles0+0)
   4858  2466f			04		       .byte.b	<(tiles0+0)
   4859  24670			04		       .byte.b	<(tiles0+0)
   4860  24671			04		       .byte.b	<(tiles0+0)
   4861  24672			04		       .byte.b	<(tiles0+0)
   4862  24673			04		       .byte.b	<(tiles0+0)
   4863  24674			04		       .byte.b	<(tiles0+0)
   4864  24675			04		       .byte.b	<(tiles0+0)
   4865  24676			04		       .byte.b	<(tiles0+0)
   4866  24677			04		       .byte.b	<(tiles0+0)
   4867  24678			04		       .byte.b	<(tiles0+0)
   4868  24679			04		       .byte.b	<(tiles0+0)
   4869  2467a			04		       .byte.b	<(tiles0+0)
   4870  2467b			04		       .byte.b	<(tiles0+0)
   4871  2467c			04		       .byte.b	<(tiles0+0)
   4872  2467d			04		       .byte.b	<(tiles0+0)
   4873  2467e			04		       .byte.b	<(tiles0+0)
   4874  2467f			04		       .byte.b	<(tiles0+0)
   4875  24680			04		       .byte.b	<(tiles0+0)
   4876  24681			04		       .byte.b	<(tiles0+0)
   4877  24682			04		       .byte.b	<(tiles0+0)
   4878  24683			04		       .byte.b	<(tiles0+0)
   4879  24684			04		       .byte.b	<(tiles0+0)
   4880  24685			04		       .byte.b	<(tiles0+0)
   4881  24686			04		       .byte.b	<(tiles0+0)
   4882  24687			04		       .byte.b	<(tiles0+0)
   4883  24688			04		       .byte.b	<(tiles0+0)
   4884  24689			04		       .byte.b	<(tiles0+0)
   4885  2468a			04		       .byte.b	<(tiles0+0)
   4886  2468b			04		       .byte.b	<(tiles0+0)
   4887  2468c			04		       .byte.b	<(tiles0+0)
   4888  2468d			04		       .byte.b	<(tiles0+0)
   4889  2468e			04		       .byte.b	<(tiles0+0)
   4890  2468f			04		       .byte.b	<(tiles0+0)
   4891  24690			04		       .byte.b	<(tiles0+0)
   4892  24691			04		       .byte.b	<(tiles0+0)
   4893  24692			04		       .byte.b	<(tiles0+0)
   4894  24693			04		       .byte.b	<(tiles0+0)
   4895  24694			04		       .byte.b	<(tiles0+0)
   4896  24695			04		       .byte.b	<(tiles0+0)
   4897  24696			04		       .byte.b	<(tiles0+0)
   4898  24697			04		       .byte.b	<(tiles0+0)
   4899  24698			04		       .byte.b	<(tiles0+0)
   4900  24699			04		       .byte.b	<(tiles0+0)
   4901  2469a			04		       .byte.b	<(tiles0+0)
   4902  2469b			04		       .byte.b	<(tiles0+0)
   4903  2469c			04		       .byte.b	<(tiles0+0)
   4904  2469d			04		       .byte.b	<(tiles0+0)
   4905  2469e			04		       .byte.b	<(tiles0+0)
   4906  2469f			04		       .byte.b	<(tiles0+0)
   4907  246a0			04		       .byte.b	<(tiles0+0)
   4908  246a1			04		       .byte.b	<(tiles0+0)
   4909  246a2			04		       .byte.b	<(tiles0+0)
   4910  246a3			04		       .byte.b	<(tiles0+0)
   4911  246a4			04		       .byte.b	<(tiles0+0)
   4912  246a5			04		       .byte.b	<(tiles0+0)
   4913  246a6			04		       .byte.b	<(tiles0+0)
   4914  246a7			04		       .byte.b	<(tiles0+0)
   4915  246a8			04		       .byte.b	<(tiles0+0)
   4916  246a9			04		       .byte.b	<(tiles0+0)
   4917  246aa			04		       .byte.b	<(tiles0+0)
   4918  246ab			04		       .byte.b	<(tiles0+0)
   4919  246ac			04		       .byte.b	<(tiles0+0)
   4920  246ad			04		       .byte.b	<(tiles0+0)
   4921  246ae			04		       .byte.b	<(tiles0+0)
   4922  246af			04		       .byte.b	<(tiles0+0)
   4923  246b0			04		       .byte.b	<(tiles0+0)
   4924  246b1			04		       .byte.b	<(tiles0+0)
   4925  246b2			04		       .byte.b	<(tiles0+0)
   4926  246b3			04		       .byte.b	<(tiles0+0)
   4927  246b4			04		       .byte.b	<(tiles0+0)
   4928  246b5			04		       .byte.b	<(tiles0+0)
   4929  246b6			04		       .byte.b	<(tiles0+0)
   4930  246b7			04		       .byte.b	<(tiles0+0)
   4931  246b8			04		       .byte.b	<(tiles0+0)
   4932  246b9			04		       .byte.b	<(tiles0+0)
   4933  246ba			04		       .byte.b	<(tiles0+0)
   4934  246bb			04		       .byte.b	<(tiles0+0)
   4935  246bc			04		       .byte.b	<(tiles0+0)
   4936  246bd			04		       .byte.b	<(tiles0+0)
   4937  246be			04		       .byte.b	<(tiles0+0)
   4938  246bf			04		       .byte.b	<(tiles0+0)
   4939  246c0			04		       .byte.b	<(tiles0+0)
   4940  246c1			04		       .byte.b	<(tiles0+0)
   4941  246c2			04		       .byte.b	<(tiles0+0)
   4942  246c3			04		       .byte.b	<(tiles0+0)
   4943  246c4			04		       .byte.b	<(tiles0+0)
   4944  246c5			04		       .byte.b	<(tiles0+0)
   4945  246c6			04		       .byte.b	<(tiles0+0)
   4946  246c7			04		       .byte.b	<(tiles0+0)
   4947  246c8			04		       .byte.b	<(tiles0+0)
   4948  246c9			04		       .byte.b	<(tiles0+0)
   4949  246ca			04		       .byte.b	<(tiles0+0)
   4950  246cb			04		       .byte.b	<(tiles0+0)
   4951  246cc			04		       .byte.b	<(tiles0+0)
   4952  246cd			04		       .byte.b	<(tiles0+0)
   4953  246ce			04		       .byte.b	<(tiles0+0)
   4954  246cf			04		       .byte.b	<(tiles0+0)
   4955  246d0			04		       .byte.b	<(tiles0+0)
   4956  246d1			04		       .byte.b	<(tiles0+0)
   4957  246d2			04		       .byte.b	<(tiles0+0)
   4958  246d3			04		       .byte.b	<(tiles0+0)
   4959  246d4			04		       .byte.b	<(tiles0+0)
   4960  246d5			04		       .byte.b	<(tiles0+0)
   4961  246d6			04		       .byte.b	<(tiles0+0)
   4962  246d7			04		       .byte.b	<(tiles0+0)
   4963  246d8			04		       .byte.b	<(tiles0+0)
   4964  246d9			04		       .byte.b	<(tiles0+0)
   4965  246da			04		       .byte.b	<(tiles0+0)
   4966  246db			04		       .byte.b	<(tiles0+0)
   4967  246dc			04		       .byte.b	<(tiles0+0)
   4968  246dd			04		       .byte.b	<(tiles0+0)
   4969  246de			04		       .byte.b	<(tiles0+0)
   4970  246df			04		       .byte.b	<(tiles0+0)
   4971  246e0			04		       .byte.b	<(tiles0+0)
   4972  246e1			04		       .byte.b	<(tiles0+0)
   4973  246e2			04		       .byte.b	<(tiles0+0)
   4974  246e3			04		       .byte.b	<(tiles0+0)
   4975  246e4			04		       .byte.b	<(tiles0+0)
   4976  246e5			04		       .byte.b	<(tiles0+0)
   4977  246e6			04		       .byte.b	<(tiles0+0)
   4978  246e7			04		       .byte.b	<(tiles0+0)
   4979  246e8			04		       .byte.b	<(tiles0+0)
   4980  246e9			04		       .byte.b	<(tiles0+0)
   4981  246ea			04		       .byte.b	<(tiles0+0)
   4982  246eb			04		       .byte.b	<(tiles0+0)
   4983  246ec			04		       .byte.b	<(tiles0+0)
   4984  246ed			04		       .byte.b	<(tiles0+0)
   4985  246ee			04		       .byte.b	<(tiles0+0)
   4986  246ef			04		       .byte.b	<(tiles0+0)
   4987  246f0			04		       .byte.b	<(tiles0+0)
   4988  246f1			04		       .byte.b	<(tiles0+0)
   4989  246f2			04		       .byte.b	<(tiles0+0)
   4990  246f3			04		       .byte.b	<(tiles0+0)
   4991  246f4			04		       .byte.b	<(tiles0+0)
   4992  246f5			06		       .byte.b	<(tiles2+0)
   4993  246f6			04		       .byte.b	<(tiles0+0)
   4994  246f7			04		       .byte.b	<(tiles0+0)
   4995  246f8			04		       .byte.b	<(tiles0+0)
   4996  246f9			04		       .byte.b	<(tiles0+0)
   4997  246fa			04		       .byte.b	<(tiles0+0)
   4998  246fb			04		       .byte.b	<(tiles0+0)
   4999  246fc			04		       .byte.b	<(tiles0+0)
   5000  246fd			06		       .byte.b	<(tiles2+0)
   5001  246fe			04		       .byte.b	<(tiles0+0)
   5002  246ff			04		       .byte.b	<(tiles0+0)
   5003  24700			04		       .byte.b	<(tiles0+0)
   5004  24701			04		       .byte.b	<(tiles0+0)
   5005  24702			04		       .byte.b	<(tiles0+0)
   5006  24703			04		       .byte.b	<(tiles0+0)
   5007  24704			04		       .byte.b	<(tiles0+0)
   5008  24705			04		       .byte.b	<(tiles0+0)
   5009  24706			04		       .byte.b	<(tiles0+0)
   5010  24707			04		       .byte.b	<(tiles0+0)
   5011  24708			04		       .byte.b	<(tiles0+0)
   5012  24709			04		       .byte.b	<(tiles0+0)
   5013  2470a			04		       .byte.b	<(tiles0+0)
   5014  2470b			04		       .byte.b	<(tiles0+0)
   5015  2470c			04		       .byte.b	<(tiles0+0)
   5016  2470d			04		       .byte.b	<(tiles0+0)
   5017  2470e			04		       .byte.b	<(tiles0+0)
   5018  2470f			04		       .byte.b	<(tiles0+0)
   5019  24710			04		       .byte.b	<(tiles0+0)
   5020  24711			04		       .byte.b	<(tiles0+0)
   5021  24712			04		       .byte.b	<(tiles0+0)
   5022  24713			04		       .byte.b	<(tiles0+0)
   5023  24714			04		       .byte.b	<(tiles0+0)
   5024  24715			04		       .byte.b	<(tiles0+0)
   5025  24716			04		       .byte.b	<(tiles0+0)
   5026  24717			04		       .byte.b	<(tiles0+0)
   5027  24718			04		       .byte.b	<(tiles0+0)
   5028  24719			04		       .byte.b	<(tiles0+0)
   5029  2471a			04		       .byte.b	<(tiles0+0)
   5030  2471b			04		       .byte.b	<(tiles0+0)
   5031  2471c			04		       .byte.b	<(tiles0+0)
   5032  2471d			04		       .byte.b	<(tiles0+0)
   5033  2471e			04		       .byte.b	<(tiles0+0)
   5034  2471f			04		       .byte.b	<(tiles0+0)
   5035  24720			04		       .byte.b	<(tiles0+0)
   5036  24721			04		       .byte.b	<(tiles0+0)
   5037  24722			04		       .byte.b	<(tiles0+0)
   5038  24723			06		       .byte.b	<(tiles2+0)
   5039  24724			04		       .byte.b	<(tiles0+0)
   5040  24725			04		       .byte.b	<(tiles0+0)
   5041  24726			04		       .byte.b	<(tiles0+0)
   5042  24727			04		       .byte.b	<(tiles0+0)
   5043  24728			04		       .byte.b	<(tiles0+0)
   5044  24729			04		       .byte.b	<(tiles0+0)
   5045  2472a			04		       .byte.b	<(tiles0+0)
   5046  2472b			04		       .byte.b	<(tiles0+0)
   5047  2472c			04		       .byte.b	<(tiles0+0)
   5048  2472d			04		       .byte.b	<(tiles0+0)
   5049  2472e			04		       .byte.b	<(tiles0+0)
   5050  2472f			04		       .byte.b	<(tiles0+0)
   5051  24730			04		       .byte.b	<(tiles0+0)
   5052  24731			04		       .byte.b	<(tiles0+0)
   5053  24732			04		       .byte.b	<(tiles0+0)
   5054  24733			04		       .byte.b	<(tiles0+0)
   5055  24734			04		       .byte.b	<(tiles0+0)
   5056  24735			04		       .byte.b	<(tiles0+0)
   5057  24736			04		       .byte.b	<(tiles0+0)
   5058  24737			04		       .byte.b	<(tiles0+0)
   5059  24738			04		       .byte.b	<(tiles0+0)
   5060  24739			04		       .byte.b	<(tiles0+0)
   5061  2473a			04		       .byte.b	<(tiles0+0)
   5062  2473b			04		       .byte.b	<(tiles0+0)
   5063  2473c			04		       .byte.b	<(tiles0+0)
   5064  2473d			04		       .byte.b	<(tiles0+0)
   5065  2473e			04		       .byte.b	<(tiles0+0)
   5066  2473f			04		       .byte.b	<(tiles0+0)
   5067  24740			04		       .byte.b	<(tiles0+0)
   5068  24741			04		       .byte.b	<(tiles0+0)
   5069  24742			04		       .byte.b	<(tiles0+0)
   5070  24743			04		       .byte.b	<(tiles0+0)
   5071  24744			04		       .byte.b	<(tiles0+0)
   5072  24745			04		       .byte.b	<(tiles0+0)
   5073  24746			04		       .byte.b	<(tiles0+0)
   5074  24747			04		       .byte.b	<(tiles0+0)
   5075  24748			04		       .byte.b	<(tiles0+0)
   5076  24749			04		       .byte.b	<(tiles0+0)
   5077  2474a			04		       .byte.b	<(tiles0+0)
   5078  2474b			04		       .byte.b	<(tiles0+0)
   5079  2474c			04		       .byte.b	<(tiles0+0)
   5080  2474d			04		       .byte.b	<(tiles0+0)
   5081  2474e			04		       .byte.b	<(tiles0+0)
   5082  2474f			04		       .byte.b	<(tiles0+0)
   5083  24750			04		       .byte.b	<(tiles0+0)
   5084  24751			04		       .byte.b	<(tiles0+0)
   5085  24752			04		       .byte.b	<(tiles0+0)
   5086  24753			04		       .byte.b	<(tiles0+0)
   5087  24754			04		       .byte.b	<(tiles0+0)
   5088  24755			04		       .byte.b	<(tiles0+0)
   5089  24756			04		       .byte.b	<(tiles0+0)
   5090  24757			04		       .byte.b	<(tiles0+0)
   5091  24758			04		       .byte.b	<(tiles0+0)
   5092  24759			04		       .byte.b	<(tiles0+0)
   5093  2475a			04		       .byte.b	<(tiles0+0)
   5094  2475b			04		       .byte.b	<(tiles0+0)
   5095  2475c			04		       .byte.b	<(tiles0+0)
   5096  2475d			04		       .byte.b	<(tiles0+0)
   5097  2475e			04		       .byte.b	<(tiles0+0)
   5098  2475f			04		       .byte.b	<(tiles0+0)
   5099  24760			04		       .byte.b	<(tiles0+0)
   5100  24761			04		       .byte.b	<(tiles0+0)
   5101  24762			04		       .byte.b	<(tiles0+0)
   5102  24763			04		       .byte.b	<(tiles0+0)
   5103  24764			04		       .byte.b	<(tiles0+0)
   5104  24765			04		       .byte.b	<(tiles0+0)
   5105  24766			04		       .byte.b	<(tiles0+0)
   5106  24767			04		       .byte.b	<(tiles0+0)
   5107  24768			04		       .byte.b	<(tiles0+0)
   5108  24769			04		       .byte.b	<(tiles0+0)
   5109  2476a			04		       .byte.b	<(tiles0+0)
   5110  2476b			04		       .byte.b	<(tiles0+0)
   5111  2476c			04		       .byte.b	<(tiles0+0)
   5112  2476d			04		       .byte.b	<(tiles0+0)
   5113  2476e			04		       .byte.b	<(tiles0+0)
   5114  2476f			04		       .byte.b	<(tiles0+0)
   5115  24770			04		       .byte.b	<(tiles0+0)
   5116  24771			04		       .byte.b	<(tiles0+0)
   5117  24772			04		       .byte.b	<(tiles0+0)
   5118  24773			04		       .byte.b	<(tiles0+0)
   5119  24774			04		       .byte.b	<(tiles0+0)
   5120  24775			04		       .byte.b	<(tiles0+0)
   5121  24776			04		       .byte.b	<(tiles0+0)
   5122  24777			04		       .byte.b	<(tiles0+0)
   5123  24778			04		       .byte.b	<(tiles0+0)
   5124  24779			04		       .byte.b	<(tiles0+0)
   5125  2477a			04		       .byte.b	<(tiles0+0)
   5126  2477b			04		       .byte.b	<(tiles0+0)
   5127  2477c			04		       .byte.b	<(tiles0+0)
   5128  2477d			04		       .byte.b	<(tiles0+0)
   5129  2477e			04		       .byte.b	<(tiles0+0)
   5130  2477f			04		       .byte.b	<(tiles0+0)
   5131  24780			04		       .byte.b	<(tiles0+0)
   5132  24781			04		       .byte.b	<(tiles0+0)
   5133  24782			04		       .byte.b	<(tiles0+0)
   5134  24783			04		       .byte.b	<(tiles0+0)
   5135  24784			04		       .byte.b	<(tiles0+0)
   5136  24785			04		       .byte.b	<(tiles0+0)
   5137  24786			04		       .byte.b	<(tiles0+0)
   5138  24787			04		       .byte.b	<(tiles0+0)
   5139  24788			04		       .byte.b	<(tiles0+0)
   5140  24789			04		       .byte.b	<(tiles0+0)
   5141  2478a			04		       .byte.b	<(tiles0+0)
   5142  2478b			04		       .byte.b	<(tiles0+0)
   5143  2478c			04		       .byte.b	<(tiles0+0)
   5144  2478d			04		       .byte.b	<(tiles0+0)
   5145  2478e			04		       .byte.b	<(tiles0+0)
   5146  2478f			04		       .byte.b	<(tiles0+0)
   5147  24790			04		       .byte.b	<(tiles0+0)
   5148  24791			04		       .byte.b	<(tiles0+0)
   5149  24792			04		       .byte.b	<(tiles0+0)
   5150  24793			04		       .byte.b	<(tiles0+0)
   5151  24794			04		       .byte.b	<(tiles0+0)
   5152  24795			04		       .byte.b	<(tiles0+0)
   5153  24796			04		       .byte.b	<(tiles0+0)
   5154  24797			04		       .byte.b	<(tiles0+0)
   5155  24798			04		       .byte.b	<(tiles0+0)
   5156  24799			04		       .byte.b	<(tiles0+0)
   5157  2479a			04		       .byte.b	<(tiles0+0)
   5158  2479b			04		       .byte.b	<(tiles0+0)
   5159  2479c			04		       .byte.b	<(tiles0+0)
   5160  2479d			04		       .byte.b	<(tiles0+0)
   5161  2479e			04		       .byte.b	<(tiles0+0)
   5162  2479f			04		       .byte.b	<(tiles0+0)
   5163  247a0			04		       .byte.b	<(tiles0+0)
   5164  247a1			04		       .byte.b	<(tiles0+0)
   5165  247a2			04		       .byte.b	<(tiles0+0)
   5166  247a3			04		       .byte.b	<(tiles0+0)
   5167  247a4			04		       .byte.b	<(tiles0+0)
   5168  247a5			04		       .byte.b	<(tiles0+0)
   5169  247a6			04		       .byte.b	<(tiles0+0)
   5170  247a7			04		       .byte.b	<(tiles0+0)
   5171  247a8			04		       .byte.b	<(tiles0+0)
   5172  247a9			04		       .byte.b	<(tiles0+0)
   5173  247aa			04		       .byte.b	<(tiles0+0)
   5174  247ab			04		       .byte.b	<(tiles0+0)
   5175  247ac			04		       .byte.b	<(tiles0+0)
   5176  247ad			04		       .byte.b	<(tiles0+0)
   5177  247ae			04		       .byte.b	<(tiles0+0)
   5178  247af			04		       .byte.b	<(tiles0+0)
   5179  247b0			04		       .byte.b	<(tiles0+0)
   5180  247b1			04		       .byte.b	<(tiles0+0)
   5181  247b2			04		       .byte.b	<(tiles0+0)
   5182  247b3			04		       .byte.b	<(tiles0+0)
   5183  247b4			04		       .byte.b	<(tiles0+0)
   5184  247b5			04		       .byte.b	<(tiles0+0)
   5185  247b6			04		       .byte.b	<(tiles0+0)
   5186  247b7			04		       .byte.b	<(tiles0+0)
   5187  247b8			04		       .byte.b	<(tiles0+0)
   5188  247b9			04		       .byte.b	<(tiles0+0)
   5189  247ba			04		       .byte.b	<(tiles0+0)
   5190  247bb			04		       .byte.b	<(tiles0+0)
   5191  247bc			04		       .byte.b	<(tiles0+0)
   5192  247bd			04		       .byte.b	<(tiles0+0)
   5193  247be			04		       .byte.b	<(tiles0+0)
   5194  247bf			04		       .byte.b	<(tiles0+0)
   5195  247c0			04		       .byte.b	<(tiles0+0)
   5196  247c1			04		       .byte.b	<(tiles0+0)
   5197  247c2			04		       .byte.b	<(tiles0+0)
   5198  247c3			04		       .byte.b	<(tiles0+0)
   5199  247c4			04		       .byte.b	<(tiles0+0)
   5200  247c5			04		       .byte.b	<(tiles0+0)
   5201  247c6			04		       .byte.b	<(tiles0+0)
   5202  247c7			04		       .byte.b	<(tiles0+0)
   5203  247c8			04		       .byte.b	<(tiles0+0)
   5204  247c9			04		       .byte.b	<(tiles0+0)
   5205  247ca			04		       .byte.b	<(tiles0+0)
   5206  247cb			04		       .byte.b	<(tiles0+0)
   5207  247cc			04		       .byte.b	<(tiles0+0)
   5208  247cd			04		       .byte.b	<(tiles0+0)
   5209  247ce			04		       .byte.b	<(tiles0+0)
   5210  247cf			04		       .byte.b	<(tiles0+0)
   5211  247d0			04		       .byte.b	<(tiles0+0)
   5212  247d1			04		       .byte.b	<(tiles0+0)
   5213  247d2			04		       .byte.b	<(tiles0+0)
   5214  247d3			04		       .byte.b	<(tiles0+0)
   5215  247d4			04		       .byte.b	<(tiles0+0)
   5216  247d5			04		       .byte.b	<(tiles0+0)
   5217  247d6			04		       .byte.b	<(tiles0+0)
   5218  247d7			04		       .byte.b	<(tiles0+0)
   5219  247d8			04		       .byte.b	<(tiles0+0)
   5220  247d9			04		       .byte.b	<(tiles0+0)
   5221  247da			04		       .byte.b	<(tiles0+0)
   5222  247db			04		       .byte.b	<(tiles0+0)
   5223  247dc			04		       .byte.b	<(tiles0+0)
   5224  247dd			04		       .byte.b	<(tiles0+0)
   5225  247de			04		       .byte.b	<(tiles0+0)
   5226  247df			04		       .byte.b	<(tiles0+0)
   5227  247e0			04		       .byte.b	<(tiles0+0)
   5228  247e1			04		       .byte.b	<(tiles0+0)
   5229  247e2			04		       .byte.b	<(tiles0+0)
   5230  247e3			04		       .byte.b	<(tiles0+0)
   5231  247e4			04		       .byte.b	<(tiles0+0)
   5232  247e5			04		       .byte.b	<(tiles0+0)
   5233  247e6			04		       .byte.b	<(tiles0+0)
   5234  247e7			04		       .byte.b	<(tiles0+0)
   5235  247e8			04		       .byte.b	<(tiles0+0)
   5236  247e9			04		       .byte.b	<(tiles0+0)
   5237  247ea			04		       .byte.b	<(tiles0+0)
   5238  247eb			04		       .byte.b	<(tiles0+0)
   5239  247ec			04		       .byte.b	<(tiles0+0)
   5240  247ed			04		       .byte.b	<(tiles0+0)
   5241  247ee			04		       .byte.b	<(tiles0+0)
   5242  247ef			04		       .byte.b	<(tiles0+0)
   5243  247f0			04		       .byte.b	<(tiles0+0)
   5244  247f1			04		       .byte.b	<(tiles0+0)
   5245  247f2			04		       .byte.b	<(tiles0+0)
   5246  247f3			04		       .byte.b	<(tiles0+0)
   5247  247f4			06		       .byte.b	<(tiles2+0)
   5248  247f5			04		       .byte.b	<(tiles0+0)
   5249  247f6			04		       .byte.b	<(tiles0+0)
   5250  247f7			04		       .byte.b	<(tiles0+0)
   5251  247f8			04		       .byte.b	<(tiles0+0)
   5252  247f9			04		       .byte.b	<(tiles0+0)
   5253  247fa			04		       .byte.b	<(tiles0+0)
   5254  247fb			04		       .byte.b	<(tiles0+0)
   5255  247fc			06		       .byte.b	<(tiles2+0)
   5256  247fd			04		       .byte.b	<(tiles0+0)
   5257  247fe			04		       .byte.b	<(tiles0+0)
   5258  247ff			04		       .byte.b	<(tiles0+0)
   5259  24800			04		       .byte.b	<(tiles0+0)
   5260  24801			04		       .byte.b	<(tiles0+0)
   5261  24802			04		       .byte.b	<(tiles0+0)
   5262  24803			04		       .byte.b	<(tiles0+0)
   5263  24804			04		       .byte.b	<(tiles0+0)
   5264  24805			04		       .byte.b	<(tiles0+0)
   5265  24806			04		       .byte.b	<(tiles0+0)
   5266  24807			04		       .byte.b	<(tiles0+0)
   5267  24808			04		       .byte.b	<(tiles0+0)
   5268  24809			04		       .byte.b	<(tiles0+0)
   5269  2480a			04		       .byte.b	<(tiles0+0)
   5270  2480b			04		       .byte.b	<(tiles0+0)
   5271  2480c			04		       .byte.b	<(tiles0+0)
   5272  2480d			04		       .byte.b	<(tiles0+0)
   5273  2480e			04		       .byte.b	<(tiles0+0)
   5274  2480f			04		       .byte.b	<(tiles0+0)
   5275  24810			04		       .byte.b	<(tiles0+0)
   5276  24811			04		       .byte.b	<(tiles0+0)
   5277  24812			04		       .byte.b	<(tiles0+0)
   5278  24813			04		       .byte.b	<(tiles0+0)
   5279  24814			04		       .byte.b	<(tiles0+0)
   5280  24815			04		       .byte.b	<(tiles0+0)
   5281  24816			04		       .byte.b	<(tiles0+0)
   5282  24817			04		       .byte.b	<(tiles0+0)
   5283  24818			04		       .byte.b	<(tiles0+0)
   5284  24819			04		       .byte.b	<(tiles0+0)
   5285  2481a			04		       .byte.b	<(tiles0+0)
   5286  2481b			04		       .byte.b	<(tiles0+0)
   5287  2481c			04		       .byte.b	<(tiles0+0)
   5288  2481d			04		       .byte.b	<(tiles0+0)
   5289  2481e			04		       .byte.b	<(tiles0+0)
   5290  2481f			04		       .byte.b	<(tiles0+0)
   5291  24820			04		       .byte.b	<(tiles0+0)
   5292  24821			04		       .byte.b	<(tiles0+0)
   5293  24822			06		       .byte.b	<(tiles2+0)
   5294  24823			04		       .byte.b	<(tiles0+0)
   5295  24824			04		       .byte.b	<(tiles0+0)
   5296  24825			04		       .byte.b	<(tiles0+0)
   5297  24826			04		       .byte.b	<(tiles0+0)
   5298  24827			04		       .byte.b	<(tiles0+0)
   5299  24828			04		       .byte.b	<(tiles0+0)
   5300  24829			04		       .byte.b	<(tiles0+0)
   5301  2482a			04		       .byte.b	<(tiles0+0)
   5302  2482b			04		       .byte.b	<(tiles0+0)
   5303  2482c			04		       .byte.b	<(tiles0+0)
   5304  2482d			04		       .byte.b	<(tiles0+0)
   5305  2482e			04		       .byte.b	<(tiles0+0)
   5306  2482f			04		       .byte.b	<(tiles0+0)
   5307  24830			04		       .byte.b	<(tiles0+0)
   5308  24831			04		       .byte.b	<(tiles0+0)
   5309  24832			04		       .byte.b	<(tiles0+0)
   5310  24833			04		       .byte.b	<(tiles0+0)
   5311  24834			04		       .byte.b	<(tiles0+0)
   5312  24835			04		       .byte.b	<(tiles0+0)
   5313  24836			04		       .byte.b	<(tiles0+0)
   5314  24837			04		       .byte.b	<(tiles0+0)
   5315  24838			04		       .byte.b	<(tiles0+0)
   5316  24839			04		       .byte.b	<(tiles0+0)
   5317  2483a			04		       .byte.b	<(tiles0+0)
   5318  2483b			04		       .byte.b	<(tiles0+0)
   5319  2483c			04		       .byte.b	<(tiles0+0)
   5320  2483d			04		       .byte.b	<(tiles0+0)
   5321  2483e			04		       .byte.b	<(tiles0+0)
   5322  2483f			04		       .byte.b	<(tiles0+0)
   5323  24840			04		       .byte.b	<(tiles0+0)
   5324  24841			04		       .byte.b	<(tiles0+0)
   5325  24842			04		       .byte.b	<(tiles0+0)
   5326  24843			04		       .byte.b	<(tiles0+0)
   5327  24844			04		       .byte.b	<(tiles0+0)
   5328  24845			04		       .byte.b	<(tiles0+0)
   5329  24846			04		       .byte.b	<(tiles0+0)
   5330  24847			04		       .byte.b	<(tiles0+0)
   5331  24848			04		       .byte.b	<(tiles0+0)
   5332  24849			04		       .byte.b	<(tiles0+0)
   5333  2484a			04		       .byte.b	<(tiles0+0)
   5334  2484b			04		       .byte.b	<(tiles0+0)
   5335  2484c			04		       .byte.b	<(tiles0+0)
   5336  2484d			04		       .byte.b	<(tiles0+0)
   5337  2484e			04		       .byte.b	<(tiles0+0)
   5338  2484f			04		       .byte.b	<(tiles0+0)
   5339  24850			04		       .byte.b	<(tiles0+0)
   5340  24851			04		       .byte.b	<(tiles0+0)
   5341  24852			04		       .byte.b	<(tiles0+0)
   5342  24853			04		       .byte.b	<(tiles0+0)
   5343  24854			04		       .byte.b	<(tiles0+0)
   5344  24855			04		       .byte.b	<(tiles0+0)
   5345  24856			04		       .byte.b	<(tiles0+0)
   5346  24857			04		       .byte.b	<(tiles0+0)
   5347  24858			04		       .byte.b	<(tiles0+0)
   5348  24859			04		       .byte.b	<(tiles0+0)
   5349  2485a			04		       .byte.b	<(tiles0+0)
   5350  2485b			04		       .byte.b	<(tiles0+0)
   5351  2485c			04		       .byte.b	<(tiles0+0)
   5352  2485d			04		       .byte.b	<(tiles0+0)
   5353  2485e			04		       .byte.b	<(tiles0+0)
   5354  2485f			04		       .byte.b	<(tiles0+0)
   5355  24860			04		       .byte.b	<(tiles0+0)
   5356  24861			04		       .byte.b	<(tiles0+0)
   5357  24862			04		       .byte.b	<(tiles0+0)
   5358  24863			04		       .byte.b	<(tiles0+0)
   5359  24864			04		       .byte.b	<(tiles0+0)
   5360  24865			04		       .byte.b	<(tiles0+0)
   5361  24866			04		       .byte.b	<(tiles0+0)
   5362  24867			04		       .byte.b	<(tiles0+0)
   5363  24868			04		       .byte.b	<(tiles0+0)
   5364  24869			04		       .byte.b	<(tiles0+0)
   5365  2486a			04		       .byte.b	<(tiles0+0)
   5366  2486b			04		       .byte.b	<(tiles0+0)
   5367  2486c			04		       .byte.b	<(tiles0+0)
   5368  2486d			04		       .byte.b	<(tiles0+0)
   5369  2486e			04		       .byte.b	<(tiles0+0)
   5370  2486f			04		       .byte.b	<(tiles0+0)
   5371  24870			04		       .byte.b	<(tiles0+0)
   5372  24871			04		       .byte.b	<(tiles0+0)
   5373  24872			04		       .byte.b	<(tiles0+0)
   5374  24873			04		       .byte.b	<(tiles0+0)
   5375  24874			04		       .byte.b	<(tiles0+0)
   5376  24875			04		       .byte.b	<(tiles0+0)
   5377  24876			04		       .byte.b	<(tiles0+0)
   5378  24877			04		       .byte.b	<(tiles0+0)
   5379  24878			04		       .byte.b	<(tiles0+0)
   5380  24879			04		       .byte.b	<(tiles0+0)
   5381  2487a			04		       .byte.b	<(tiles0+0)
   5382  2487b			04		       .byte.b	<(tiles0+0)
   5383  2487c			04		       .byte.b	<(tiles0+0)
   5384  2487d			04		       .byte.b	<(tiles0+0)
   5385  2487e			04		       .byte.b	<(tiles0+0)
   5386  2487f			04		       .byte.b	<(tiles0+0)
   5387  24880			04		       .byte.b	<(tiles0+0)
   5388  24881			04		       .byte.b	<(tiles0+0)
   5389  24882			04		       .byte.b	<(tiles0+0)
   5390  24883			04		       .byte.b	<(tiles0+0)
   5391  24884			04		       .byte.b	<(tiles0+0)
   5392  24885			04		       .byte.b	<(tiles0+0)
   5393  24886			04		       .byte.b	<(tiles0+0)
   5394  24887			04		       .byte.b	<(tiles0+0)
   5395  24888			04		       .byte.b	<(tiles0+0)
   5396  24889			04		       .byte.b	<(tiles0+0)
   5397  2488a			04		       .byte.b	<(tiles0+0)
   5398  2488b			04		       .byte.b	<(tiles0+0)
   5399  2488c			04		       .byte.b	<(tiles0+0)
   5400  2488d			04		       .byte.b	<(tiles0+0)
   5401  2488e			04		       .byte.b	<(tiles0+0)
   5402  2488f			04		       .byte.b	<(tiles0+0)
   5403  24890			04		       .byte.b	<(tiles0+0)
   5404  24891			04		       .byte.b	<(tiles0+0)
   5405  24892			04		       .byte.b	<(tiles0+0)
   5406  24893			04		       .byte.b	<(tiles0+0)
   5407  24894			04		       .byte.b	<(tiles0+0)
   5408  24895			04		       .byte.b	<(tiles0+0)
   5409  24896			04		       .byte.b	<(tiles0+0)
   5410  24897			04		       .byte.b	<(tiles0+0)
   5411  24898			04		       .byte.b	<(tiles0+0)
   5412  24899			04		       .byte.b	<(tiles0+0)
   5413  2489a			04		       .byte.b	<(tiles0+0)
   5414  2489b			04		       .byte.b	<(tiles0+0)
   5415  2489c			04		       .byte.b	<(tiles0+0)
   5416  2489d			04		       .byte.b	<(tiles0+0)
   5417  2489e			04		       .byte.b	<(tiles0+0)
   5418  2489f			04		       .byte.b	<(tiles0+0)
   5419  248a0			04		       .byte.b	<(tiles0+0)
   5420  248a1			04		       .byte.b	<(tiles0+0)
   5421  248a2			04		       .byte.b	<(tiles0+0)
   5422  248a3			04		       .byte.b	<(tiles0+0)
   5423  248a4			04		       .byte.b	<(tiles0+0)
   5424  248a5			04		       .byte.b	<(tiles0+0)
   5425  248a6			04		       .byte.b	<(tiles0+0)
   5426  248a7			04		       .byte.b	<(tiles0+0)
   5427  248a8			04		       .byte.b	<(tiles0+0)
   5428  248a9			04		       .byte.b	<(tiles0+0)
   5429  248aa			04		       .byte.b	<(tiles0+0)
   5430  248ab			04		       .byte.b	<(tiles0+0)
   5431  248ac			04		       .byte.b	<(tiles0+0)
   5432  248ad			04		       .byte.b	<(tiles0+0)
   5433  248ae			04		       .byte.b	<(tiles0+0)
   5434  248af			04		       .byte.b	<(tiles0+0)
   5435  248b0			04		       .byte.b	<(tiles0+0)
   5436  248b1			04		       .byte.b	<(tiles0+0)
   5437  248b2			04		       .byte.b	<(tiles0+0)
   5438  248b3			04		       .byte.b	<(tiles0+0)
   5439  248b4			04		       .byte.b	<(tiles0+0)
   5440  248b5			04		       .byte.b	<(tiles0+0)
   5441  248b6			04		       .byte.b	<(tiles0+0)
   5442  248b7			04		       .byte.b	<(tiles0+0)
   5443  248b8			04		       .byte.b	<(tiles0+0)
   5444  248b9			04		       .byte.b	<(tiles0+0)
   5445  248ba			04		       .byte.b	<(tiles0+0)
   5446  248bb			04		       .byte.b	<(tiles0+0)
   5447  248bc			04		       .byte.b	<(tiles0+0)
   5448  248bd			04		       .byte.b	<(tiles0+0)
   5449  248be			04		       .byte.b	<(tiles0+0)
   5450  248bf			04		       .byte.b	<(tiles0+0)
   5451  248c0			04		       .byte.b	<(tiles0+0)
   5452  248c1			04		       .byte.b	<(tiles0+0)
   5453  248c2			04		       .byte.b	<(tiles0+0)
   5454  248c3			04		       .byte.b	<(tiles0+0)
   5455  248c4			04		       .byte.b	<(tiles0+0)
   5456  248c5			04		       .byte.b	<(tiles0+0)
   5457  248c6			04		       .byte.b	<(tiles0+0)
   5458  248c7			04		       .byte.b	<(tiles0+0)
   5459  248c8			04		       .byte.b	<(tiles0+0)
   5460  248c9			04		       .byte.b	<(tiles0+0)
   5461  248ca			04		       .byte.b	<(tiles0+0)
   5462  248cb			04		       .byte.b	<(tiles0+0)
   5463  248cc			04		       .byte.b	<(tiles0+0)
   5464  248cd			04		       .byte.b	<(tiles0+0)
   5465  248ce			04		       .byte.b	<(tiles0+0)
   5466  248cf			04		       .byte.b	<(tiles0+0)
   5467  248d0			04		       .byte.b	<(tiles0+0)
   5468  248d1			04		       .byte.b	<(tiles0+0)
   5469  248d2			04		       .byte.b	<(tiles0+0)
   5470  248d3			04		       .byte.b	<(tiles0+0)
   5471  248d4			04		       .byte.b	<(tiles0+0)
   5472  248d5			04		       .byte.b	<(tiles0+0)
   5473  248d6			04		       .byte.b	<(tiles0+0)
   5474  248d7			04		       .byte.b	<(tiles0+0)
   5475  248d8			04		       .byte.b	<(tiles0+0)
   5476  248d9			04		       .byte.b	<(tiles0+0)
   5477  248da			04		       .byte.b	<(tiles0+0)
   5478  248db			04		       .byte.b	<(tiles0+0)
   5479  248dc			04		       .byte.b	<(tiles0+0)
   5480  248dd			04		       .byte.b	<(tiles0+0)
   5481  248de			04		       .byte.b	<(tiles0+0)
   5482  248df			04		       .byte.b	<(tiles0+0)
   5483  248e0			04		       .byte.b	<(tiles0+0)
   5484  248e1			04		       .byte.b	<(tiles0+0)
   5485  248e2			04		       .byte.b	<(tiles0+0)
   5486  248e3			04		       .byte.b	<(tiles0+0)
   5487  248e4			04		       .byte.b	<(tiles0+0)
   5488  248e5			04		       .byte.b	<(tiles0+0)
   5489  248e6			04		       .byte.b	<(tiles0+0)
   5490  248e7			04		       .byte.b	<(tiles0+0)
   5491  248e8			04		       .byte.b	<(tiles0+0)
   5492  248e9			04		       .byte.b	<(tiles0+0)
   5493  248ea			04		       .byte.b	<(tiles0+0)
   5494  248eb			04		       .byte.b	<(tiles0+0)
   5495  248ec			04		       .byte.b	<(tiles0+0)
   5496  248ed			04		       .byte.b	<(tiles0+0)
   5497  248ee			04		       .byte.b	<(tiles0+0)
   5498  248ef			04		       .byte.b	<(tiles0+0)
   5499  248f0			04		       .byte.b	<(tiles0+0)
   5500  248f1			04		       .byte.b	<(tiles0+0)
   5501  248f2			04		       .byte.b	<(tiles0+0)
   5502  248f3			06		       .byte.b	<(tiles2+0)
   5503  248f4			04		       .byte.b	<(tiles0+0)
   5504  248f5			04		       .byte.b	<(tiles0+0)
   5505  248f6			04		       .byte.b	<(tiles0+0)
   5506  248f7			04		       .byte.b	<(tiles0+0)
   5507  248f8			04		       .byte.b	<(tiles0+0)
   5508  248f9			04		       .byte.b	<(tiles0+0)
   5509  248fa			04		       .byte.b	<(tiles0+0)
   5510  248fb			06		       .byte.b	<(tiles2+0)
   5511  248fc			04		       .byte.b	<(tiles0+0)
   5512  248fd			04		       .byte.b	<(tiles0+0)
   5513  248fe			04		       .byte.b	<(tiles0+0)
   5514  248ff			04		       .byte.b	<(tiles0+0)
   5515  24900			04		       .byte.b	<(tiles0+0)
   5516  24901			04		       .byte.b	<(tiles0+0)
   5517  24902			06		       .byte.b	<(tiles2+0)
   5518  24903			04		       .byte.b	<(tiles0+0)
   5519  24904			04		       .byte.b	<(tiles0+0)
   5520  24905			04		       .byte.b	<(tiles0+0)
   5521  24906			04		       .byte.b	<(tiles0+0)
   5522  24907			04		       .byte.b	<(tiles0+0)
   5523  24908			04		       .byte.b	<(tiles0+0)
   5524  24909			04		       .byte.b	<(tiles0+0)
   5525  2490a			04		       .byte.b	<(tiles0+0)
   5526  2490b			04		       .byte.b	<(tiles0+0)
   5527  2490c			04		       .byte.b	<(tiles0+0)
   5528  2490d			04		       .byte.b	<(tiles0+0)
   5529  2490e			04		       .byte.b	<(tiles0+0)
   5530  2490f			04		       .byte.b	<(tiles0+0)
   5531  24910			04		       .byte.b	<(tiles0+0)
   5532  24911			04		       .byte.b	<(tiles0+0)
   5533  24912			04		       .byte.b	<(tiles0+0)
   5534  24913			04		       .byte.b	<(tiles0+0)
   5535  24914			04		       .byte.b	<(tiles0+0)
   5536  24915			04		       .byte.b	<(tiles0+0)
   5537  24916			04		       .byte.b	<(tiles0+0)
   5538  24917			04		       .byte.b	<(tiles0+0)
   5539  24918			04		       .byte.b	<(tiles0+0)
   5540  24919			06		       .byte.b	<(tiles2+0)
   5541  2491a			04		       .byte.b	<(tiles0+0)
   5542  2491b			04		       .byte.b	<(tiles0+0)
   5543  2491c			04		       .byte.b	<(tiles0+0)
   5544  2491d			04		       .byte.b	<(tiles0+0)
   5545  2491e			04		       .byte.b	<(tiles0+0)
   5546  2491f			04		       .byte.b	<(tiles0+0)
   5547  24920			04		       .byte.b	<(tiles0+0)
   5548  24921			06		       .byte.b	<(tiles2+0)
   5549  24922			04		       .byte.b	<(tiles0+0)
   5550  24923			04		       .byte.b	<(tiles0+0)
   5551  24924			04		       .byte.b	<(tiles0+0)
   5552  24925			04		       .byte.b	<(tiles0+0)
   5553  24926			04		       .byte.b	<(tiles0+0)
   5554  24927			04		       .byte.b	<(tiles0+0)
   5555  24928			04		       .byte.b	<(tiles0+0)
   5556  24929			04		       .byte.b	<(tiles0+0)
   5557  2492a			04		       .byte.b	<(tiles0+0)
   5558  2492b			04		       .byte.b	<(tiles0+0)
   5559  2492c			06		       .byte.b	<(tiles2+0)
   5560  2492d			04		       .byte.b	<(tiles0+0)
   5561  2492e			04		       .byte.b	<(tiles0+0)
   5562  2492f			04		       .byte.b	<(tiles0+0)
   5563  24930			04		       .byte.b	<(tiles0+0)
   5564  24931			04		       .byte.b	<(tiles0+0)
   5565  24932			04		       .byte.b	<(tiles0+0)
   5566  24933			04		       .byte.b	<(tiles0+0)
   5567  24934			04		       .byte.b	<(tiles0+0)
   5568  24935			04		       .byte.b	<(tiles0+0)
   5569  24936			04		       .byte.b	<(tiles0+0)
   5570  24937			04		       .byte.b	<(tiles0+0)
   5571  24938			04		       .byte.b	<(tiles0+0)
   5572  24939			04		       .byte.b	<(tiles0+0)
   5573  2493a			04		       .byte.b	<(tiles0+0)
   5574  2493b			04		       .byte.b	<(tiles0+0)
   5575  2493c			04		       .byte.b	<(tiles0+0)
   5576  2493d			04		       .byte.b	<(tiles0+0)
   5577  2493e			04		       .byte.b	<(tiles0+0)
   5578  2493f			04		       .byte.b	<(tiles0+0)
   5579  24940			04		       .byte.b	<(tiles0+0)
   5580  24941			04		       .byte.b	<(tiles0+0)
   5581  24942			04		       .byte.b	<(tiles0+0)
   5582  24943			04		       .byte.b	<(tiles0+0)
   5583  24944			04		       .byte.b	<(tiles0+0)
   5584  24945			04		       .byte.b	<(tiles0+0)
   5585  24946			04		       .byte.b	<(tiles0+0)
   5586  24947			04		       .byte.b	<(tiles0+0)
   5587  24948			04		       .byte.b	<(tiles0+0)
   5588  24949			04		       .byte.b	<(tiles0+0)
   5589  2494a			04		       .byte.b	<(tiles0+0)
   5590  2494b			04		       .byte.b	<(tiles0+0)
   5591  2494c			04		       .byte.b	<(tiles0+0)
   5592  2494d			04		       .byte.b	<(tiles0+0)
   5593  2494e			04		       .byte.b	<(tiles0+0)
   5594  2494f			06		       .byte.b	<(tiles2+0)
   5595  24950			06		       .byte.b	<(tiles2+0)
   5596  24951			04		       .byte.b	<(tiles0+0)
   5597  24952			04		       .byte.b	<(tiles0+0)
   5598  24953			04		       .byte.b	<(tiles0+0)
   5599  24954			04		       .byte.b	<(tiles0+0)
   5600  24955			04		       .byte.b	<(tiles0+0)
   5601  24956			04		       .byte.b	<(tiles0+0)
   5602  24957			04		       .byte.b	<(tiles0+0)
   5603  24958			04		       .byte.b	<(tiles0+0)
   5604  24959			04		       .byte.b	<(tiles0+0)
   5605  2495a			04		       .byte.b	<(tiles0+0)
   5606  2495b			04		       .byte.b	<(tiles0+0)
   5607  2495c			04		       .byte.b	<(tiles0+0)
   5608  2495d			04		       .byte.b	<(tiles0+0)
   5609  2495e			04		       .byte.b	<(tiles0+0)
   5610  2495f			04		       .byte.b	<(tiles0+0)
   5611  24960			04		       .byte.b	<(tiles0+0)
   5612  24961			04		       .byte.b	<(tiles0+0)
   5613  24962			04		       .byte.b	<(tiles0+0)
   5614  24963			04		       .byte.b	<(tiles0+0)
   5615  24964			04		       .byte.b	<(tiles0+0)
   5616  24965			04		       .byte.b	<(tiles0+0)
   5617  24966			04		       .byte.b	<(tiles0+0)
   5618  24967			06		       .byte.b	<(tiles2+0)
   5619  24968			06		       .byte.b	<(tiles2+0)
   5620  24969			04		       .byte.b	<(tiles0+0)
   5621  2496a			04		       .byte.b	<(tiles0+0)
   5622  2496b			04		       .byte.b	<(tiles0+0)
   5623  2496c			04		       .byte.b	<(tiles0+0)
   5624  2496d			04		       .byte.b	<(tiles0+0)
   5625  2496e			04		       .byte.b	<(tiles0+0)
   5626  2496f			04		       .byte.b	<(tiles0+0)
   5627  24970			04		       .byte.b	<(tiles0+0)
   5628  24971			04		       .byte.b	<(tiles0+0)
   5629  24972			04		       .byte.b	<(tiles0+0)
   5630  24973			04		       .byte.b	<(tiles0+0)
   5631  24974			04		       .byte.b	<(tiles0+0)
   5632  24975			04		       .byte.b	<(tiles0+0)
   5633  24976			04		       .byte.b	<(tiles0+0)
   5634  24977			04		       .byte.b	<(tiles0+0)
   5635  24978			04		       .byte.b	<(tiles0+0)
   5636  24979			04		       .byte.b	<(tiles0+0)
   5637  2497a			04		       .byte.b	<(tiles0+0)
   5638  2497b			04		       .byte.b	<(tiles0+0)
   5639  2497c			04		       .byte.b	<(tiles0+0)
   5640  2497d			04		       .byte.b	<(tiles0+0)
   5641  2497e			04		       .byte.b	<(tiles0+0)
   5642  2497f			04		       .byte.b	<(tiles0+0)
   5643  24980			04		       .byte.b	<(tiles0+0)
   5644  24981			04		       .byte.b	<(tiles0+0)
   5645  24982			04		       .byte.b	<(tiles0+0)
   5646  24983			04		       .byte.b	<(tiles0+0)
   5647  24984			04		       .byte.b	<(tiles0+0)
   5648  24985			04		       .byte.b	<(tiles0+0)
   5649  24986			06		       .byte.b	<(tiles2+0)
   5650  24987			06		       .byte.b	<(tiles2+0)
   5651  24988			04		       .byte.b	<(tiles0+0)
   5652  24989			04		       .byte.b	<(tiles0+0)
   5653  2498a			04		       .byte.b	<(tiles0+0)
   5654  2498b			04		       .byte.b	<(tiles0+0)
   5655  2498c			04		       .byte.b	<(tiles0+0)
   5656  2498d			04		       .byte.b	<(tiles0+0)
   5657  2498e			04		       .byte.b	<(tiles0+0)
   5658  2498f			04		       .byte.b	<(tiles0+0)
   5659  24990			04		       .byte.b	<(tiles0+0)
   5660  24991			04		       .byte.b	<(tiles0+0)
   5661  24992			04		       .byte.b	<(tiles0+0)
   5662  24993			04		       .byte.b	<(tiles0+0)
   5663  24994			04		       .byte.b	<(tiles0+0)
   5664  24995			04		       .byte.b	<(tiles0+0)
   5665  24996			04		       .byte.b	<(tiles0+0)
   5666  24997			04		       .byte.b	<(tiles0+0)
   5667  24998			04		       .byte.b	<(tiles0+0)
   5668  24999			04		       .byte.b	<(tiles0+0)
   5669  2499a			04		       .byte.b	<(tiles0+0)
   5670  2499b			04		       .byte.b	<(tiles0+0)
   5671  2499c			04		       .byte.b	<(tiles0+0)
   5672  2499d			04		       .byte.b	<(tiles0+0)
   5673  2499e			04		       .byte.b	<(tiles0+0)
   5674  2499f			04		       .byte.b	<(tiles0+0)
   5675  249a0			04		       .byte.b	<(tiles0+0)
   5676  249a1			04		       .byte.b	<(tiles0+0)
   5677  249a2			04		       .byte.b	<(tiles0+0)
   5678  249a3			04		       .byte.b	<(tiles0+0)
   5679  249a4			04		       .byte.b	<(tiles0+0)
   5680  249a5			04		       .byte.b	<(tiles0+0)
   5681  249a6			04		       .byte.b	<(tiles0+0)
   5682  249a7			04		       .byte.b	<(tiles0+0)
   5683  249a8			04		       .byte.b	<(tiles0+0)
   5684  249a9			04		       .byte.b	<(tiles0+0)
   5685  249aa			04		       .byte.b	<(tiles0+0)
   5686  249ab			04		       .byte.b	<(tiles0+0)
   5687  249ac			04		       .byte.b	<(tiles0+0)
   5688  249ad			04		       .byte.b	<(tiles0+0)
   5689  249ae			04		       .byte.b	<(tiles0+0)
   5690  249af			04		       .byte.b	<(tiles0+0)
   5691  249b0			04		       .byte.b	<(tiles0+0)
   5692  249b1			04		       .byte.b	<(tiles0+0)
   5693  249b2			06		       .byte.b	<(tiles2+0)
   5694  249b3			04		       .byte.b	<(tiles0+0)
   5695  249b4			04		       .byte.b	<(tiles0+0)
   5696  249b5			04		       .byte.b	<(tiles0+0)
   5697  249b6			04		       .byte.b	<(tiles0+0)
   5698  249b7			04		       .byte.b	<(tiles0+0)
   5699  249b8			04		       .byte.b	<(tiles0+0)
   5700  249b9			04		       .byte.b	<(tiles0+0)
   5701  249ba			04		       .byte.b	<(tiles0+0)
   5702  249bb			04		       .byte.b	<(tiles0+0)
   5703  249bc			04		       .byte.b	<(tiles0+0)
   5704  249bd			04		       .byte.b	<(tiles0+0)
   5705  249be			04		       .byte.b	<(tiles0+0)
   5706  249bf			04		       .byte.b	<(tiles0+0)
   5707  249c0			04		       .byte.b	<(tiles0+0)
   5708  249c1			04		       .byte.b	<(tiles0+0)
   5709  249c2			04		       .byte.b	<(tiles0+0)
   5710  249c3			06		       .byte.b	<(tiles2+0)
   5711  249c4			06		       .byte.b	<(tiles2+0)
   5712  249c5			04		       .byte.b	<(tiles0+0)
   5713  249c6			04		       .byte.b	<(tiles0+0)
   5714  249c7			04		       .byte.b	<(tiles0+0)
   5715  249c8			04		       .byte.b	<(tiles0+0)
   5716  249c9			04		       .byte.b	<(tiles0+0)
   5717  249ca			04		       .byte.b	<(tiles0+0)
   5718  249cb			04		       .byte.b	<(tiles0+0)
   5719  249cc			04		       .byte.b	<(tiles0+0)
   5720  249cd			04		       .byte.b	<(tiles0+0)
   5721  249ce			04		       .byte.b	<(tiles0+0)
   5722  249cf			04		       .byte.b	<(tiles0+0)
   5723  249d0			04		       .byte.b	<(tiles0+0)
   5724  249d1			04		       .byte.b	<(tiles0+0)
   5725  249d2			04		       .byte.b	<(tiles0+0)
   5726  249d3			04		       .byte.b	<(tiles0+0)
   5727  249d4			04		       .byte.b	<(tiles0+0)
   5728  249d5			04		       .byte.b	<(tiles0+0)
   5729  249d6			04		       .byte.b	<(tiles0+0)
   5730  249d7			04		       .byte.b	<(tiles0+0)
   5731  249d8			04		       .byte.b	<(tiles0+0)
   5732  249d9			04		       .byte.b	<(tiles0+0)
   5733  249da			04		       .byte.b	<(tiles0+0)
   5734  249db			04		       .byte.b	<(tiles0+0)
   5735  249dc			04		       .byte.b	<(tiles0+0)
   5736  249dd			04		       .byte.b	<(tiles0+0)
   5737  249de			04		       .byte.b	<(tiles0+0)
   5738  249df			04		       .byte.b	<(tiles0+0)
   5739  249e0			04		       .byte.b	<(tiles0+0)
   5740  249e1			04		       .byte.b	<(tiles0+0)
   5741  249e2			04		       .byte.b	<(tiles0+0)
   5742  249e3			04		       .byte.b	<(tiles0+0)
   5743  249e4			04		       .byte.b	<(tiles0+0)
   5744  249e5			04		       .byte.b	<(tiles0+0)
   5745  249e6			04		       .byte.b	<(tiles0+0)
   5746  249e7			04		       .byte.b	<(tiles0+0)
   5747  249e8			04		       .byte.b	<(tiles0+0)
   5748  249e9			04		       .byte.b	<(tiles0+0)
   5749  249ea			06		       .byte.b	<(tiles2+0)
   5750  249eb			06		       .byte.b	<(tiles2+0)
   5751  249ec			04		       .byte.b	<(tiles0+0)
   5752  249ed			04		       .byte.b	<(tiles0+0)
   5753  249ee			04		       .byte.b	<(tiles0+0)
   5754  249ef			04		       .byte.b	<(tiles0+0)
   5755  249f0			04		       .byte.b	<(tiles0+0)
   5756  249f1			04		       .byte.b	<(tiles0+0)
   5757  249f2			06		       .byte.b	<(tiles2+0)
   5758  249f3			04		       .byte.b	<(tiles0+0)
   5759  249f4			04		       .byte.b	<(tiles0+0)
   5760  249f5			04		       .byte.b	<(tiles0+0)
   5761  249f6			04		       .byte.b	<(tiles0+0)
   5762  249f7			04		       .byte.b	<(tiles0+0)
   5763  249f8			04		       .byte.b	<(tiles0+0)
   5764  249f9			04		       .byte.b	<(tiles0+0)
   5765  249fa			06		       .byte.b	<(tiles2+0)
   5766  249fb			04		       .byte.b	<(tiles0+0)
   5767  249fc			04		       .byte.b	<(tiles0+0)
   5768  249fd			04		       .byte.b	<(tiles0+0)
   5769  249fe			04		       .byte.b	<(tiles0+0)
   5770  249ff			04		       .byte.b	<(tiles0+0)
   5771  24a00			04		       .byte.b	<(tiles0+0)
   5772  24a01			04		       .byte.b	<(tiles0+0)
   5773  24a02			04		       .byte.b	<(tiles0+0)
   5774  24a03			04		       .byte.b	<(tiles0+0)
   5775  24a04			04		       .byte.b	<(tiles0+0)
   5776  24a05			04		       .byte.b	<(tiles0+0)
   5777  24a06			04		       .byte.b	<(tiles0+0)
   5778  24a07			04		       .byte.b	<(tiles0+0)
   5779  24a08			04		       .byte.b	<(tiles0+0)
   5780  24a09			04		       .byte.b	<(tiles0+0)
   5781  24a0a			04		       .byte.b	<(tiles0+0)
   5782  24a0b			04		       .byte.b	<(tiles0+0)
   5783  24a0c			04		       .byte.b	<(tiles0+0)
   5784  24a0d			06		       .byte.b	<(tiles2+0)
   5785  24a0e			04		       .byte.b	<(tiles0+0)
   5786  24a0f			04		       .byte.b	<(tiles0+0)
   5787  24a10			04		       .byte.b	<(tiles0+0)
   5788  24a11			04		       .byte.b	<(tiles0+0)
   5789  24a12			04		       .byte.b	<(tiles0+0)
   5790  24a13			04		       .byte.b	<(tiles0+0)
   5791  24a14			04		       .byte.b	<(tiles0+0)
   5792  24a15			04		       .byte.b	<(tiles0+0)
   5793  24a16			04		       .byte.b	<(tiles0+0)
   5794  24a17			04		       .byte.b	<(tiles0+0)
   5795  24a18			04		       .byte.b	<(tiles0+0)
   5796  24a19			04		       .byte.b	<(tiles0+0)
   5797  24a1a			06		       .byte.b	<(tiles2+0)
   5798  24a1b			04		       .byte.b	<(tiles0+0)
   5799  24a1c			04		       .byte.b	<(tiles0+0)
   5800  24a1d			04		       .byte.b	<(tiles0+0)
   5801  24a1e			04		       .byte.b	<(tiles0+0)
   5802  24a1f			04		       .byte.b	<(tiles0+0)
   5803  24a20			04		       .byte.b	<(tiles0+0)
   5804  24a21			04		       .byte.b	<(tiles0+0)
   5805  24a22			04		       .byte.b	<(tiles0+0)
   5806  24a23			04		       .byte.b	<(tiles0+0)
   5807  24a24			04		       .byte.b	<(tiles0+0)
   5808  24a25			04		       .byte.b	<(tiles0+0)
   5809  24a26			04		       .byte.b	<(tiles0+0)
   5810  24a27			04		       .byte.b	<(tiles0+0)
   5811  24a28			04		       .byte.b	<(tiles0+0)
   5812  24a29			04		       .byte.b	<(tiles0+0)
   5813  24a2a			04		       .byte.b	<(tiles0+0)
   5814  24a2b			04		       .byte.b	<(tiles0+0)
   5815  24a2c			04		       .byte.b	<(tiles0+0)
   5816  24a2d			04		       .byte.b	<(tiles0+0)
   5817  24a2e			04		       .byte.b	<(tiles0+0)
   5818  24a2f			04		       .byte.b	<(tiles0+0)
   5819  24a30			04		       .byte.b	<(tiles0+0)
   5820  24a31			04		       .byte.b	<(tiles0+0)
   5821  24a32			04		       .byte.b	<(tiles0+0)
   5822  24a33			06		       .byte.b	<(tiles2+0)
   5823  24a34			04		       .byte.b	<(tiles0+0)
   5824  24a35			04		       .byte.b	<(tiles0+0)
   5825  24a36			04		       .byte.b	<(tiles0+0)
   5826  24a37			04		       .byte.b	<(tiles0+0)
   5827  24a38			04		       .byte.b	<(tiles0+0)
   5828  24a39			04		       .byte.b	<(tiles0+0)
   5829  24a3a			04		       .byte.b	<(tiles0+0)
   5830  24a3b			04		       .byte.b	<(tiles0+0)
   5831  24a3c			04		       .byte.b	<(tiles0+0)
   5832  24a3d			04		       .byte.b	<(tiles0+0)
   5833  24a3e			04		       .byte.b	<(tiles0+0)
   5834  24a3f			04		       .byte.b	<(tiles0+0)
   5835  24a40			04		       .byte.b	<(tiles0+0)
   5836  24a41			04		       .byte.b	<(tiles0+0)
   5837  24a42			04		       .byte.b	<(tiles0+0)
   5838  24a43			04		       .byte.b	<(tiles0+0)
   5839  24a44			04		       .byte.b	<(tiles0+0)
   5840  24a45			04		       .byte.b	<(tiles0+0)
   5841  24a46			06		       .byte.b	<(tiles2+0)
   5842  24a47			04		       .byte.b	<(tiles0+0)
   5843  24a48			04		       .byte.b	<(tiles0+0)
   5844  24a49			04		       .byte.b	<(tiles0+0)
   5845  24a4a			04		       .byte.b	<(tiles0+0)
   5846  24a4b			04		       .byte.b	<(tiles0+0)
   5847  24a4c			04		       .byte.b	<(tiles0+0)
   5848  24a4d			04		       .byte.b	<(tiles0+0)
   5849  24a4e			04		       .byte.b	<(tiles0+0)
   5850  24a4f			04		       .byte.b	<(tiles0+0)
   5851  24a50			04		       .byte.b	<(tiles0+0)
   5852  24a51			04		       .byte.b	<(tiles0+0)
   5853  24a52			04		       .byte.b	<(tiles0+0)
   5854  24a53			04		       .byte.b	<(tiles0+0)
   5855  24a54			04		       .byte.b	<(tiles0+0)
   5856  24a55			04		       .byte.b	<(tiles0+0)
   5857  24a56			04		       .byte.b	<(tiles0+0)
   5858  24a57			04		       .byte.b	<(tiles0+0)
   5859  24a58			04		       .byte.b	<(tiles0+0)
   5860  24a59			06		       .byte.b	<(tiles2+0)
   5861  24a5a			04		       .byte.b	<(tiles0+0)
   5862  24a5b			04		       .byte.b	<(tiles0+0)
   5863  24a5c			04		       .byte.b	<(tiles0+0)
   5864  24a5d			04		       .byte.b	<(tiles0+0)
   5865  24a5e			04		       .byte.b	<(tiles0+0)
   5866  24a5f			04		       .byte.b	<(tiles0+0)
   5867  24a60			04		       .byte.b	<(tiles0+0)
   5868  24a61			04		       .byte.b	<(tiles0+0)
   5869  24a62			04		       .byte.b	<(tiles0+0)
   5870  24a63			04		       .byte.b	<(tiles0+0)
   5871  24a64			04		       .byte.b	<(tiles0+0)
   5872  24a65			04		       .byte.b	<(tiles0+0)
   5873  24a66			04		       .byte.b	<(tiles0+0)
   5874  24a67			04		       .byte.b	<(tiles0+0)
   5875  24a68			04		       .byte.b	<(tiles0+0)
   5876  24a69			04		       .byte.b	<(tiles0+0)
   5877  24a6a			04		       .byte.b	<(tiles0+0)
   5878  24a6b			04		       .byte.b	<(tiles0+0)
   5879  24a6c			06		       .byte.b	<(tiles2+0)
   5880  24a6d			04		       .byte.b	<(tiles0+0)
   5881  24a6e			04		       .byte.b	<(tiles0+0)
   5882  24a6f			04		       .byte.b	<(tiles0+0)
   5883  24a70			04		       .byte.b	<(tiles0+0)
   5884  24a71			04		       .byte.b	<(tiles0+0)
   5885  24a72			04		       .byte.b	<(tiles0+0)
   5886  24a73			04		       .byte.b	<(tiles0+0)
   5887  24a74			04		       .byte.b	<(tiles0+0)
   5888  24a75			04		       .byte.b	<(tiles0+0)
   5889  24a76			04		       .byte.b	<(tiles0+0)
   5890  24a77			04		       .byte.b	<(tiles0+0)
   5891  24a78			04		       .byte.b	<(tiles0+0)
   5892  24a79			04		       .byte.b	<(tiles0+0)
   5893  24a7a			04		       .byte.b	<(tiles0+0)
   5894  24a7b			04		       .byte.b	<(tiles0+0)
   5895  24a7c			04		       .byte.b	<(tiles0+0)
   5896  24a7d			04		       .byte.b	<(tiles0+0)
   5897  24a7e			04		       .byte.b	<(tiles0+0)
   5898  24a7f			06		       .byte.b	<(tiles2+0)
   5899  24a80			04		       .byte.b	<(tiles0+0)
   5900  24a81			04		       .byte.b	<(tiles0+0)
   5901  24a82			04		       .byte.b	<(tiles0+0)
   5902  24a83			04		       .byte.b	<(tiles0+0)
   5903  24a84			04		       .byte.b	<(tiles0+0)
   5904  24a85			04		       .byte.b	<(tiles0+0)
   5905  24a86			04		       .byte.b	<(tiles0+0)
   5906  24a87			04		       .byte.b	<(tiles0+0)
   5907  24a88			04		       .byte.b	<(tiles0+0)
   5908  24a89			04		       .byte.b	<(tiles0+0)
   5909  24a8a			04		       .byte.b	<(tiles0+0)
   5910  24a8b			04		       .byte.b	<(tiles0+0)
   5911  24a8c			04		       .byte.b	<(tiles0+0)
   5912  24a8d			04		       .byte.b	<(tiles0+0)
   5913  24a8e			04		       .byte.b	<(tiles0+0)
   5914  24a8f			04		       .byte.b	<(tiles0+0)
   5915  24a90			04		       .byte.b	<(tiles0+0)
   5916  24a91			04		       .byte.b	<(tiles0+0)
   5917  24a92			06		       .byte.b	<(tiles2+0)
   5918  24a93			04		       .byte.b	<(tiles0+0)
   5919  24a94			04		       .byte.b	<(tiles0+0)
   5920  24a95			04		       .byte.b	<(tiles0+0)
   5921  24a96			04		       .byte.b	<(tiles0+0)
   5922  24a97			04		       .byte.b	<(tiles0+0)
   5923  24a98			04		       .byte.b	<(tiles0+0)
   5924  24a99			04		       .byte.b	<(tiles0+0)
   5925  24a9a			04		       .byte.b	<(tiles0+0)
   5926  24a9b			04		       .byte.b	<(tiles0+0)
   5927  24a9c			04		       .byte.b	<(tiles0+0)
   5928  24a9d			04		       .byte.b	<(tiles0+0)
   5929  24a9e			04		       .byte.b	<(tiles0+0)
   5930  24a9f			04		       .byte.b	<(tiles0+0)
   5931  24aa0			04		       .byte.b	<(tiles0+0)
   5932  24aa1			04		       .byte.b	<(tiles0+0)
   5933  24aa2			04		       .byte.b	<(tiles0+0)
   5934  24aa3			04		       .byte.b	<(tiles0+0)
   5935  24aa4			04		       .byte.b	<(tiles0+0)
   5936  24aa5			06		       .byte.b	<(tiles2+0)
   5937  24aa6			04		       .byte.b	<(tiles0+0)
   5938  24aa7			04		       .byte.b	<(tiles0+0)
   5939  24aa8			04		       .byte.b	<(tiles0+0)
   5940  24aa9			04		       .byte.b	<(tiles0+0)
   5941  24aaa			04		       .byte.b	<(tiles0+0)
   5942  24aab			04		       .byte.b	<(tiles0+0)
   5943  24aac			04		       .byte.b	<(tiles0+0)
   5944  24aad			04		       .byte.b	<(tiles0+0)
   5945  24aae			04		       .byte.b	<(tiles0+0)
   5946  24aaf			04		       .byte.b	<(tiles0+0)
   5947  24ab0			04		       .byte.b	<(tiles0+0)
   5948  24ab1			04		       .byte.b	<(tiles0+0)
   5949  24ab2			04		       .byte.b	<(tiles0+0)
   5950  24ab3			04		       .byte.b	<(tiles0+0)
   5951  24ab4			04		       .byte.b	<(tiles0+0)
   5952  24ab5			04		       .byte.b	<(tiles0+0)
   5953  24ab6			04		       .byte.b	<(tiles0+0)
   5954  24ab7			04		       .byte.b	<(tiles0+0)
   5955  24ab8			06		       .byte.b	<(tiles2+0)
   5956  24ab9			04		       .byte.b	<(tiles0+0)
   5957  24aba			04		       .byte.b	<(tiles0+0)
   5958  24abb			04		       .byte.b	<(tiles0+0)
   5959  24abc			04		       .byte.b	<(tiles0+0)
   5960  24abd			04		       .byte.b	<(tiles0+0)
   5961  24abe			04		       .byte.b	<(tiles0+0)
   5962  24abf			04		       .byte.b	<(tiles0+0)
   5963  24ac0			04		       .byte.b	<(tiles0+0)
   5964  24ac1			04		       .byte.b	<(tiles0+0)
   5965  24ac2			04		       .byte.b	<(tiles0+0)
   5966  24ac3			04		       .byte.b	<(tiles0+0)
   5967  24ac4			04		       .byte.b	<(tiles0+0)
   5968  24ac5			04		       .byte.b	<(tiles0+0)
   5969  24ac6			04		       .byte.b	<(tiles0+0)
   5970  24ac7			04		       .byte.b	<(tiles0+0)
   5971  24ac8			04		       .byte.b	<(tiles0+0)
   5972  24ac9			04		       .byte.b	<(tiles0+0)
   5973  24aca			04		       .byte.b	<(tiles0+0)
   5974  24acb			06		       .byte.b	<(tiles2+0)
   5975  24acc			04		       .byte.b	<(tiles0+0)
   5976  24acd			04		       .byte.b	<(tiles0+0)
   5977  24ace			04		       .byte.b	<(tiles0+0)
   5978  24acf			04		       .byte.b	<(tiles0+0)
   5979  24ad0			04		       .byte.b	<(tiles0+0)
   5980  24ad1			04		       .byte.b	<(tiles0+0)
   5981  24ad2			04		       .byte.b	<(tiles0+0)
   5982  24ad3			04		       .byte.b	<(tiles0+0)
   5983  24ad4			04		       .byte.b	<(tiles0+0)
   5984  24ad5			04		       .byte.b	<(tiles0+0)
   5985  24ad6			04		       .byte.b	<(tiles0+0)
   5986  24ad7			04		       .byte.b	<(tiles0+0)
   5987  24ad8			04		       .byte.b	<(tiles0+0)
   5988  24ad9			04		       .byte.b	<(tiles0+0)
   5989  24ada			04		       .byte.b	<(tiles0+0)
   5990  24adb			04		       .byte.b	<(tiles0+0)
   5991  24adc			04		       .byte.b	<(tiles0+0)
   5992  24add			04		       .byte.b	<(tiles0+0)
   5993  24ade			06		       .byte.b	<(tiles2+0)
   5994  24adf			04		       .byte.b	<(tiles0+0)
   5995  24ae0			04		       .byte.b	<(tiles0+0)
   5996  24ae1			04		       .byte.b	<(tiles0+0)
   5997  24ae2			04		       .byte.b	<(tiles0+0)
   5998  24ae3			04		       .byte.b	<(tiles0+0)
   5999  24ae4			04		       .byte.b	<(tiles0+0)
   6000  24ae5			04		       .byte.b	<(tiles0+0)
   6001  24ae6			04		       .byte.b	<(tiles0+0)
   6002  24ae7			04		       .byte.b	<(tiles0+0)
   6003  24ae8			04		       .byte.b	<(tiles0+0)
   6004  24ae9			04		       .byte.b	<(tiles0+0)
   6005  24aea			04		       .byte.b	<(tiles0+0)
   6006  24aeb			04		       .byte.b	<(tiles0+0)
   6007  24aec			04		       .byte.b	<(tiles0+0)
   6008  24aed			04		       .byte.b	<(tiles0+0)
   6009  24aee			04		       .byte.b	<(tiles0+0)
   6010  24aef			04		       .byte.b	<(tiles0+0)
   6011  24af0			04		       .byte.b	<(tiles0+0)
   6012  24af1			06		       .byte.b	<(tiles2+0)
   6013  24af2			04		       .byte.b	<(tiles0+0)
   6014  24af3			04		       .byte.b	<(tiles0+0)
   6015  24af4			04		       .byte.b	<(tiles0+0)
   6016  24af5			04		       .byte.b	<(tiles0+0)
   6017  24af6			04		       .byte.b	<(tiles0+0)
   6018  24af7			04		       .byte.b	<(tiles0+0)
   6019  24af8			04		       .byte.b	<(tiles0+0)
   6020  24af9			06		       .byte.b	<(tiles2+0)
   6021  24afa			06		       .byte.b	<(tiles2+0)
   6022  24afb			06		       .byte.b	<(tiles2+0)
   6023  24afc			06		       .byte.b	<(tiles2+0)
   6024  24afd			06		       .byte.b	<(tiles2+0)
   6025  24afe			06		       .byte.b	<(tiles2+0)
   6026  24aff			06		       .byte.b	<(tiles2+0)
   6027  24b00			06		       .byte.b	<(tiles2+0)
   6028  24b01			06		       .byte.b	<(tiles2+0)
   6029  24b02			06		       .byte.b	<(tiles2+0)
   6030  24b03			06		       .byte.b	<(tiles2+0)
   6031  24b04			06		       .byte.b	<(tiles2+0)
   6032  24b05			06		       .byte.b	<(tiles2+0)
   6033  24b06			06		       .byte.b	<(tiles2+0)
   6034  24b07			06		       .byte.b	<(tiles2+0)
   6035  24b08			06		       .byte.b	<(tiles2+0)
   6036  24b09			06		       .byte.b	<(tiles2+0)
   6037  24b0a			06		       .byte.b	<(tiles2+0)
   6038  24b0b			06		       .byte.b	<(tiles2+0)
   6039  24b0c			06		       .byte.b	<(tiles2+0)
   6040  24b0d			06		       .byte.b	<(tiles2+0)
   6041  24b0e			06		       .byte.b	<(tiles2+0)
   6042  24b0f			06		       .byte.b	<(tiles2+0)
   6043  24b10			06		       .byte.b	<(tiles2+0)
   6044  24b11			06		       .byte.b	<(tiles2+0)
   6045  24b12			06		       .byte.b	<(tiles2+0)
   6046  24b13			06		       .byte.b	<(tiles2+0)
   6047  24b14			06		       .byte.b	<(tiles2+0)
   6048  24b15			06		       .byte.b	<(tiles2+0)
   6049  24b16			06		       .byte.b	<(tiles2+0)
   6050  24b17			06		       .byte.b	<(tiles2+0)
   6051  24b18			06		       .byte.b	<(tiles2+0)
   6052  24b19			06		       .byte.b	<(tiles2+0)
   6053  24b1a			06		       .byte.b	<(tiles2+0)
   6054  24b1b			06		       .byte.b	<(tiles2+0)
   6055  24b1c			06		       .byte.b	<(tiles2+0)
   6056  24b1d			06		       .byte.b	<(tiles2+0)
   6057  24b1e			06		       .byte.b	<(tiles2+0)
   6058  24b1f			06		       .byte.b	<(tiles2+0)
   6059  24b20			06		       .byte.b	<(tiles2+0)
   6060  24b21			06		       .byte.b	<(tiles2+0)
   6061  24b22			06		       .byte.b	<(tiles2+0)
   6062  24b23			06		       .byte.b	<(tiles2+0)
   6063  24b24			06		       .byte.b	<(tiles2+0)
   6064  24b25			06		       .byte.b	<(tiles2+0)
   6065  24b26			06		       .byte.b	<(tiles2+0)
   6066  24b27			06		       .byte.b	<(tiles2+0)
   6067  24b28			06		       .byte.b	<(tiles2+0)
   6068  24b29			06		       .byte.b	<(tiles2+0)
   6069  24b2a			06		       .byte.b	<(tiles2+0)
   6070  24b2b			06		       .byte.b	<(tiles2+0)
   6071  24b2c			06		       .byte.b	<(tiles2+0)
   6072  24b2d			06		       .byte.b	<(tiles2+0)
   6073  24b2e			06		       .byte.b	<(tiles2+0)
   6074  24b2f			06		       .byte.b	<(tiles2+0)
   6075  24b30			06		       .byte.b	<(tiles2+0)
   6076  24b31			06		       .byte.b	<(tiles2+0)
   6077  24b32			06		       .byte.b	<(tiles2+0)
   6078  24b33			06		       .byte.b	<(tiles2+0)
   6079  24b34			06		       .byte.b	<(tiles2+0)
   6080  24b35			06		       .byte.b	<(tiles2+0)
   6081  24b36			06		       .byte.b	<(tiles2+0)
   6082  24b37			06		       .byte.b	<(tiles2+0)
   6083  24b38			06		       .byte.b	<(tiles2+0)
   6084  24b39			06		       .byte.b	<(tiles2+0)
   6085  24b3a			06		       .byte.b	<(tiles2+0)
   6086  24b3b			06		       .byte.b	<(tiles2+0)
   6087  24b3c			06		       .byte.b	<(tiles2+0)
   6088  24b3d			06		       .byte.b	<(tiles2+0)
   6089  24b3e			06		       .byte.b	<(tiles2+0)
   6090  24b3f			06		       .byte.b	<(tiles2+0)
   6091  24b40			06		       .byte.b	<(tiles2+0)
   6092  24b41			06		       .byte.b	<(tiles2+0)
   6093  24b42			06		       .byte.b	<(tiles2+0)
   6094  24b43			06		       .byte.b	<(tiles2+0)
   6095  24b44			06		       .byte.b	<(tiles2+0)
   6096  24b45			06		       .byte.b	<(tiles2+0)
   6097  24b46			06		       .byte.b	<(tiles2+0)
   6098  24b47			06		       .byte.b	<(tiles2+0)
   6099  24b48			06		       .byte.b	<(tiles2+0)
   6100  24b49			06		       .byte.b	<(tiles2+0)
   6101  24b4a			06		       .byte.b	<(tiles2+0)
   6102  24b4b			06		       .byte.b	<(tiles2+0)
   6103  24b4c			06		       .byte.b	<(tiles2+0)
   6104  24b4d			06		       .byte.b	<(tiles2+0)
   6105  24b4e			06		       .byte.b	<(tiles2+0)
   6106  24b4f			06		       .byte.b	<(tiles2+0)
   6107  24b50			06		       .byte.b	<(tiles2+0)
   6108  24b51			06		       .byte.b	<(tiles2+0)
   6109  24b52			06		       .byte.b	<(tiles2+0)
   6110  24b53			06		       .byte.b	<(tiles2+0)
   6111  24b54			06		       .byte.b	<(tiles2+0)
   6112  24b55			06		       .byte.b	<(tiles2+0)
   6113  24b56			06		       .byte.b	<(tiles2+0)
   6114  24b57			06		       .byte.b	<(tiles2+0)
   6115  24b58			06		       .byte.b	<(tiles2+0)
   6116  24b59			06		       .byte.b	<(tiles2+0)
   6117  24b5a			06		       .byte.b	<(tiles2+0)
   6118  24b5b			06		       .byte.b	<(tiles2+0)
   6119  24b5c			06		       .byte.b	<(tiles2+0)
   6120  24b5d			06		       .byte.b	<(tiles2+0)
   6121  24b5e			06		       .byte.b	<(tiles2+0)
   6122  24b5f			06		       .byte.b	<(tiles2+0)
   6123  24b60			06		       .byte.b	<(tiles2+0)
   6124  24b61			06		       .byte.b	<(tiles2+0)
   6125  24b62			06		       .byte.b	<(tiles2+0)
   6126  24b63			06		       .byte.b	<(tiles2+0)
   6127  24b64			06		       .byte.b	<(tiles2+0)
   6128  24b65			06		       .byte.b	<(tiles2+0)
   6129  24b66			06		       .byte.b	<(tiles2+0)
   6130  24b67			06		       .byte.b	<(tiles2+0)
   6131  24b68			06		       .byte.b	<(tiles2+0)
   6132  24b69			06		       .byte.b	<(tiles2+0)
   6133  24b6a			06		       .byte.b	<(tiles2+0)
   6134  24b6b			06		       .byte.b	<(tiles2+0)
   6135  24b6c			06		       .byte.b	<(tiles2+0)
   6136  24b6d			06		       .byte.b	<(tiles2+0)
   6137  24b6e			06		       .byte.b	<(tiles2+0)
   6138  24b6f			06		       .byte.b	<(tiles2+0)
   6139  24b70			06		       .byte.b	<(tiles2+0)
   6140  24b71			06		       .byte.b	<(tiles2+0)
   6141  24b72			06		       .byte.b	<(tiles2+0)
   6142  24b73			06		       .byte.b	<(tiles2+0)
   6143  24b74			06		       .byte.b	<(tiles2+0)
   6144  24b75			06		       .byte.b	<(tiles2+0)
   6145  24b76			06		       .byte.b	<(tiles2+0)
   6146  24b77			06		       .byte.b	<(tiles2+0)
   6147  24b78			06		       .byte.b	<(tiles2+0)
   6148  24b79			06		       .byte.b	<(tiles2+0)
   6149  24b7a			06		       .byte.b	<(tiles2+0)
   6150  24b7b			06		       .byte.b	<(tiles2+0)
   6151  24b7c			06		       .byte.b	<(tiles2+0)
   6152  24b7d			06		       .byte.b	<(tiles2+0)
   6153  24b7e			06		       .byte.b	<(tiles2+0)
   6154  24b7f			06		       .byte.b	<(tiles2+0)
   6155  24b80			06		       .byte.b	<(tiles2+0)
   6156  24b81			06		       .byte.b	<(tiles2+0)
   6157  24b82			06		       .byte.b	<(tiles2+0)
   6158  24b83			06		       .byte.b	<(tiles2+0)
   6159  24b84			06		       .byte.b	<(tiles2+0)
   6160  24b85			06		       .byte.b	<(tiles2+0)
   6161  24b86			06		       .byte.b	<(tiles2+0)
   6162  24b87			06		       .byte.b	<(tiles2+0)
   6163  24b88			06		       .byte.b	<(tiles2+0)
   6164  24b89			06		       .byte.b	<(tiles2+0)
   6165  24b8a			06		       .byte.b	<(tiles2+0)
   6166  24b8b			06		       .byte.b	<(tiles2+0)
   6167  24b8c			06		       .byte.b	<(tiles2+0)
   6168  24b8d			06		       .byte.b	<(tiles2+0)
   6169  24b8e			06		       .byte.b	<(tiles2+0)
   6170  24b8f			06		       .byte.b	<(tiles2+0)
   6171  24b90			06		       .byte.b	<(tiles2+0)
   6172  24b91			06		       .byte.b	<(tiles2+0)
   6173  24b92			06		       .byte.b	<(tiles2+0)
   6174  24b93			06		       .byte.b	<(tiles2+0)
   6175  24b94			06		       .byte.b	<(tiles2+0)
   6176  24b95			06		       .byte.b	<(tiles2+0)
   6177  24b96			06		       .byte.b	<(tiles2+0)
   6178  24b97			06		       .byte.b	<(tiles2+0)
   6179  24b98			06		       .byte.b	<(tiles2+0)
   6180  24b99			06		       .byte.b	<(tiles2+0)
   6181  24b9a			06		       .byte.b	<(tiles2+0)
   6182  24b9b			06		       .byte.b	<(tiles2+0)
   6183  24b9c			06		       .byte.b	<(tiles2+0)
   6184  24b9d			06		       .byte.b	<(tiles2+0)
   6185  24b9e			06		       .byte.b	<(tiles2+0)
   6186  24b9f			06		       .byte.b	<(tiles2+0)
   6187  24ba0			06		       .byte.b	<(tiles2+0)
   6188  24ba1			06		       .byte.b	<(tiles2+0)
   6189  24ba2			06		       .byte.b	<(tiles2+0)
   6190  24ba3			06		       .byte.b	<(tiles2+0)
   6191  24ba4			06		       .byte.b	<(tiles2+0)
   6192  24ba5			06		       .byte.b	<(tiles2+0)
   6193  24ba6			06		       .byte.b	<(tiles2+0)
   6194  24ba7			06		       .byte.b	<(tiles2+0)
   6195  24ba8			06		       .byte.b	<(tiles2+0)
   6196  24ba9			06		       .byte.b	<(tiles2+0)
   6197  24baa			06		       .byte.b	<(tiles2+0)
   6198  24bab			06		       .byte.b	<(tiles2+0)
   6199  24bac			06		       .byte.b	<(tiles2+0)
   6200  24bad			06		       .byte.b	<(tiles2+0)
   6201  24bae			06		       .byte.b	<(tiles2+0)
   6202  24baf			06		       .byte.b	<(tiles2+0)
   6203  24bb0			06		       .byte.b	<(tiles2+0)
   6204  24bb1			06		       .byte.b	<(tiles2+0)
   6205  24bb2			06		       .byte.b	<(tiles2+0)
   6206  24bb3			06		       .byte.b	<(tiles2+0)
   6207  24bb4			06		       .byte.b	<(tiles2+0)
   6208  24bb5			06		       .byte.b	<(tiles2+0)
   6209  24bb6			06		       .byte.b	<(tiles2+0)
   6210  24bb7			06		       .byte.b	<(tiles2+0)
   6211  24bb8			06		       .byte.b	<(tiles2+0)
   6212  24bb9			06		       .byte.b	<(tiles2+0)
   6213  24bba			06		       .byte.b	<(tiles2+0)
   6214  24bbb			06		       .byte.b	<(tiles2+0)
   6215  24bbc			06		       .byte.b	<(tiles2+0)
   6216  24bbd			06		       .byte.b	<(tiles2+0)
   6217  24bbe			06		       .byte.b	<(tiles2+0)
   6218  24bbf			06		       .byte.b	<(tiles2+0)
   6219  24bc0			06		       .byte.b	<(tiles2+0)
   6220  24bc1			06		       .byte.b	<(tiles2+0)
   6221  24bc2			06		       .byte.b	<(tiles2+0)
   6222  24bc3			06		       .byte.b	<(tiles2+0)
   6223  24bc4			06		       .byte.b	<(tiles2+0)
   6224  24bc5			06		       .byte.b	<(tiles2+0)
   6225  24bc6			06		       .byte.b	<(tiles2+0)
   6226  24bc7			06		       .byte.b	<(tiles2+0)
   6227  24bc8			06		       .byte.b	<(tiles2+0)
   6228  24bc9			06		       .byte.b	<(tiles2+0)
   6229  24bca			06		       .byte.b	<(tiles2+0)
   6230  24bcb			06		       .byte.b	<(tiles2+0)
   6231  24bcc			06		       .byte.b	<(tiles2+0)
   6232  24bcd			06		       .byte.b	<(tiles2+0)
   6233  24bce			06		       .byte.b	<(tiles2+0)
   6234  24bcf			06		       .byte.b	<(tiles2+0)
   6235  24bd0			06		       .byte.b	<(tiles2+0)
   6236  24bd1			06		       .byte.b	<(tiles2+0)
   6237  24bd2			06		       .byte.b	<(tiles2+0)
   6238  24bd3			06		       .byte.b	<(tiles2+0)
   6239  24bd4			06		       .byte.b	<(tiles2+0)
   6240  24bd5			06		       .byte.b	<(tiles2+0)
   6241  24bd6			06		       .byte.b	<(tiles2+0)
   6242  24bd7			06		       .byte.b	<(tiles2+0)
   6243  24bd8			06		       .byte.b	<(tiles2+0)
   6244  24bd9			06		       .byte.b	<(tiles2+0)
   6245  24bda			06		       .byte.b	<(tiles2+0)
   6246  24bdb			06		       .byte.b	<(tiles2+0)
   6247  24bdc			06		       .byte.b	<(tiles2+0)
   6248  24bdd			06		       .byte.b	<(tiles2+0)
   6249  24bde			06		       .byte.b	<(tiles2+0)
   6250  24bdf			06		       .byte.b	<(tiles2+0)
   6251  24be0			06		       .byte.b	<(tiles2+0)
   6252  24be1			06		       .byte.b	<(tiles2+0)
   6253  24be2			06		       .byte.b	<(tiles2+0)
   6254  24be3			06		       .byte.b	<(tiles2+0)
   6255  24be4			06		       .byte.b	<(tiles2+0)
   6256  24be5			06		       .byte.b	<(tiles2+0)
   6257  24be6			06		       .byte.b	<(tiles2+0)
   6258  24be7			06		       .byte.b	<(tiles2+0)
   6259  24be8			06		       .byte.b	<(tiles2+0)
   6260  24be9			06		       .byte.b	<(tiles2+0)
   6261  24bea			06		       .byte.b	<(tiles2+0)
   6262  24beb			06		       .byte.b	<(tiles2+0)
   6263  24bec			06		       .byte.b	<(tiles2+0)
   6264  24bed			06		       .byte.b	<(tiles2+0)
   6265  24bee			06		       .byte.b	<(tiles2+0)
   6266  24bef			06		       .byte.b	<(tiles2+0)
   6267  24bf0			06		       .byte.b	<(tiles2+0)
   6268  24bf1			04		       .byte.b	<(tiles0+0)
   6269  24bf2			04		       .byte.b	<(tiles0+0)
   6270  24bf3			04		       .byte.b	<(tiles0+0)
   6271  24bf4			04		       .byte.b	<(tiles0+0)
   6272  24bf5			04		       .byte.b	<(tiles0+0)
   6273  24bf6			04		       .byte.b	<(tiles0+0)
   6274  24bf7				    skipmapdata31
   6275  24bf7				    DMAHOLEEND0 SET	.
   6276  24bf7				    gameend
   6277  24bf7				    DMAHOLEEND0 SET	.
   5129 bytes of ROM space left in the main area of bank 8.
   6278  24bf7					       echo	" ",[($E000 - .)]d , "bytes of ROM space left in the main area of bank 8."
   6279  24bf7				   -	       if	($E000 - .) < 0
   6280  24bf7				   -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
   6281  24bf7					       endif
   6282  24bf7
   6283  26000					       ORG	$26000,0	; *************
   6284  26000
   6285  26000					       RORG	$E000	; *************
   6286  26000
   6287  26000			e0 00	    playerSprite =	$E000
   6288  26000
   6289  26000				    playerSprite
   6290  26000			55 55		       HEX	5555
   6291  26000			e0 02	    enemySprite =	$E002
   6292  26002
   6293  26002				    enemySprite
   6294  26002			aa aa		       HEX	aaaa
   6295  26002			e0 04	    tiles0     =	$E004
   6296  26004
   6297  26004				    tiles0
   6298  26004			00 00		       HEX	0000
   6299  26004			e0 06	    tiles2     =	$E006
   6300  26006
   6301  26006				    tiles2
   6302  26006			00 00		       HEX	0000
   6303  26008
   6304  26100					       ORG	$26100,0	; *************
   6305  26100
   6306  26100					       RORG	$E100	; *************
   6307  26100
   6308  26100							;playerSprite
   6309  26100			55 55		       HEX	5555
   6310  26102							;enemySprite
   6311  26102			aa aa		       HEX	aaaa
   6312  26104							;tiles0
   6313  26104			00 00		       HEX	0000
   6314  26106							;tiles2
   6315  26106			55 55		       HEX	5555
   6316  26108
   6317  26200					       ORG	$26200,0	; *************
   6318  26200
   6319  26200					       RORG	$E200	; *************
   6320  26200
   6321  26200							;playerSprite
   6322  26200			55 55		       HEX	5555
   6323  26202							;enemySprite
   6324  26202			aa aa		       HEX	aaaa
   6325  26204							;tiles0
   6326  26204			00 00		       HEX	0000
   6327  26206							;tiles2
   6328  26206			95 55		       HEX	9555
   6329  26208
   6330  26300					       ORG	$26300,0	; *************
   6331  26300
   6332  26300					       RORG	$E300	; *************
   6333  26300
   6334  26300							;playerSprite
   6335  26300			55 55		       HEX	5555
   6336  26302							;enemySprite
   6337  26302			aa aa		       HEX	aaaa
   6338  26304							;tiles0
   6339  26304			00 00		       HEX	0000
   6340  26306							;tiles2
   6341  26306			ea a9		       HEX	eaa9
   6342  26308
   6343  26400					       ORG	$26400,0	; *************
   6344  26400
   6345  26400					       RORG	$E400	; *************
   6346  26400
   6347  26400							;playerSprite
   6348  26400			55 55		       HEX	5555
   6349  26402							;enemySprite
   6350  26402			aa aa		       HEX	aaaa
   6351  26404							;tiles0
   6352  26404			00 00		       HEX	0000
   6353  26406							;tiles2
   6354  26406			e5 59		       HEX	e559
   6355  26408
   6356  26500					       ORG	$26500,0	; *************
   6357  26500
   6358  26500					       RORG	$E500	; *************
   6359  26500
   6360  26500							;playerSprite
   6361  26500			aa aa		       HEX	aaaa
   6362  26502							;enemySprite
   6363  26502			aa aa		       HEX	aaaa
   6364  26504							;tiles0
   6365  26504			00 00		       HEX	0000
   6366  26506							;tiles2
   6367  26506			ee 99		       HEX	ee99
   6368  26508
   6369  26600					       ORG	$26600,0	; *************
   6370  26600
   6371  26600					       RORG	$E600	; *************
   6372  26600
   6373  26600							;playerSprite
   6374  26600			aa aa		       HEX	aaaa
   6375  26602							;enemySprite
   6376  26602			aa aa		       HEX	aaaa
   6377  26604							;tiles0
   6378  26604			00 00		       HEX	0000
   6379  26606							;tiles2
   6380  26606			ee 99		       HEX	ee99
   6381  26608
   6382  26700					       ORG	$26700,0	; *************
   6383  26700
   6384  26700					       RORG	$E700	; *************
   6385  26700
   6386  26700							;playerSprite
   6387  26700			aa aa		       HEX	aaaa
   6388  26702							;enemySprite
   6389  26702			aa aa		       HEX	aaaa
   6390  26704							;tiles0
   6391  26704			00 00		       HEX	0000
   6392  26706							;tiles2
   6393  26706			ee 99		       HEX	ee99
   6394  26708
   6395  26800					       ORG	$26800,0	; *************
   6396  26800
   6397  26800					       RORG	$E800	; *************
   6398  26800
   6399  26800							;playerSprite
   6400  26800			aa aa		       HEX	aaaa
   6401  26802							;enemySprite
   6402  26802			aa aa		       HEX	aaaa
   6403  26804							;tiles0
   6404  26804			00 00		       HEX	0000
   6405  26806							;tiles2
   6406  26806			ee 99		       HEX	ee99
   6407  26808
   6408  26900					       ORG	$26900,0	; *************
   6409  26900
   6410  26900					       RORG	$E900	; *************
   6411  26900
   6412  26900							;playerSprite
   6413  26900			aa aa		       HEX	aaaa
   6414  26902							;enemySprite
   6415  26902			aa aa		       HEX	aaaa
   6416  26904							;tiles0
   6417  26904			00 00		       HEX	0000
   6418  26906							;tiles2
   6419  26906			ee 99		       HEX	ee99
   6420  26908
   6421  26a00					       ORG	$26A00,0	; *************
   6422  26a00
   6423  26a00					       RORG	$EA00	; *************
   6424  26a00
   6425  26a00							;playerSprite
   6426  26a00			aa aa		       HEX	aaaa
   6427  26a02							;enemySprite
   6428  26a02			aa aa		       HEX	aaaa
   6429  26a04							;tiles0
   6430  26a04			00 00		       HEX	0000
   6431  26a06							;tiles2
   6432  26a06			ee 99		       HEX	ee99
   6433  26a08
   6434  26b00					       ORG	$26B00,0	; *************
   6435  26b00
   6436  26b00					       RORG	$EB00	; *************
   6437  26b00
   6438  26b00							;playerSprite
   6439  26b00			ff ff		       HEX	ffff
   6440  26b02							;enemySprite
   6441  26b02			aa aa		       HEX	aaaa
   6442  26b04							;tiles0
   6443  26b04			00 00		       HEX	0000
   6444  26b06							;tiles2
   6445  26b06			ef f9		       HEX	eff9
   6446  26b08
   6447  26c00					       ORG	$26C00,0	; *************
   6448  26c00
   6449  26c00					       RORG	$EC00	; *************
   6450  26c00
   6451  26c00							;playerSprite
   6452  26c00			ff ff		       HEX	ffff
   6453  26c02							;enemySprite
   6454  26c02			aa aa		       HEX	aaaa
   6455  26c04							;tiles0
   6456  26c04			00 00		       HEX	0000
   6457  26c06							;tiles2
   6458  26c06			ea a9		       HEX	eaa9
   6459  26c08
   6460  26d00					       ORG	$26D00,0	; *************
   6461  26d00
   6462  26d00					       RORG	$ED00	; *************
   6463  26d00
   6464  26d00							;playerSprite
   6465  26d00			ff ff		       HEX	ffff
   6466  26d02							;enemySprite
   6467  26d02			aa aa		       HEX	aaaa
   6468  26d04							;tiles0
   6469  26d04			00 00		       HEX	0000
   6470  26d06							;tiles2
   6471  26d06			ff fd		       HEX	fffd
   6472  26d08
   6473  26e00					       ORG	$26E00,0	; *************
   6474  26e00
   6475  26e00					       RORG	$EE00	; *************
   6476  26e00
   6477  26e00							;playerSprite
   6478  26e00			ff ff		       HEX	ffff
   6479  26e02							;enemySprite
   6480  26e02			aa aa		       HEX	aaaa
   6481  26e04							;tiles0
   6482  26e04			00 00		       HEX	0000
   6483  26e06							;tiles2
   6484  26e06			ff fe		       HEX	fffe
   6485  26e08
   6486  26f00					       ORG	$26F00,0	; *************
   6487  26f00
   6488  26f00					       RORG	$EF00	; *************
   6489  26f00
   6490  26f00							;playerSprite
   6491  26f00			ff ff		       HEX	ffff
   6492  26f02							;enemySprite
   6493  26f02			aa aa		       HEX	aaaa
   6494  26f04							;tiles0
   6495  26f04			00 00		       HEX	0000
   6496  26f06							;tiles2
   6497  26f06			55 55		       HEX	5555
   6498  26f08				    tileMap_mult_lo
   6499  26f08			00		       .byte.b	<(tileMap+0)
   6500  26f09			ff		       .byte.b	<(tileMap+255)
   6501  26f0a			fe		       .byte.b	<(tileMap+510)
   6502  26f0b			fd		       .byte.b	<(tileMap+765)
   6503  26f0c			fc		       .byte.b	<(tileMap+1020)
   6504  26f0d			fb		       .byte.b	<(tileMap+1275)
   6505  26f0e			fa		       .byte.b	<(tileMap+1530)
   6506  26f0f			f9		       .byte.b	<(tileMap+1785)
   6507  26f10			f8		       .byte.b	<(tileMap+2040)
   6508  26f11			f7		       .byte.b	<(tileMap+2295)
   6509  26f12			f6		       .byte.b	<(tileMap+2550)
   6510  26f13			f5		       .byte.b	<(tileMap+2805)
   6511  26f14				    tileMap_mult_hi
   6512  26f14			40		       .byte.b	>(tileMap+0)
   6513  26f15			40		       .byte.b	>(tileMap+255)
   6514  26f16			41		       .byte.b	>(tileMap+510)
   6515  26f17			42		       .byte.b	>(tileMap+765)
   6516  26f18			43		       .byte.b	>(tileMap+1020)
   6517  26f19			44		       .byte.b	>(tileMap+1275)
   6518  26f1a			45		       .byte.b	>(tileMap+1530)
   6519  26f1b			46		       .byte.b	>(tileMap+1785)
   6520  26f1c			47		       .byte.b	>(tileMap+2040)
   6521  26f1d			48		       .byte.b	>(tileMap+2295)
   6522  26f1e			49		       .byte.b	>(tileMap+2550)
   6523  26f1f			4a		       .byte.b	>(tileMap+2805)
   6524  26f20				   -	       if	SPACEOVERFLOW > 0
   6525  26f20				   -	       echo	""
   6526  26f20				   -	       echo	"######## ERROR: space overflow detected in",[SPACEOVERFLOW]d,"areas."
   6527  26f20				   -	       echo	"######## look above for areas with negative ROM space left."
   6528  26f20				   -	       echo	"######## Aborting assembly."
   6529  26f20				   -	       ERR
   6530  26f20					       endif
   6531  26f20
   6532  26f20
   6533  26f20							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6534  26f20
   6535  26f20				   -	       ifnconst	bankswitchmode
   6536  26f20				   -	       if	( * < $f000 )
   6537  26f20				   -	       ORG	$F000
   6538  26f20				   -	       endif
   6539  26f20					       else
   6540  26f20					       ifconst	ROM128K
   6541  26f20					       if	( * < $f000 )
   6542  27000					       ORG	$27000
   6543  27000					       RORG	$F000
   6544  27000					       endif
   6545  27000					       endif
   6546  27000				   -	       ifconst	ROM144K
   6547  27000				   -	       if	( * < $f000 )
   6548  27000				   -	       ORG	$27000
   6549  27000				   -	       RORG	$F000
   6550  27000				   -	       endif
   6551  27000					       endif
   6552  27000				   -	       ifconst	ROM256K
   6553  27000				   -	       if	( * < $f000 )
   6554  27000				   -	       ORG	$47000
   6555  27000				   -	       RORG	$F000
   6556  27000				   -	       endif
   6557  27000					       endif
   6558  27000				   -	       ifconst	ROM272K
   6559  27000				   -	       if	( * < $f000 )
   6560  27000				   -	       ORG	$47000
   6561  27000				   -	       RORG	$F000
   6562  27000				   -	       endif
   6563  27000					       endif
   6564  27000				   -	       ifconst	ROM512K
   6565  27000				   -	       if	( * < $f000 )
   6566  27000				   -	       ORG	$87000
   6567  27000				   -	       RORG	$F000
   6568  27000				   -	       endif
   6569  27000					       endif
   6570  27000				   -	       ifconst	ROM528K
   6571  27000				   -	       if	( * < $f000 )
   6572  27000				   -	       ORG	$87000
   6573  27000				   -	       RORG	$F000
   6574  27000				   -	       endif
   6575  27000					       endif
   6576  27000					       endif
   6577  27000
   6578  27000							; all of these "modules" have conditional clauses in them, so even though
   6579  27000							; they're always included here, they don't take up rom unless the user
   6580  27000							; explicitly enables support for the feature.
   6581  27000
   6582  27000					       ifnconst	included.rmtplayer.asm
------- FILE rmtplayer.asm LEVEL 2 PASS 3
      0  27000					       include	rmtplayer.asm	; requires page alignment, so go first
      1  27000				   -	       ifconst	RMT
      2  27000				   -
      3  27000				   -rmtmodulestart
      4  27000				   -
      5  27000				   -			;*
      6  27000				   -			;* Raster Music Tracker, RMT Atari routine version 1.20030223
      7  27000				   -			;* (c) Radek Sterba, Raster/C.P.U., 2002 - 2003
      8  27000				   -			;* http://raster.atari.org
      9  27000				   -			;*
     10  27000				   -			;* Some small changes to allow using this code with DASM cross assembler and
     11  27000				   -			;* to compile for cartridge based systems, like the Atari 5200 or Atari 7800,
     12  27000				   -			;* by Eckhard Stolberg ( http://home.arcor.de/estolberg/ ).
     13  27000				   -			;*
     14  27000				   -			;* Warnings:
     15  27000				   -			;*
     16  27000				   -			;* 1. RMT player routine needs 19 itself reserved bytes in zero page (no accessed
     17  27000				   -			;*    from any other routines) as well as cca 1KB of memory before the "PLAYER"
     18  27000				   -			;*    address for frequency tables and functionary variables. It's:
     19  27000				   -			;*	  a) from PLAYER-$400 to PLAYER for stereo RMTplayer
     20  27000				   -			;*    b) from PLAYER-$380 to PLAYER for mono RMTplayer
     21  27000				   -			;*
     22  27000				   -			;* note: This has been changed for 5200 & 7800 compatibility. Now PLAYER points
     23  27000				   -			;*	  to the start of the frequency tables. The player routines follows after
     24  27000				   -			;*	  that. The variables are now independent and can be located with
     25  27000				   -			;*	  PLAYER_VAR_RAM and PLAYER_ZP_RAM (see below):
     26  27000				   -			;*
     27  27000				   -			;* 2. RMT player routine MUST (!!!) be compiled from the begin of the memory page.
     28  27000				   -			;*    i.e. "PLAYER" address can be $..00 only!
     29  27000				   -			;*
     30  27000				   -			;* 3. Because of RMTplayer provides a lot of effects, it spent a lot of CPU time.
     31  27000				   -			;*
     32  27000				   -			;*
     33  27000				   -			;* Define the following equates here or in your main code file.
     34  27000				   -			;* Set the values according to the system you compile for.
     35  27000				   -			;*
     36  27000				   -
     37  27000				   -POKEY_BASE equ	pokeyaddress
     38  27000				   -PLAYER_ZP_RAM equ	songchannel1layer1lo	; player routine needs 19 bytes of zero page RAM
     39  27000				   -PLAYER_VAR_RAM equ	RMTRAM	;variables in main RAM - 173 bytes mono - 337 stereo
     40  27000				   -ROM_BASED  equ	1	;using a ROM based system - no self modifying code
     41  27000				   -STEREO8T   equ	0	;0 => compile RMTplayer for mono 4 tracks
     42  27000				   -			;				    ;1 => compile RMTplayer for stereo 8 tracks
     43  27000				   -
     44  27000				   -rmt_ispeed equ	PLAYER_ZP_RAM+19
     45  27000				   -rmt_intcount equ	PLAYER_ZP_RAM+20
     46  27000				   -
     47  27000				   -			;*
     48  27000				   -
     49  27000				   -	       IF	STEREO8T
     50  27000				   -TRACKS     equ	8
     51  27000				   -	       ELSE
     52  27000				   -TRACKS     equ	4
     53  27000				   -	       EIF
     54  27000				   -
     55  27000				   -			;*
     56  27000				   -			;* RMT FEATures definitions
     57  27000				   -			;* For optimizations of RMT player routine to concrete RMT modul only!
     58  27000				   -			;* --------BEGIN--------
     59  27000				   -FEAT_COMMAND1 equ	1	;* cca 8 bytes
     60  27000				   -FEAT_COMMAND2 equ	1	;* cca 20 bytes (+save 1 address in zero page) and quicker whole RMT routine
     61  27000				   -FEAT_COMMAND3 equ	1	;* cca 12 bytes
     62  27000				   -FEAT_COMMAND4 equ	1	;* cca 15 bytes
     63  27000				   -FEAT_COMMAND5 equ	1	;* cca 67 bytes
     64  27000				   -FEAT_COMMAND6 equ	1	;* cca 15 bytes
     65  27000				   -			;* COMMAND7 SETNOTE (i.e. command 7 with parameter != $80)
     66  27000				   -FEAT_COMMAND7SETNOTE equ	1	;* cca 12 bytes
     67  27000				   -			;* COMMAND7 VOLUMEONLY (i.e. command 7 with parameter == $80)
     68  27000				   -FEAT_COMMAND7VOLUMEONLY equ	1	;* cca 74 bytes
     69  27000				   -			;* PORTAMENTO
     70  27000				   -FEAT_PORTAMENTO equ	1	;* cca 138 bytes and quicker whole RMT routine
     71  27000				   -			;* FILTER
     72  27000				   -FEAT_FILTER equ	1	;* cca 179 bytes and quicker whole RMT routine
     73  27000				   -FEAT_FILTERG0L equ	1	;* (cca 38 bytes for each)
     74  27000				   -FEAT_FILTERG1L equ	1
     75  27000				   -FEAT_FILTERG0R equ	1
     76  27000				   -FEAT_FILTERG1R equ	1
     77  27000				   -			;* BASS16B (i.e. distortion value 6)
     78  27000				   -FEAT_BASS16 equ	1	;* cca 194 bytes +128bytes freq table and quicker whole RMT routine
     79  27000				   -FEAT_BASS16G1L equ	1	;* (cca 47 bytes for each)
     80  27000				   -FEAT_BASS16G3L equ	1
     81  27000				   -FEAT_BASS16G1R equ	1
     82  27000				   -FEAT_BASS16G3R equ	1
     83  27000				   -			;* VOLUME ONLY for particular generators
     84  27000				   -FEAT_VOLUMEONLYG0L equ	1	;* (cca 7 bytes for each)
     85  27000				   -FEAT_VOLUMEONLYG2L equ	1
     86  27000				   -FEAT_VOLUMEONLYG3L equ	1
     87  27000				   -FEAT_VOLUMEONLYG0R equ	1
     88  27000				   -FEAT_VOLUMEONLYG2R equ	1
     89  27000				   -FEAT_VOLUMEONLYG3R equ	1
     90  27000				   -			;* TABLE TYPE (i.e. TABLETYPE=1)
     91  27000				   -FEAT_TABLETYPE equ	1	;* cca 53 bytes and quicker whole RMT routine
     92  27000				   -			;* TABLE MODE (i.e. TABLEMODE=1)
     93  27000				   -FEAT_TABLEMODE equ	1	;* cca 16 bytes and quicker whole RMT routine
     94  27000				   -			;* AUDCTLMANUALSET (i.e. any MANUAL AUDCTL setting to nonzero value)
     95  27000				   -FEAT_AUDCTLMANUALSET equ	1	;* cca 27 bytes and quicker whole RMT routine
     96  27000				   -			;* --------END--------
     97  27000				   -			;*
     98  27000				   -			;*
     99  27000				   -			;* RMT ZeroPage addresses
    100  27000				   -
    101  27000				   -MEMLOC     SET	PLAYER_ZP_RAM
    102  27000				   -p_tis      =	MEMLOC
    103  27000				   -p_instrstable =	MEMLOC
    104  27000				   -MEMLOC     SET	(MEMLOC+2)
    105  27000				   -p_trackslbstable =	MEMLOC
    106  27000				   -MEMLOC     SET	(MEMLOC+2)
    107  27000				   -p_trackshbstable =	MEMLOC
    108  27000				   -MEMLOC     SET	(MEMLOC+2)
    109  27000				   -p_song     =	MEMLOC
    110  27000				   -MEMLOC     SET	(MEMLOC+2)
    111  27000				   -
    112  27000				   -_ns        =	MEMLOC
    113  27000				   -MEMLOC     SET	(MEMLOC+2)
    114  27000				   -_nr        =	MEMLOC
    115  27000				   -MEMLOC     SET	(MEMLOC+2)
    116  27000				   -_nt        =	MEMLOC
    117  27000				   -MEMLOC     SET	(MEMLOC+2)
    118  27000				   -
    119  27000				   -rmtreg1    =	MEMLOC
    120  27000				   -MEMLOC     SET	(MEMLOC+1)
    121  27000				   -rmtreg2    =	MEMLOC
    122  27000				   -MEMLOC     SET	(MEMLOC+1)
    123  27000				   -rmtreg3    =	MEMLOC
    124  27000				   -MEMLOC     SET	(MEMLOC+1)
    125  27000				   -_tmp       =	MEMLOC
    126  27000				   -MEMLOC     SET	(MEMLOC+1)
    127  27000				   -	       IF	FEAT_COMMAND2
    128  27000				   -frqaddcmd2 =	MEMLOC
    129  27000				   -MEMLOC     SET	(MEMLOC+1)
    130  27000				   -	       EIF
    131  27000				   -
    132  27000				   -			;*
    133  27000				   -			;* Variables in main RAM used by player routine.
    134  27000				   -			;* 337 bytes for stereo - 173 bytes for mono
    135  27000				   -			;*
    136  27000				   -
    137  27000				   -MEMLOC     SET	PLAYER_VAR_RAM
    138  27000				   -track_variables =	MEMLOC
    139  27000				   -
    140  27000				   -trackn_db  =	MEMLOC
    141  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    142  27000				   -trackn_hb  =	MEMLOC
    143  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    144  27000				   -trackn_idx =	MEMLOC
    145  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    146  27000				   -trackn_pause =	MEMLOC
    147  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    148  27000				   -trackn_note =	MEMLOC
    149  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    150  27000				   -trackn_volume =	MEMLOC
    151  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    152  27000				   -trackn_distor =	MEMLOC
    153  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    154  27000				   -trackn_shiftfrq =	MEMLOC
    155  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    156  27000				   -
    157  27000				   -	       IF	FEAT_PORTAMENTO
    158  27000				   -trackn_portafrqc =	MEMLOC
    159  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    160  27000				   -trackn_portafrqa =	MEMLOC
    161  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    162  27000				   -trackn_portaspeed =	MEMLOC
    163  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    164  27000				   -trackn_portaspeeda =	MEMLOC
    165  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    166  27000				   -trackn_portadepth =	MEMLOC
    167  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    168  27000				   -	       EIF
    169  27000				   -
    170  27000				   -trackn_instrx2 =	MEMLOC
    171  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    172  27000				   -trackn_instrdb =	MEMLOC
    173  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    174  27000				   -trackn_instrhb =	MEMLOC
    175  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    176  27000				   -trackn_instridx =	MEMLOC
    177  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    178  27000				   -trackn_instrlen =	MEMLOC
    179  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    180  27000				   -trackn_instrlop =	MEMLOC
    181  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    182  27000				   -trackn_instrreachend =	MEMLOC
    183  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    184  27000				   -trackn_volumeslidedepth =	MEMLOC
    185  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    186  27000				   -trackn_volumeslidevalue =	MEMLOC
    187  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    188  27000				   -trackn_volumemin =	MEMLOC
    189  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    190  27000				   -trackn_effdelay =	MEMLOC
    191  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    192  27000				   -trackn_effvibratoa =	MEMLOC
    193  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    194  27000				   -trackn_effvibratobeg =	MEMLOC
    195  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    196  27000				   -trackn_effvibratoend =	MEMLOC
    197  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    198  27000				   -trackn_effshift =	MEMLOC
    199  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    200  27000				   -trackn_tabletypespeed =	MEMLOC
    201  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    202  27000				   -
    203  27000				   -	       IF	FEAT_TABLEMODE
    204  27000				   -trackn_tablemode =	MEMLOC
    205  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    206  27000				   -	       EIF
    207  27000				   -
    208  27000				   -trackn_tablenote =	MEMLOC
    209  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    210  27000				   -
    211  27000				   -trackn_tablea =	MEMLOC
    212  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    213  27000				   -trackn_tableend =	MEMLOC
    214  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    215  27000				   -trackn_tablelop =	MEMLOC
    216  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    217  27000				   -trackn_tablespeeda =	MEMLOC
    218  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    219  27000				   -trackn_command =	MEMLOC
    220  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    221  27000				   -
    222  27000				   -	       IF	FEAT_BASS16
    223  27000				   -trackn_outnote =	MEMLOC
    224  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    225  27000				   -	       EIF
    226  27000				   -	       IF	FEAT_FILTER
    227  27000				   -trackn_filter =	MEMLOC
    228  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    229  27000				   -	       EIF
    230  27000				   -
    231  27000				   -trackn_audf =	MEMLOC
    232  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    233  27000				   -trackn_audc =	MEMLOC
    234  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    235  27000				   -
    236  27000				   -	       IF	FEAT_AUDCTLMANUALSET
    237  27000				   -trackn_audctl =	MEMLOC
    238  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    239  27000				   -	       EIF
    240  27000				   -
    241  27000				   -v_audctl   =	MEMLOC
    242  27000				   -MEMLOC     SET	(MEMLOC+1)
    243  27000				   -v_audctl2  =	MEMLOC
    244  27000				   -MEMLOC     SET	(MEMLOC+1)
    245  27000				   -v_speed    =	MEMLOC
    246  27000				   -MEMLOC     SET	(MEMLOC+1)
    247  27000				   -v_aspeed   =	MEMLOC
    248  27000				   -MEMLOC     SET	(MEMLOC+1)
    249  27000				   -v_bspeed   =	MEMLOC
    250  27000				   -MEMLOC     SET	(MEMLOC+1)
    251  27000				   -v_instrspeed =	MEMLOC
    252  27000				   -MEMLOC     SET	(MEMLOC+1)
    253  27000				   -v_ainstrspeed =	MEMLOC
    254  27000				   -MEMLOC     SET	(MEMLOC+1)
    255  27000				   -v_maxtracklen =	MEMLOC
    256  27000				   -MEMLOC     SET	(MEMLOC+1)
    257  27000				   -v_abeat    =	MEMLOC
    258  27000				   -MEMLOC     SET	(MEMLOC+1)
    259  27000				   -
    260  27000				   -track_endvariables =	MEMLOC
    261  27000				   -
    262  27000				   -			;*
    263  27000				   -			;* Data tables used by player routine.
    264  27000				   -			;*
    265  27000				   -	       ALIGN	256
    266  27000				   -PLAYER     =	.
    267  27000				   -
    268  27000				   -volumetab
    269  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    270  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
    271  27000				   -	       dc.b	$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01,$02,$02,$02,$02
    272  27000				   -	       dc.b	$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02,$03,$03,$03
    273  27000				   -	       dc.b	$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03,$04,$04
    274  27000				   -	       dc.b	$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
    275  27000				   -	       dc.b	$00,$00,$01,$01,$02,$02,$02,$03,$03,$04,$04,$04,$05,$05,$06,$06
    276  27000				   -	       dc.b	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
    277  27000				   -	       dc.b	$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07,$08
    278  27000				   -	       dc.b	$00,$01,$01,$02,$02,$03,$04,$04,$05,$05,$06,$07,$07,$08,$08,$09
    279  27000				   -	       dc.b	$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$07,$07,$08,$09,$09,$0A
    280  27000				   -	       dc.b	$00,$01,$01,$02,$03,$04,$04,$05,$06,$07,$07,$08,$09,$0A,$0A,$0B
    281  27000				   -	       dc.b	$00,$01,$02,$02,$03,$04,$05,$06,$06,$07,$08,$09,$0A,$0A,$0B,$0C
    282  27000				   -	       dc.b	$00,$01,$02,$03,$03,$04,$05,$06,$07,$08,$09,$0A,$0A,$0B,$0C,$0D
    283  27000				   -	       dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0A,$0B,$0C,$0D,$0E
    284  27000				   -	       dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0A,$0B,$0C,$0D,$0E,$0F
    285  27000				   -
    286  27000				   -frqtab
    287  27000				   -			;	ERT [<frqtab]!=0	;* frqtab must begin at the memory page bound! (i.e. $..00 address)
    288  27000				   -frqtabbass1
    289  27000				   -	       dc.b	$BF,$B6,$AA,$A1,$98,$8F,$89,$80,$F2,$E6,$DA,$CE,$BF,$B6,$AA,$A1
    290  27000				   -	       dc.b	$98,$8F,$89,$80,$7A,$71,$6B,$65,$5F,$5C,$56,$50,$4D,$47,$44,$3E
    291  27000				   -	       dc.b	$3C,$38,$35,$32,$2F,$2D,$2A,$28,$25,$23,$21,$1F,$1D,$1C,$1A,$18
    292  27000				   -	       dc.b	$17,$16,$14,$13,$12,$11,$10,$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07
    293  27000				   -frqtabbass2
    294  27000				   -	       dc.b	$FF,$F1,$E4,$D8,$CA,$C0,$B5,$AB,$A2,$99,$8E,$87,$7F,$79,$73,$70
    295  27000				   -	       dc.b	$66,$61,$5A,$55,$52,$4B,$48,$43,$3F,$3C,$39,$37,$33,$30,$2D,$2A
    296  27000				   -	       dc.b	$28,$25,$24,$21,$1F,$1E,$1C,$1B,$19,$17,$16,$15,$13,$12,$11,$10
    297  27000				   -	       dc.b	$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00
    298  27000				   -frqtabpure
    299  27000				   -	       dc.b	$F3,$E6,$D9,$CC,$C1,$B5,$AD,$A2,$99,$90,$88,$80,$79,$72,$6C,$66
    300  27000				   -	       dc.b	$60,$5B,$55,$51,$4C,$48,$44,$40,$3C,$39,$35,$32,$2F,$2D,$2A,$28
    301  27000				   -	       dc.b	$25,$23,$21,$1F,$1D,$1C,$1A,$18,$17,$16,$14,$13,$12,$11,$10,$0F
    302  27000				   -	       dc.b	$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00,$00
    303  27000				   -	       IF	FEAT_BASS16
    304  27000				   -frqtabbasshi
    305  27000				   -	       dc.b	$0D,$0D,$0C,$0B,$0B,$0A,$0A,$09,$08,$08,$07,$07,$07,$06,$06,$05
    306  27000				   -	       dc.b	$05,$05,$04,$04,$04,$04,$03,$03,$03,$03,$03,$02,$02,$02,$02,$02
    307  27000				   -	       dc.b	$02,$02,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$00,$00
    308  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    309  27000				   -	       EIF
    310  27000				   -
    311  27000				   -	       IF	FEAT_BASS16
    312  27000				   -frqtabbasslo
    313  27000				   -	       dc.b	$F2,$33,$96,$E2,$38,$8C,$00,$6A,$E8,$6A,$EF,$80,$08,$AE,$46,$E6
    314  27000				   -	       dc.b	$95,$41,$F6,$B0,$6E,$30,$F6,$BB,$84,$52,$22,$F4,$C8,$A0,$7A,$55
    315  27000				   -	       dc.b	$34,$14,$F5,$D8,$BD,$A4,$8D,$77,$60,$4E,$38,$27,$15,$06,$F7,$E8
    316  27000				   -	       dc.b	$DB,$CF,$C3,$B8,$AC,$A2,$9A,$90,$88,$7F,$78,$70,$6A,$64,$5E,$00
    317  27000				   -	       EIF
    318  27000				   -
    319  27000				   -	       IF	ROM_BASED
    320  27000				   -rts_tab    dc.w	cmd0-1,cmd1-1,cmd2-1,cmd3-1,cmd4-1,cmd5-1,cmd6-1,cmd7-1
    321  27000				   -	       EIF
    322  27000				   -INSTRPAR   equ	12
    323  27000				   -tabbeganddistor
    324  27000				   -	       dc.b	frqtabpure-frqtab,$00
    325  27000				   -	       dc.b	frqtabpure-frqtab,$20
    326  27000				   -	       dc.b	frqtabpure-frqtab,$40
    327  27000				   -	       dc.b	frqtabbass1-frqtab,$c0
    328  27000				   -	       dc.b	frqtabpure-frqtab,$80
    329  27000				   -	       dc.b	frqtabpure-frqtab,$a0
    330  27000				   -	       dc.b	frqtabbass1-frqtab,$c0
    331  27000				   -	       dc.b	frqtabbass2-frqtab,$c0
    332  27000				   -vibtabbeg  dc.b	0,vib1-vib0,vib2-vib0,vib3-vib0,vibx-vib0
    333  27000				   -vib0       dc.b	0
    334  27000				   -vib1       dc.b	1,-1,-1,1
    335  27000				   -vib2       dc.b	1,0,-1,-1,0,1
    336  27000				   -vib3       dc.b	1,1,0,-1,-1,-1,-1,0,1,1
    337  27000				   -vibx
    338  27000				   -emptytrack
    339  27000				   -	       dc.b	62,0
    340  27000				   -
    341  27000				   -			;*
    342  27000				   -			;* Set of RMT main vectors:
    343  27000				   -			;*
    344  27000				   -RASTERMUSICTRACKER
    345  27000				   -	       jmp	rmt_init
    346  27000				   -	       jmp	rmt_play
    347  27000				   -	       jmp	rmt_p3
    348  27000				   -	       jmp	rmt_silence
    349  27000				   -	       jmp	SetPokey
    350  27000				   -rmt_init
    351  27000				   -	       stx	_ns
    352  27000				   -	       sty	_ns+1
    353  27000				   -	       pha
    354  27000				   -	       IF	track_endvariables-track_variables>255
    355  27000				   -	       ldy	#0
    356  27000				   -	       tya
    357  27000				   -rmtri0     sta	track_variables,y
    358  27000				   -	       sta	track_endvariables-$100,y
    359  27000				   -	       iny
    360  27000				   -	       bne	rmtri0
    361  27000				   -	       ELSE
    362  27000				   -	       ldy	#track_endvariables-track_variables
    363  27000				   -	       lda	#0
    364  27000				   -rmtri0     sta	track_variables-1,y
    365  27000				   -	       dey
    366  27000				   -	       bne	rmtri0
    367  27000				   -	       EIF
    368  27000				   -	       ldy	#4
    369  27000				   -	       lda	(_ns),y
    370  27000				   -	       sta	v_maxtracklen
    371  27000				   -	       iny
    372  27000				   -	       lda	(_ns),y
    373  27000				   -	       sta	v_speed
    374  27000				   -	       iny
    375  27000				   -	       lda	(_ns),y
    376  27000				   -	       sta	v_instrspeed
    377  27000				   -	       sta	v_ainstrspeed
    378  27000				   -	       ldy	#8
    379  27000				   -rmtri1     lda	(_ns),y
    380  27000				   -	       sta	p_tis-8,y
    381  27000				   -	       iny
    382  27000				   -	       cpy	#8+8
    383  27000				   -	       bne	rmtri1
    384  27000				   -	       pla
    385  27000				   -	       pha
    386  27000				   -	       IF	STEREO8T
    387  27000				   -	       asl
    388  27000				   -	       asl
    389  27000				   -	       asl
    390  27000				   -	       clc
    391  27000				   -	       adc	p_song
    392  27000				   -	       sta	p_song
    393  27000				   -	       pla
    394  27000				   -	       and	#$e0
    395  27000				   -	       asl
    396  27000				   -	       rol
    397  27000				   -	       rol
    398  27000				   -	       rol
    399  27000				   -	       ELSE
    400  27000				   -	       asl
    401  27000				   -	       asl
    402  27000				   -	       clc
    403  27000				   -	       adc	p_song
    404  27000				   -	       sta	p_song
    405  27000				   -	       pla
    406  27000				   -	       and	#$c0
    407  27000				   -	       asl
    408  27000				   -	       rol
    409  27000				   -	       rol
    410  27000				   -	       EIF
    411  27000				   -	       adc	p_song+1
    412  27000				   -	       sta	p_song+1
    413  27000				   -	       jsr	GetSongLine
    414  27000				   -	       jsr	GetTrackLine
    415  27000				   -	       jsr	InitOfNewSetInstrumentsOnly
    416  27000				   -	       jsr	rmt_silence
    417  27000				   -	       lda	v_instrspeed
    418  27000				   -	       rts
    419  27000				   -rmt_silence
    420  27000				   -	       IF	STEREO8T
    421  27000				   -	       lda	#0
    422  27000				   -	       sta	POKEY_BASE+$08
    423  27000				   -	       sta	POKEY_BASE_S+$08
    424  27000				   -	       ldy	#3
    425  27000				   -	       sty	POKEY_BASE+$0f
    426  27000				   -	       sty	POKEY_BASE_S+$0f
    427  27000				   -	       ldy	#8
    428  27000				   -rmtsi1     sta	POKEY_BASE+$00,y
    429  27000				   -	       sta	POKEY_BASE_S+$00,y
    430  27000				   -	       dey
    431  27000				   -	       bpl	rmtsi1
    432  27000				   -	       ELSE
    433  27000				   -	       lda	#0
    434  27000				   -	       sta	POKEY_BASE+$08
    435  27000				   -	       ldy	#3
    436  27000				   -	       sty	POKEY_BASE+$0f
    437  27000				   -	       ldy	#8
    438  27000				   -rmtsi1     sta	POKEY_BASE+$00,y
    439  27000				   -	       dey
    440  27000				   -	       bpl	rmtsi1
    441  27000				   -	       EIF
    442  27000				   -	       rts
    443  27000				   -GetSongLine
    444  27000				   -	       ldx	#0
    445  27000				   -	       stx	v_abeat
    446  27000				   -rmtnn0
    447  27000				   -	       ldx	#0
    448  27000				   -rmtnn1     txa
    449  27000				   -	       tay
    450  27000				   -	       lda	(p_song),y
    451  27000				   -	       cmp	#$fe
    452  27000				   -	       bcs	rmtnn2
    453  27000				   -	       tay
    454  27000				   -	       lda	(p_trackslbstable),y
    455  27000				   -	       sta	trackn_db,x
    456  27000				   -	       lda	(p_trackshbstable),y
    457  27000				   -rmtnn1a    sta	trackn_hb,x
    458  27000				   -	       lda	#0
    459  27000				   -	       sta	trackn_idx,x
    460  27000				   -	       lda	#1
    461  27000				   -	       sta	trackn_pause,x
    462  27000				   -	       lda	#$80
    463  27000				   -	       sta	trackn_instrx2,x
    464  27000				   -	       inx
    465  27000				   -	       cpx	#TRACKS
    466  27000				   -	       bne	rmtnn1
    467  27000				   -	       lda	p_song
    468  27000				   -	       clc
    469  27000				   -	       adc	#TRACKS
    470  27000				   -	       sta	p_song
    471  27000				   -	       bcc	rmtnn1b
    472  27000				   -	       inc	p_song+1
    473  27000				   -rmtnn1b
    474  27000				   -	       rts
    475  27000				   -rmtnn2
    476  27000				   -	       beq	rmtnn3
    477  27000				   -rmtnn2a    lda	#<emptytrack
    478  27000				   -	       sta	trackn_db,x
    479  27000				   -	       lda	#>emptytrack
    480  27000				   -	       jmp	rmtnn1a
    481  27000				   -rmtnn3
    482  27000				   -	       ldy	#2
    483  27000				   -	       lda	(p_song),y
    484  27000				   -	       tax
    485  27000				   -	       iny
    486  27000				   -	       lda	(p_song),y
    487  27000				   -	       sta	p_song+1
    488  27000				   -	       stx	p_song
    489  27000				   -	       jmp	rmtnn0
    490  27000				   -GetTrackLine
    491  27000				   -rmtoo0
    492  27000				   -rmtoo0a
    493  27000				   -	       lda	v_speed
    494  27000				   -	       sta	v_bspeed
    495  27000				   -	       ldx	#0
    496  27000				   -rmtoo1
    497  27000				   -	       lda	trackn_pause,x
    498  27000				   -	       beq	rmtoo1x
    499  27000				   -	       dec	trackn_pause,x
    500  27000				   -	       bne	rmtoo1x
    501  27000				   -	       inc	trackn_pause,x
    502  27000				   -rmtoo1b
    503  27000				   -	       lda	trackn_db,x
    504  27000				   -	       sta	_ns
    505  27000				   -	       lda	trackn_hb,x
    506  27000				   -	       sta	_ns+1
    507  27000				   -rmtoo1i
    508  27000				   -	       ldy	trackn_idx,x
    509  27000				   -	       lda	(_ns),y
    510  27000				   -	       sta	rmtreg1
    511  27000				   -	       iny
    512  27000				   -	       lda	(_ns),y
    513  27000				   -	       sta	rmtreg2
    514  27000				   -	       iny
    515  27000				   -	       tya
    516  27000				   -	       sta	trackn_idx,x
    517  27000				   -	       lda	rmtreg1
    518  27000				   -	       and	#$3f
    519  27000				   -	       cmp	#61
    520  27000				   -	       beq	rmtoo1a
    521  27000				   -	       bcs	rmtoo2
    522  27000				   -	       sta	trackn_note,x
    523  27000				   -	       IF	FEAT_BASS16
    524  27000				   -	       sta	trackn_outnote,x
    525  27000				   -	       EIF
    526  27000				   -	       lda	rmtreg2
    527  27000				   -	       lsr
    528  27000				   -	       and	#$3f*2
    529  27000				   -	       sta	trackn_instrx2,x
    530  27000				   -rmtoo1a    lda	rmtreg2
    531  27000				   -	       lsr
    532  27000				   -	       ror	rmtreg1
    533  27000				   -	       lsr
    534  27000				   -	       ror	rmtreg1
    535  27000				   -	       lda	rmtreg1
    536  27000				   -	       and	#$f0
    537  27000				   -	       sta	trackn_volume,x
    538  27000				   -rmtoo1x
    539  27000				   -	       inx
    540  27000				   -	       cpx	#TRACKS
    541  27000				   -	       bne	rmtoo1
    542  27000				   -	       lda	v_bspeed
    543  27000				   -	       sta	v_speed
    544  27000				   -	       sta	v_aspeed
    545  27000				   -	       rts
    546  27000				   -rmtoo2
    547  27000				   -	       cmp	#63
    548  27000				   -	       beq	rmtoo63
    549  27000				   -	       lda	rmtreg1
    550  27000				   -	       and	#$c0
    551  27000				   -	       beq	rmtoo62_b
    552  27000				   -	       asl
    553  27000				   -	       rol
    554  27000				   -	       rol
    555  27000				   -	       sta	trackn_pause,x
    556  27000				   -	       dec	trackn_idx,x
    557  27000				   -	       jmp	rmtoo1x
    558  27000				   -rmtoo62_b
    559  27000				   -	       lda	rmtreg2
    560  27000				   -	       sta	trackn_pause,x
    561  27000				   -	       jmp	rmtoo1x
    562  27000				   -rmtoo63
    563  27000				   -	       lda	rmtreg1
    564  27000				   -	       bmi	rmtoo63_1X
    565  27000				   -	       lda	rmtreg2
    566  27000				   -	       sta	v_bspeed
    567  27000				   -	       jmp	rmtoo1i
    568  27000				   -rmtoo63_1X
    569  27000				   -	       cmp	#255
    570  27000				   -	       beq	rmtoo63_11
    571  27000				   -	       lda	rmtreg2
    572  27000				   -	       sta	trackn_idx,x
    573  27000				   -	       jmp	rmtoo1i
    574  27000				   -rmtoo63_11
    575  27000				   -	       jsr	GetSongLine
    576  27000				   -	       jmp	rmtoo0
    577  27000				   -InitOfNewSetInstrumentsOnly
    578  27000				   -	       ldx	#0
    579  27000				   -p2x1       ldy	trackn_instrx2,x
    580  27000				   -	       bmi	p2x2
    581  27000				   -	       jsr	SetUpInstrumentY2
    582  27000				   -	       lda	#$80
    583  27000				   -	       sta	trackn_instrx2,x
    584  27000				   -p2x2
    585  27000				   -	       inx
    586  27000				   -	       cpx	#TRACKS
    587  27000				   -	       bne	p2x1
    588  27000				   -	       rts
    589  27000				   -rmt_play
    590  27000				   -rmt_p0
    591  27000				   -	       jsr	SetPokey
    592  27000				   -rmt_p1
    593  27000				   -	       dec	v_ainstrspeed
    594  27000				   -	       beq	rmtp1a
    595  27000				   -	       jmp	rmt_p3
    596  27000				   -rmtp1a
    597  27000				   -	       lda	v_instrspeed
    598  27000				   -	       sta	v_ainstrspeed
    599  27000				   -rmt_p2
    600  27000				   -	       dec	v_aspeed
    601  27000				   -	       bne	rmt_p3
    602  27000				   -	       inc	v_abeat
    603  27000				   -	       lda	v_abeat
    604  27000				   -	       cmp	v_maxtracklen
    605  27000				   -	       bne	rmtp2o2
    606  27000				   -	       jsr	GetSongLine
    607  27000				   -rmtp2o2
    608  27000				   -	       jsr	GetTrackLine
    609  27000				   -	       jmp	rmt_p2X
    610  27000				   -go_ppnext  jmp	ppnext
    611  27000				   -rmt_p2X
    612  27000				   -	       jsr	InitOfNewSetInstrumentsOnly
    613  27000				   -rmt_p3
    614  27000				   -	       lda	#>frqtab
    615  27000				   -	       sta	_nr+1
    616  27000				   -	       ldx	#0
    617  27000				   -rmtpp1
    618  27000				   -	       lda	trackn_instrhb,x
    619  27000				   -	       beq	go_ppnext
    620  27000				   -	       sta	_ns+1
    621  27000				   -	       lda	trackn_instrdb,x
    622  27000				   -	       sta	_ns
    623  27000				   -	       ldy	trackn_instridx,x
    624  27000				   -	       lda	(_ns),y
    625  27000				   -	       sta	rmtreg1
    626  27000				   -	       iny
    627  27000				   -	       lda	(_ns),y
    628  27000				   -	       sta	rmtreg2
    629  27000				   -	       iny
    630  27000				   -	       lda	(_ns),y
    631  27000				   -	       sta	rmtreg3
    632  27000				   -	       iny
    633  27000				   -	       tya
    634  27000				   -	       cmp	trackn_instrlen,x
    635  27000				   -	       bcc	rmtpp2
    636  27000				   -	       beq	rmtpp2
    637  27000				   -	       lda	#$80
    638  27000				   -	       sta	trackn_instrreachend,x
    639  27000				   -rmtpp1b
    640  27000				   -	       lda	trackn_instrlop,x
    641  27000				   -rmtpp2     sta	trackn_instridx,x
    642  27000				   -	       lda	rmtreg1
    643  27000				   -	       IF	STEREO8T
    644  27000				   -	       cpx	#4
    645  27000				   -	       bcc	rmtpp2s
    646  27000				   -	       lsr
    647  27000				   -	       lsr
    648  27000				   -	       lsr
    649  27000				   -	       lsr
    650  27000				   -rmtpp2s
    651  27000				   -	       EIF
    652  27000				   -	       and	#$0f
    653  27000				   -	       ora	trackn_volume,x
    654  27000				   -	       tay
    655  27000				   -	       lda	volumetab,y
    656  27000				   -	       pha
    657  27000				   -	       lda	rmtreg2
    658  27000				   -	       and	#$0e
    659  27000				   -	       tay
    660  27000				   -	       lda	tabbeganddistor,y
    661  27000				   -	       sta	_nr
    662  27000				   -	       pla
    663  27000				   -	       ora	tabbeganddistor+1,y
    664  27000				   -	       sta	trackn_audc,x
    665  27000				   -	       jmp	InstrumentsEffects
    666  27000				   -returnfromInstrumentsEffects
    667  27000				   -	       IF	FEAT_COMMAND2
    668  27000				   -	       lda	#0
    669  27000				   -	       sta	frqaddcmd2
    670  27000				   -	       EIF
    671  27000				   -	       lda	rmtreg2
    672  27000				   -	       sta	trackn_command,x
    673  27000				   -	       and	#$70
    674  27000				   -	       lsr
    675  27000				   -	       lsr
    676  27000				   -	       IF	ROM_BASED
    677  27000				   -	       lsr
    678  27000				   -	       tay
    679  27000				   -	       lda	rts_tab+1,y
    680  27000				   -	       pha
    681  27000				   -	       lda	rts_tab,y
    682  27000				   -	       pha
    683  27000				   -	       rts
    684  27000				   -	       ELSE
    685  27000				   -	       sta	jmx+1
    686  27000				   -jmx        bcc	*
    687  27000				   -	       jmp	cmd0
    688  27000				   -	       nop
    689  27000				   -	       jmp	cmd1
    690  27000				   -	       nop
    691  27000				   -	       jmp	cmd2
    692  27000				   -	       nop
    693  27000				   -	       jmp	cmd3
    694  27000				   -	       nop
    695  27000				   -	       jmp	cmd4
    696  27000				   -	       nop
    697  27000				   -	       jmp	cmd5
    698  27000				   -	       nop
    699  27000				   -	       jmp	cmd6
    700  27000				   -	       nop
    701  27000				   -	       jmp	cmd7
    702  27000				   -	       EIF
    703  27000				   -cmd0
    704  27000				   -	       lda	trackn_note,x
    705  27000				   -	       clc
    706  27000				   -	       adc	rmtreg3
    707  27000				   -cmd0a
    708  27000				   -	       IF	FEAT_TABLETYPE
    709  27000				   -	       ldy	trackn_tabletypespeed,x
    710  27000				   -	       bmi	cmd0b
    711  27000				   -	       EIF
    712  27000				   -	       clc
    713  27000				   -	       adc	trackn_tablenote,x
    714  27000				   -	       cmp	#61
    715  27000				   -	       bcc	cmd0a1
    716  27000				   -	       lda	#0
    717  27000				   -	       sta	trackn_audc,x
    718  27000				   -	       lda	#63
    719  27000				   -cmd0a1
    720  27000				   -	       IF	FEAT_BASS16
    721  27000				   -	       sta	trackn_outnote,x
    722  27000				   -	       EIF
    723  27000				   -	       tay
    724  27000				   -	       lda	(_nr),y
    725  27000				   -	       clc
    726  27000				   -	       adc	trackn_shiftfrq,x
    727  27000				   -	       IF	FEAT_COMMAND2
    728  27000				   -	       clc
    729  27000				   -	       adc	frqaddcmd2
    730  27000				   -	       EIF
    731  27000				   -	       sta	trackn_audf,x
    732  27000				   -	       jmp	rmtpp9
    733  27000				   -	       IF	FEAT_TABLETYPE
    734  27000				   -cmd0b
    735  27000				   -	       cmp	#61
    736  27000				   -	       bcc	cmd0b1
    737  27000				   -	       lda	#0
    738  27000				   -	       sta	trackn_audc,x
    739  27000				   -	       lda	#63
    740  27000				   -cmd0b1
    741  27000				   -	       tay
    742  27000				   -	       lda	trackn_shiftfrq,x
    743  27000				   -	       clc
    744  27000				   -	       adc	trackn_tablenote,x
    745  27000				   -	       clc
    746  27000				   -	       adc	(_nr),y
    747  27000				   -	       IF	FEAT_COMMAND2
    748  27000				   -	       clc
    749  27000				   -	       adc	frqaddcmd2
    750  27000				   -	       EIF
    751  27000				   -	       sta	trackn_audf,x
    752  27000				   -	       jmp	rmtpp9
    753  27000				   -	       EIF
    754  27000				   -cmd1
    755  27000				   -	       IF	FEAT_COMMAND1
    756  27000				   -	       lda	rmtreg3
    757  27000				   -	       sta	trackn_audf,x
    758  27000				   -	       jmp	rmtpp9
    759  27000				   -	       EIF
    760  27000				   -cmd2
    761  27000				   -	       IF	FEAT_COMMAND2
    762  27000				   -	       lda	rmtreg3
    763  27000				   -	       sta	frqaddcmd2
    764  27000				   -	       lda	trackn_note,x
    765  27000				   -	       jmp	cmd0a
    766  27000				   -	       EIF
    767  27000				   -cmd3
    768  27000				   -	       IF	FEAT_COMMAND3
    769  27000				   -	       lda	trackn_note,x
    770  27000				   -	       clc
    771  27000				   -	       adc	rmtreg3
    772  27000				   -	       sta	trackn_note,x
    773  27000				   -	       jmp	cmd0a
    774  27000				   -	       EIF
    775  27000				   -cmd4
    776  27000				   -	       IF	FEAT_COMMAND4
    777  27000				   -	       lda	trackn_shiftfrq,x
    778  27000				   -	       clc
    779  27000				   -	       adc	rmtreg3
    780  27000				   -	       sta	trackn_shiftfrq,x
    781  27000				   -	       lda	trackn_note,x
    782  27000				   -	       jmp	cmd0a
    783  27000				   -	       EIF
    784  27000				   -cmd5
    785  27000				   -	       IF	FEAT_COMMAND5&&FEAT_PORTAMENTO
    786  27000				   -	       IF	FEAT_TABLETYPE
    787  27000				   -	       lda	trackn_tabletypespeed,x
    788  27000				   -	       bpl	cmd5a1
    789  27000				   -	       ldy	trackn_note,x
    790  27000				   -	       lda	(_nr),y
    791  27000				   -	       clc
    792  27000				   -	       adc	trackn_tablenote,x
    793  27000				   -	       jmp	cmd5ax
    794  27000				   -	       EIF
    795  27000				   -cmd5a1
    796  27000				   -	       lda	trackn_note,x
    797  27000				   -	       clc
    798  27000				   -	       adc	trackn_tablenote,x
    799  27000				   -	       cmp	#61
    800  27000				   -	       bcc	cmd5a2
    801  27000				   -	       lda	#63
    802  27000				   -cmd5a2
    803  27000				   -	       tay
    804  27000				   -	       lda	(_nr),y
    805  27000				   -cmd5ax
    806  27000				   -	       sta	trackn_portafrqc,x
    807  27000				   -	       ldy	rmtreg3
    808  27000				   -	       bne	cmd5a
    809  27000				   -	       sta	trackn_portafrqa,x
    810  27000				   -cmd5a
    811  27000				   -	       tya
    812  27000				   -	       lsr
    813  27000				   -	       lsr
    814  27000				   -	       lsr
    815  27000				   -	       lsr
    816  27000				   -	       sta	trackn_portaspeed,x
    817  27000				   -	       sta	trackn_portaspeeda,x
    818  27000				   -	       lda	rmtreg3
    819  27000				   -	       and	#$0f
    820  27000				   -	       sta	trackn_portadepth,x
    821  27000				   -	       lda	trackn_note,x
    822  27000				   -	       jmp	cmd0a
    823  27000				   -	       ELSE
    824  27000				   -	       IF	FEAT_COMMAND5
    825  27000				   -	       jmp	rmtpp9
    826  27000				   -	       EIF
    827  27000				   -	       EIF
    828  27000				   -cmd6
    829  27000				   -	       IF	FEAT_COMMAND6&&FEAT_FILTER
    830  27000				   -	       lda	rmtreg3
    831  27000				   -	       clc
    832  27000				   -	       adc	trackn_filter,x
    833  27000				   -	       sta	trackn_filter,x
    834  27000				   -	       lda	trackn_note,x
    835  27000				   -	       jmp	cmd0a
    836  27000				   -	       ELSE
    837  27000				   -	       IF	FEAT_COMMAND6
    838  27000				   -	       jmp	rmtpp9
    839  27000				   -	       EIF
    840  27000				   -	       EIF
    841  27000				   -cmd7
    842  27000				   -	       IF	FEAT_COMMAND7SETNOTE||FEAT_COMMAND7VOLUMEONLY
    843  27000				   -	       IF	FEAT_COMMAND7SETNOTE
    844  27000				   -	       lda	rmtreg3
    845  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY
    846  27000				   -	       cmp	#$80
    847  27000				   -	       beq	cmd7a
    848  27000				   -	       EIF
    849  27000				   -	       sta	trackn_note,x
    850  27000				   -	       jmp	cmd0a
    851  27000				   -	       EIF
    852  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY
    853  27000				   -cmd7a
    854  27000				   -	       lda	trackn_audc,x
    855  27000				   -	       ora	#$f0
    856  27000				   -	       sta	trackn_audc,x
    857  27000				   -	       lda	trackn_note,x
    858  27000				   -	       jmp	cmd0a
    859  27000				   -	       EIF
    860  27000				   -	       EIF
    861  27000				   -rmtpp9
    862  27000				   -	       IF	FEAT_PORTAMENTO
    863  27000				   -	       lda	trackn_portaspeeda,x
    864  27000				   -	       beq	rmtpp10
    865  27000				   -	       sec
    866  27000				   -	       sbc	#1
    867  27000				   -	       sta	trackn_portaspeeda,x
    868  27000				   -	       bne	rmtpp10
    869  27000				   -	       lda	trackn_portaspeed,x
    870  27000				   -	       sta	trackn_portaspeeda,x
    871  27000				   -	       lda	trackn_portafrqa,x
    872  27000				   -	       cmp	trackn_portafrqc,x
    873  27000				   -	       beq	rmtpp10
    874  27000				   -	       bcs	pps1
    875  27000				   -	       adc	trackn_portadepth,x
    876  27000				   -	       bcs	pps8
    877  27000				   -	       cmp	trackn_portafrqc,x
    878  27000				   -	       bcs	pps8
    879  27000				   -	       jmp	pps9
    880  27000				   -pps1
    881  27000				   -	       sbc	trackn_portadepth,x
    882  27000				   -	       bcc	pps8
    883  27000				   -	       cmp	trackn_portafrqc,x
    884  27000				   -	       bcs	pps9
    885  27000				   -pps8
    886  27000				   -	       lda	trackn_portafrqc,x
    887  27000				   -pps9
    888  27000				   -	       sta	trackn_portafrqa,x
    889  27000				   -rmtpp10
    890  27000				   -	       lda	rmtreg2
    891  27000				   -	       and	#$01
    892  27000				   -	       beq	rmtpp11
    893  27000				   -	       lda	trackn_portafrqa,x
    894  27000				   -	       clc
    895  27000				   -	       adc	trackn_shiftfrq,x
    896  27000				   -	       sta	trackn_audf,x
    897  27000				   -rmtpp11
    898  27000				   -	       EIF
    899  27000				   -ppnext
    900  27000				   -	       inx
    901  27000				   -	       cpx	#TRACKS
    902  27000				   -	       beq	rmt_p4
    903  27000				   -	       jmp	rmtpp1
    904  27000				   -rmt_p4
    905  27000				   -	       IF	FEAT_AUDCTLMANUALSET
    906  27000				   -	       ldx	#3
    907  27000				   -	       lda	#0
    908  27000				   -qq0        ora	trackn_audctl,x
    909  27000				   -	       dex
    910  27000				   -	       bpl	qq0
    911  27000				   -	       sta	v_audctl
    912  27000				   -qq1
    913  27000				   -	       ldx	v_audctl
    914  27000				   -	       ELSE
    915  27000				   -	       ldx	#0
    916  27000				   -	       stx	v_audctl
    917  27000				   -	       EIF
    918  27000				   -	       IF	FEAT_FILTER
    919  27000				   -	       IF	FEAT_FILTERG0L
    920  27000				   -	       lda	trackn_command+0
    921  27000				   -	       bpl	qq2
    922  27000				   -	       lda	trackn_audc+0
    923  27000				   -	       and	#$0f
    924  27000				   -	       beq	qq2
    925  27000				   -	       lda	trackn_audf+0
    926  27000				   -	       clc
    927  27000				   -	       adc	trackn_filter+0
    928  27000				   -	       sta	trackn_audf+2
    929  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
    930  27000				   -	       lda	trackn_audc+2
    931  27000				   -	       and	#$10
    932  27000				   -	       bne	qq1a
    933  27000				   -	       EIF
    934  27000				   -	       lda	#0
    935  27000				   -	       sta	trackn_audc+2
    936  27000				   -qq1a
    937  27000				   -	       txa
    938  27000				   -	       ora	#4
    939  27000				   -	       tax
    940  27000				   -	       EIF
    941  27000				   -qq2
    942  27000				   -	       IF	FEAT_FILTERG1L
    943  27000				   -	       lda	trackn_command+1
    944  27000				   -	       bpl	qq3
    945  27000				   -	       lda	trackn_audc+1
    946  27000				   -	       and	#$0f
    947  27000				   -	       beq	qq3
    948  27000				   -	       lda	trackn_audf+1
    949  27000				   -	       clc
    950  27000				   -	       adc	trackn_filter+1
    951  27000				   -	       sta	trackn_audf+3
    952  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3L
    953  27000				   -	       lda	trackn_audc+3
    954  27000				   -	       and	#$10
    955  27000				   -	       bne	qq2a
    956  27000				   -	       EIF
    957  27000				   -	       lda	#0
    958  27000				   -	       sta	trackn_audc+3
    959  27000				   -qq2a
    960  27000				   -	       txa
    961  27000				   -	       ora	#2
    962  27000				   -	       tax
    963  27000				   -	       EIF
    964  27000				   -qq3
    965  27000				   -	       IF	FEAT_FILTERG0L||FEAT_FILTERG1L
    966  27000				   -	       cpx	v_audctl
    967  27000				   -	       bne	qq5
    968  27000				   -	       EIF
    969  27000				   -	       EIF
    970  27000				   -	       IF	FEAT_BASS16
    971  27000				   -	       IF	FEAT_BASS16G1L
    972  27000				   -	       lda	trackn_command+1
    973  27000				   -	       and	#$0e
    974  27000				   -	       cmp	#6
    975  27000				   -	       bne	qq4
    976  27000				   -	       lda	trackn_audc+1
    977  27000				   -	       and	#$0f
    978  27000				   -	       beq	qq4
    979  27000				   -	       ldy	trackn_outnote+1
    980  27000				   -	       lda	frqtabbasslo,y
    981  27000				   -	       sta	trackn_audf+0
    982  27000				   -	       lda	frqtabbasshi,y
    983  27000				   -	       sta	trackn_audf+1
    984  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0L
    985  27000				   -	       lda	trackn_audc+0
    986  27000				   -	       and	#$10
    987  27000				   -	       bne	qq3a
    988  27000				   -	       EIF
    989  27000				   -	       lda	#0
    990  27000				   -	       sta	trackn_audc+0
    991  27000				   -qq3a
    992  27000				   -	       txa
    993  27000				   -	       ora	#$50
    994  27000				   -	       tax
    995  27000				   -	       EIF
    996  27000				   -qq4
    997  27000				   -	       IF	FEAT_BASS16G3L
    998  27000				   -	       lda	trackn_command+3
    999  27000				   -	       and	#$0e
   1000  27000				   -	       cmp	#6
   1001  27000				   -	       bne	qq5
   1002  27000				   -	       lda	trackn_audc+3
   1003  27000				   -	       and	#$0f
   1004  27000				   -	       beq	qq5
   1005  27000				   -	       ldy	trackn_outnote+3
   1006  27000				   -	       lda	frqtabbasslo,y
   1007  27000				   -	       sta	trackn_audf+2
   1008  27000				   -	       lda	frqtabbasshi,y
   1009  27000				   -	       sta	trackn_audf+3
   1010  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
   1011  27000				   -	       lda	trackn_audc+2
   1012  27000				   -	       and	#$10
   1013  27000				   -	       bne	qq4a
   1014  27000				   -	       EIF
   1015  27000				   -	       lda	#0
   1016  27000				   -	       sta	trackn_audc+2
   1017  27000				   -qq4a
   1018  27000				   -	       txa
   1019  27000				   -	       ora	#$28
   1020  27000				   -	       tax
   1021  27000				   -	       EIF
   1022  27000				   -	       EIF
   1023  27000				   -qq5
   1024  27000				   -	       stx	v_audctl
   1025  27000				   -	       IF	STEREO8T
   1026  27000				   -	       IF	FEAT_AUDCTLMANUALSET
   1027  27000				   -	       ldx	#3
   1028  27000				   -	       lda	#0
   1029  27000				   -qs0        ora	trackn_audctl+4,x
   1030  27000				   -	       dex
   1031  27000				   -	       bpl	qs0
   1032  27000				   -	       sta	v_audctl2
   1033  27000				   -qs1
   1034  27000				   -	       ldx	v_audctl2
   1035  27000				   -	       ELSE
   1036  27000				   -	       ldx	#0
   1037  27000				   -	       stx	v_audctl2
   1038  27000				   -	       EIF
   1039  27000				   -	       IF	FEAT_FILTER
   1040  27000				   -	       IF	FEAT_FILTERG0R
   1041  27000				   -	       lda	trackn_command+0+4
   1042  27000				   -	       bpl	qs2
   1043  27000				   -	       lda	trackn_audc+0+4
   1044  27000				   -	       and	#$0f
   1045  27000				   -	       beq	qs2
   1046  27000				   -	       lda	trackn_audf+0+4
   1047  27000				   -	       clc
   1048  27000				   -	       adc	trackn_filter+0+4
   1049  27000				   -	       sta	trackn_audf+2+4
   1050  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1051  27000				   -	       lda	trackn_audc+2+4
   1052  27000				   -	       and	#$10
   1053  27000				   -	       bne	qs1a
   1054  27000				   -	       EIF
   1055  27000				   -	       lda	#0
   1056  27000				   -	       sta	trackn_audc+2+4
   1057  27000				   -qs1a
   1058  27000				   -	       txa
   1059  27000				   -	       ora	#4
   1060  27000				   -	       tax
   1061  27000				   -	       EIF
   1062  27000				   -qs2
   1063  27000				   -	       IF	FEAT_FILTERG1R
   1064  27000				   -	       lda	trackn_command+1+4
   1065  27000				   -	       bpl	qs3
   1066  27000				   -	       lda	trackn_audc+1+4
   1067  27000				   -	       and	#$0f
   1068  27000				   -	       beq	qs3
   1069  27000				   -	       lda	trackn_audf+1+4
   1070  27000				   -	       clc
   1071  27000				   -	       adc	trackn_filter+1+4
   1072  27000				   -	       sta	trackn_audf+3+4
   1073  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3R
   1074  27000				   -	       lda	trackn_audc+3+4
   1075  27000				   -	       and	#$10
   1076  27000				   -	       bne	qs2a
   1077  27000				   -	       EIF
   1078  27000				   -	       lda	#0
   1079  27000				   -	       sta	trackn_audc+3+4
   1080  27000				   -qs2a
   1081  27000				   -	       txa
   1082  27000				   -	       ora	#2
   1083  27000				   -	       tax
   1084  27000				   -	       EIF
   1085  27000				   -qs3
   1086  27000				   -	       IF	FEAT_FILTERG0R||FEAT_FILTERG1R
   1087  27000				   -	       cpx	v_audctl2
   1088  27000				   -	       bne	qs5
   1089  27000				   -	       EIF
   1090  27000				   -	       EIF
   1091  27000				   -	       IF	FEAT_BASS16
   1092  27000				   -	       IF	FEAT_BASS16G1R
   1093  27000				   -	       lda	trackn_command+1+4
   1094  27000				   -	       and	#$0e
   1095  27000				   -	       cmp	#6
   1096  27000				   -	       bne	qs4
   1097  27000				   -	       lda	trackn_audc+1+4
   1098  27000				   -	       and	#$0f
   1099  27000				   -	       beq	qs4
   1100  27000				   -	       ldy	trackn_outnote+1+4
   1101  27000				   -	       lda	frqtabbasslo,y
   1102  27000				   -	       sta	trackn_audf+0+4
   1103  27000				   -	       lda	frqtabbasshi,y
   1104  27000				   -	       sta	trackn_audf+1+4
   1105  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0R
   1106  27000				   -	       lda	trackn_audc+0+4
   1107  27000				   -	       and	#$10
   1108  27000				   -	       bne	qs3a
   1109  27000				   -	       EIF
   1110  27000				   -	       lda	#0
   1111  27000				   -	       sta	trackn_audc+0+4
   1112  27000				   -qs3a
   1113  27000				   -	       txa
   1114  27000				   -	       ora	#$50
   1115  27000				   -	       tax
   1116  27000				   -	       EIF
   1117  27000				   -qs4
   1118  27000				   -	       IF	FEAT_BASS16G3R
   1119  27000				   -	       lda	trackn_command+3+4
   1120  27000				   -	       and	#$0e
   1121  27000				   -	       cmp	#6
   1122  27000				   -	       bne	qs5
   1123  27000				   -	       lda	trackn_audc+3+4
   1124  27000				   -	       and	#$0f
   1125  27000				   -	       beq	qs5
   1126  27000				   -	       ldy	trackn_outnote+3+4
   1127  27000				   -	       lda	frqtabbasslo,y
   1128  27000				   -	       sta	trackn_audf+2+4
   1129  27000				   -	       lda	frqtabbasshi,y
   1130  27000				   -	       sta	trackn_audf+3+4
   1131  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1132  27000				   -	       lda	trackn_audc+2+4
   1133  27000				   -	       and	#$10
   1134  27000				   -	       bne	qs4a
   1135  27000				   -	       EIF
   1136  27000				   -	       lda	#0
   1137  27000				   -	       sta	trackn_audc+2+4
   1138  27000				   -qs4a
   1139  27000				   -	       txa
   1140  27000				   -	       ora	#$28
   1141  27000				   -	       tax
   1142  27000				   -	       EIF
   1143  27000				   -	       EIF
   1144  27000				   -qs5
   1145  27000				   -	       stx	v_audctl2
   1146  27000				   -	       EIF
   1147  27000				   -rmt_p5
   1148  27000				   -	       lda	v_ainstrspeed
   1149  27000				   -	       rts
   1150  27000				   -SetPokey
   1151  27000				   -	       IF	STEREO8T
   1152  27000				   -	       ldy	v_audctl2
   1153  27000				   -	       lda	trackn_audf+0+4
   1154  27000				   -	       ldx	trackn_audf+0
   1155  27000				   -	       sta	POKEY_BASE_S+$00
   1156  27000				   -	       stx	POKEY_BASE+$00
   1157  27000				   -	       lda	trackn_audc+0+4
   1158  27000				   -	       ldx	trackn_audc+0
   1159  27000				   -	       sta	POKEY_BASE_S+$01
   1160  27000				   -	       stx	POKEY_BASE+$01
   1161  27000				   -	       lda	trackn_audf+1+4
   1162  27000				   -	       ldx	trackn_audf+1
   1163  27000				   -	       sta	POKEY_BASE_S+$02
   1164  27000				   -	       stx	POKEY_BASE+$02
   1165  27000				   -	       lda	trackn_audc+1+4
   1166  27000				   -	       ldx	trackn_audc+1
   1167  27000				   -	       sta	POKEY_BASE_S+$03
   1168  27000				   -	       stx	POKEY_BASE+$03
   1169  27000				   -	       lda	trackn_audf+2+4
   1170  27000				   -	       ldx	trackn_audf+2
   1171  27000				   -	       sta	POKEY_BASE_S+$04
   1172  27000				   -	       stx	POKEY_BASE+$04
   1173  27000				   -	       lda	trackn_audc+2+4
   1174  27000				   -	       ldx	trackn_audc+2
   1175  27000				   -	       sta	POKEY_BASE_S+$05
   1176  27000				   -	       stx	POKEY_BASE+$05
   1177  27000				   -	       lda	trackn_audf+3+4
   1178  27000				   -	       ldx	trackn_audf+3
   1179  27000				   -	       sta	POKEY_BASE_S+$06
   1180  27000				   -	       stx	POKEY_BASE+$06
   1181  27000				   -	       lda	trackn_audc+3+4
   1182  27000				   -	       ldx	trackn_audc+3
   1183  27000				   -	       sta	POKEY_BASE_S+$07
   1184  27000				   -	       stx	POKEY_BASE+$07
   1185  27000				   -	       lda	v_audctl
   1186  27000				   -	       sty	POKEY_BASE_S+$08
   1187  27000				   -	       sta	POKEY_BASE+$08
   1188  27000				   -	       ELSE
   1189  27000				   -
   1190  27000				   -	       ifconst	RMTVOLUME
   1191  27000				   -	       lda	rmtvolume
   1192  27000				   -	       sta	fourbitfadevalueint
   1193  27000				   -	       endif
   1194  27000				   -	       ldy	v_audctl
   1195  27000				   -	       ldx	trackn_audf+0
   1196  27000				   -	       lda	trackn_audc+0
   1197  27000				   -	       ifconst	RMTVOLUME
   1198  27000				   -	       jsr	fourbitfadeint
   1199  27000				   -	       endif
   1200  27000				   -	       stx	POKEY_BASE+$00+0
   1201  27000				   -	       sta	POKEY_BASE+$01+0
   1202  27000				   -
   1203  27000				   -	       ldx	trackn_audf+1
   1204  27000				   -	       lda	trackn_audc+1
   1205  27000				   -	       ifconst	RMTVOLUME
   1206  27000				   -	       jsr	fourbitfadeint
   1207  27000				   -	       endif
   1208  27000				   -	       stx	POKEY_BASE+$00+2
   1209  27000				   -	       sta	POKEY_BASE+$01+2
   1210  27000				   -
   1211  27000				   -	       ldx	trackn_audf+2
   1212  27000				   -	       lda	trackn_audc+2
   1213  27000				   -	       ifconst	RMTVOLUME
   1214  27000				   -	       jsr	fourbitfadeint
   1215  27000				   -	       endif
   1216  27000				   -	       stx	POKEY_BASE+$00+4
   1217  27000				   -	       sta	POKEY_BASE+$01+4
   1218  27000				   -
   1219  27000				   -	       ldx	trackn_audf+3
   1220  27000				   -	       lda	trackn_audc+3
   1221  27000				   -	       ifconst	RMTVOLUME
   1222  27000				   -	       jsr	fourbitfadeint
   1223  27000				   -	       endif
   1224  27000				   -	       stx	POKEY_BASE+$00+6
   1225  27000				   -	       sta	POKEY_BASE+$01+6
   1226  27000				   -
   1227  27000				   -	       sty	POKEY_BASE+$08
   1228  27000				   -
   1229  27000				   -	       EIF
   1230  27000				   -	       rts
   1231  27000				   -SetUpInstrumentY2
   1232  27000				   -	       lda	(p_instrstable),y
   1233  27000				   -	       sta	trackn_instrdb,x
   1234  27000				   -	       sta	_nt
   1235  27000				   -	       iny
   1236  27000				   -	       lda	(p_instrstable),y
   1237  27000				   -	       sta	trackn_instrhb,x
   1238  27000				   -	       sta	_nt+1
   1239  27000				   -	       ldy	#0
   1240  27000				   -	       lda	(_nt),y
   1241  27000				   -	       sta	trackn_tableend,x
   1242  27000				   -	       clc
   1243  27000				   -	       adc	#1
   1244  27000				   -	       sta	trackn_instridx,x
   1245  27000				   -	       iny
   1246  27000				   -	       lda	(_nt),y
   1247  27000				   -	       sta	trackn_tablelop,x
   1248  27000				   -	       iny
   1249  27000				   -	       lda	(_nt),y
   1250  27000				   -	       sta	trackn_instrlen,x
   1251  27000				   -	       iny
   1252  27000				   -	       lda	(_nt),y
   1253  27000				   -	       sta	trackn_instrlop,x
   1254  27000				   -	       iny
   1255  27000				   -	       lda	(_nt),y
   1256  27000				   -	       sta	trackn_tabletypespeed,x
   1257  27000				   -	       IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1258  27000				   -	       and	#$3f
   1259  27000				   -	       EIF
   1260  27000				   -	       sta	trackn_tablespeeda,x
   1261  27000				   -	       IF	FEAT_TABLEMODE
   1262  27000				   -	       lda	(_nt),y
   1263  27000				   -	       and	#$40
   1264  27000				   -	       sta	trackn_tablemode,x
   1265  27000				   -	       EIF
   1266  27000				   -	       iny
   1267  27000				   -	       IF	FEAT_AUDCTLMANUALSET
   1268  27000				   -	       lda	(_nt),y
   1269  27000				   -	       sta	trackn_audctl,x
   1270  27000				   -	       EIF
   1271  27000				   -	       iny
   1272  27000				   -	       lda	(_nt),y
   1273  27000				   -	       sta	trackn_volumeslidedepth,x
   1274  27000				   -	       iny
   1275  27000				   -	       lda	(_nt),y
   1276  27000				   -	       sta	trackn_volumemin,x
   1277  27000				   -	       iny
   1278  27000				   -	       lda	(_nt),y
   1279  27000				   -	       sta	trackn_effdelay,x
   1280  27000				   -	       iny
   1281  27000				   -	       lda	(_nt),y
   1282  27000				   -	       tay
   1283  27000				   -	       lda	vibtabbeg,y
   1284  27000				   -	       sta	trackn_effvibratoa,x
   1285  27000				   -	       sta	trackn_effvibratobeg,x
   1286  27000				   -	       lda	vibtabbeg+1,y
   1287  27000				   -	       sta	trackn_effvibratoend,x
   1288  27000				   -	       ldy	#10
   1289  27000				   -	       lda	(_nt),y
   1290  27000				   -	       sta	trackn_effshift,x
   1291  27000				   -	       lda	#128
   1292  27000				   -	       sta	trackn_volumeslidevalue,x
   1293  27000				   -	       lda	#0
   1294  27000				   -	       sta	trackn_instrreachend,x
   1295  27000				   -	       sta	trackn_shiftfrq,x
   1296  27000				   -	       lda	#INSTRPAR
   1297  27000				   -	       sta	trackn_tablea,x
   1298  27000				   -	       tay
   1299  27000				   -	       lda	(_nt),y
   1300  27000				   -	       sta	trackn_tablenote,x
   1301  27000				   -	       IF	FEAT_FILTER
   1302  27000				   -	       lda	#1
   1303  27000				   -	       sta	trackn_filter,x
   1304  27000				   -	       EIF
   1305  27000				   -	       rts
   1306  27000				   -InstrumentsEffects
   1307  27000				   -	       lda	trackn_effdelay,x
   1308  27000				   -	       beq	ei2
   1309  27000				   -	       tay
   1310  27000				   -	       dey
   1311  27000				   -	       bne	ei1
   1312  27000				   -	       lda	trackn_shiftfrq,x
   1313  27000				   -	       clc
   1314  27000				   -	       adc	trackn_effshift,x
   1315  27000				   -	       clc
   1316  27000				   -	       ldy	trackn_effvibratoa,x
   1317  27000				   -	       adc	vib0,y
   1318  27000				   -	       sta	trackn_shiftfrq,x
   1319  27000				   -	       iny
   1320  27000				   -	       tya
   1321  27000				   -	       cmp	trackn_effvibratoend,x
   1322  27000				   -	       bne	ei1a
   1323  27000				   -	       lda	trackn_effvibratobeg,x
   1324  27000				   -ei1a
   1325  27000				   -	       sta	trackn_effvibratoa,x
   1326  27000				   -	       jmp	ei2
   1327  27000				   -ei1
   1328  27000				   -	       tya
   1329  27000				   -	       sta	trackn_effdelay,x
   1330  27000				   -ei2
   1331  27000				   -	       lda	trackn_tableend,x
   1332  27000				   -	       cmp	#INSTRPAR
   1333  27000				   -	       beq	ei3
   1334  27000				   -	       lda	trackn_tablespeeda,x
   1335  27000				   -	       bpl	ei2f
   1336  27000				   -ei2c
   1337  27000				   -	       lda	trackn_tablea,x
   1338  27000				   -	       clc
   1339  27000				   -	       adc	#1
   1340  27000				   -	       cmp	trackn_tableend,x
   1341  27000				   -	       bcc	ei2a
   1342  27000				   -	       beq	ei2a
   1343  27000				   -	       lda	trackn_tablelop,x
   1344  27000				   -ei2a
   1345  27000				   -	       sta	trackn_tablea,x
   1346  27000				   -	       lda	trackn_instrdb,x
   1347  27000				   -	       sta	_nt
   1348  27000				   -	       lda	trackn_instrhb,x
   1349  27000				   -	       sta	_nt+1
   1350  27000				   -	       ldy	trackn_tablea,x
   1351  27000				   -	       lda	(_nt),y
   1352  27000				   -	       IF	FEAT_TABLEMODE
   1353  27000				   -	       ldy	trackn_tablemode,x
   1354  27000				   -	       beq	ei2e
   1355  27000				   -	       clc
   1356  27000				   -	       adc	trackn_tablenote,x
   1357  27000				   -ei2e
   1358  27000				   -	       EIF
   1359  27000				   -	       sta	trackn_tablenote,x
   1360  27000				   -	       lda	trackn_tabletypespeed,x
   1361  27000				   -	       IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1362  27000				   -	       and	#$3f
   1363  27000				   -	       EIF
   1364  27000				   -ei2f
   1365  27000				   -	       sec
   1366  27000				   -	       sbc	#1
   1367  27000				   -	       sta	trackn_tablespeeda,x
   1368  27000				   -ei3
   1369  27000				   -	       lda	trackn_instrreachend,x
   1370  27000				   -	       bpl	ei4
   1371  27000				   -	       lda	trackn_volume,x
   1372  27000				   -	       beq	ei4
   1373  27000				   -	       cmp	trackn_volumemin,x
   1374  27000				   -	       beq	ei4
   1375  27000				   -	       bcc	ei4
   1376  27000				   -	       tay
   1377  27000				   -	       lda	trackn_volumeslidevalue,x
   1378  27000				   -	       clc
   1379  27000				   -	       adc	trackn_volumeslidedepth,x
   1380  27000				   -	       sta	trackn_volumeslidevalue,x
   1381  27000				   -	       bcc	ei4
   1382  27000				   -	       tya
   1383  27000				   -	       sbc	#16
   1384  27000				   -	       sta	trackn_volume,x
   1385  27000				   -ei4
   1386  27000				   -	       jmp	returnfromInstrumentsEffects
   1387  27000				   -
   1388  27000				   -rmtmoduleend
   1389  27000				   -	       echo	"  (rmtplayer module is using ",[(rmtmoduleend-rmtmodulestart)]d," bytes)"
   1390  27000				   -
   1391  27000					       endif		; RMT
------- FILE c:\Users\Jag\Desktop\plotmap scrolling doublebuffer\test.78b.asm
   6584  27000					       endif
   6585  27000					       ifnconst	included.7800vox.asm
------- FILE 7800vox.asm LEVEL 2 PASS 3
      0  27000					       include	7800vox.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000							; AtariVox 7800basic wrapper
      4  27000
      5  27000							; to be called with
      6  27000							; A=# of bytes
      7  27000							;
      8  27000
      9  27000				   -	       ifconst	HSSUPPORT
     10  27000				   -
     11  27000				   -_7800voxstart
     12  27000				   -
     13  27000				   -AVoxReadBytes
     14  27000				   -	       sta	temp8
     15  27000				   -	       jsr	i2c_startwrite
     16  27000				   -	       bcs	eeprom_error
     17  27000				   -
     18  27000				   -	       lda	HSVoxHi
     19  27000				   -	       jsr	i2c_txbyte
     20  27000				   -	       lda	HSVoxLo
     21  27000				   -	       jsr	i2c_txbyte
     22  27000				   -	       jsr	i2c_stopwrite
     23  27000				   -
     24  27000				   -	       jsr	i2c_startread
     25  27000				   -
     26  27000				   -	       ldx	#0
     27  27000				   -AVoxReadBytesLoop
     28  27000				   -	       jsr	i2c_rxbyte
     29  27000				   -	       sta	eeprombuffer,x
     30  27000				   -	       inx
     31  27000				   -	       cpx	temp8
     32  27000				   -	       bne	AVoxReadBytesLoop
     33  27000				   -	       jsr	i2c_stopread
     34  27000				   -	       lda	#0
     35  27000				   -	       rts
     36  27000				   -
     37  27000				   -			; to be called with
     38  27000				   -			; A=# of bytes
     39  27000				   -			;
     40  27000				   -
     41  27000				   -AVoxWriteBytes
     42  27000				   -	       sta	temp8
     43  27000				   -	       jsr	i2c_startwrite
     44  27000				   -	       bcs	eeprom_error
     45  27000				   -
     46  27000				   -	       lda	HSVoxHi
     47  27000				   -	       jsr	i2c_txbyte
     48  27000				   -	       lda	HSVoxLo
     49  27000				   -	       jsr	i2c_txbyte
     50  27000				   -
     51  27000				   -	       ldx	#$00
     52  27000				   -AVoxWriteBytesLoop
     53  27000				   -	       lda	eeprombuffer,x
     54  27000				   -	       jsr	i2c_txbyte
     55  27000				   -	       inx
     56  27000				   -	       cpx	temp8
     57  27000				   -	       bne	AVoxWriteBytesLoop
     58  27000				   -	       jsr	i2c_stopwrite
     59  27000				   -
     60  27000				   -	       lda	#0
     61  27000				   -	       rts
     62  27000				   -
     63  27000				   -eeprom_error
     64  27000				   -	       lda	#$ff
     65  27000				   -	       rts
     66  27000				   -
     67  27000				   -AVoxDetect
     68  27000				   -
     69  27000				   -	       jsr	i2c_startwrite
     70  27000				   -	       bcs	eeprom_error
     71  27000				   -	       lda	#$30
     72  27000				   -	       jsr	i2c_txbyte
     73  27000				   -	       lda	#$00
     74  27000				   -	       jsr	i2c_txbyte
     75  27000				   -	       jsr	i2c_stopwrite
     76  27000				   -	       rts
     77  27000				   -
     78  27000				   -	       include	"i2c7800.inc"
     79  27000				   -	       I2C_SUBS	temp9
     80  27000				   -
     81  27000				   -_7800voxend
     82  27000				   -
     83  27000				   -	       echo	"  (7800vox module is using ",[(_7800voxend-_7800voxstart)]d," bytes)"
     84  27000				   -
     85  27000					       endif
     86  27000
------- FILE c:\Users\Jag\Desktop\plotmap scrolling doublebuffer\test.78b.asm
   6587  27000					       endif
   6588  27000					       ifnconst	included.pokeysound.asm
------- FILE pokeysound.asm LEVEL 2 PASS 3
      0  27000					       include	pokeysound.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000
      4  27000				   -	       ifconst	pokeysupport
      5  27000				   -
      6  27000				   -pokeysoundmodulestart
      7  27000				   -
      8  27000				   -mutepokey
      9  27000				   -	       lda	#0
     10  27000				   -	       ldy	#7
     11  27000				   -mutepokeyloop
     12  27000				   -	       sta	pokey1pointlo,y
     13  27000				   -	       sta	(pokeybaselo),y
     14  27000				   -	       dey
     15  27000				   -	       bpl	mutepokeyloop
     16  27000				   -	       rts
     17  27000				   -
     18  27000				   -checkpokeyplaying
     19  27000				   -	       ldx	#6
     20  27000				   -checkpokeyplayingloop
     21  27000				   -	       lda	pokey1pointlo,x
     22  27000				   -	       ora	pokey1pointhi,x
     23  27000				   -	       beq	pokeychannelinactive
     24  27000				   -	       jsr	playpokeysfxA	; x=channel*2
     25  27000				   -pokeychannelinactive
     26  27000				   -	       dex
     27  27000				   -	       dex
     28  27000				   -	       bpl	checkpokeyplayingloop
     29  27000				   -	       rts
     30  27000				   -
     31  27000				   -playpokeysfxA
     32  27000				   -	       txa
     33  27000				   -	       tay
     34  27000				   -	       lda	pokey1tick,x
     35  27000				   -	       beq	playpokeysfxAcont
     36  27000				   -	       sec
     37  27000				   -	       sbc	#1
     38  27000				   -	       sta	pokey1tick,x	; sound resolution is >1 frame, and we're mid-tock...
     39  27000				   -	       rts
     40  27000				   -
     41  27000				   -playpokeysfxAcont
     42  27000				   -	       lda	pokey1frames,x	; set the frame countdown for this sound chunk
     43  27000				   -	       sta	pokey1tick,x
     44  27000				   -
     45  27000				   -	       lda	pokey1priority,x	; decrease the sound's priority if its non-zero
     46  27000				   -	       beq	playpokeysfxAcont2
     47  27000				   -	       sec
     48  27000				   -	       sbc	#1
     49  27000				   -	       sta	pokey1priority,x
     50  27000				   -playpokeysfxAcont2
     51  27000				   -
     52  27000				   -			; *** FREQUENCY
     53  27000				   -	       lda	(pokey1pointlo,x)
     54  27000				   -	       sta	inttemp1
     55  27000				   -	       clc
     56  27000				   -	       adc	pokey1offset,x	; take into account any pitch modification
     57  27000				   -	       sta	(pokeybaselo),y	; PAUDF0,0
     58  27000				   -
     59  27000				   -			;advance the data pointer +1
     60  27000				   -	       inc	pokey1pointlo,x
     61  27000				   -	       bne	skippokeyhiinc1
     62  27000				   -	       inc	pokey1pointhi,x
     63  27000				   -skippokeyhiinc1
     64  27000				   -
     65  27000				   -			; *** WAVE
     66  27000				   -	       lda	(pokey1pointlo,x)
     67  27000				   -	       asl
     68  27000				   -	       asl
     69  27000				   -	       asl
     70  27000				   -	       asl		; x16
     71  27000				   -
     72  27000				   -			;advance the data pointer +1
     73  27000				   -	       inc	pokey1pointlo,x
     74  27000				   -	       bne	skippokeyhiinc2
     75  27000				   -	       inc	pokey1pointhi,x
     76  27000				   -skippokeyhiinc2
     77  27000				   -
     78  27000				   -	       ora	(pokey1pointlo,x)
     79  27000				   -	       iny
     80  27000				   -	       sta	(pokeybaselo),y
     81  27000				   -
     82  27000				   -	       ora	inttemp1	; check if F|C|V=0
     83  27000				   -	       beq	zeropokeypoint	; if so, we're at the end of the sound.
     84  27000				   -
     85  27000				   -			; advance the pointer +1, on to the next sound chunk
     86  27000				   -	       inc	pokey1pointlo,x
     87  27000				   -	       bne	skippokeyhiinc3
     88  27000				   -	       inc	pokey1pointhi,x
     89  27000				   -skippokeyhiinc3
     90  27000				   -	       rts
     91  27000				   -
     92  27000				   -zeropokeypoint
     93  27000				   -	       sta	pokey1pointlo,x
     94  27000				   -	       sta	pokey1pointhi,x
     95  27000				   -	       sta	pokey1priority,x
     96  27000				   -	       rts
     97  27000				   -
     98  27000				   -schedulepokeysfx
     99  27000				   -	       ldx	#6
    100  27000				   -schedulepokeysfxloop
    101  27000				   -	       lda	pokey1pointlo,x
    102  27000				   -	       ora	pokey1pointhi,x
    103  27000				   -	       bne	schedulespokeysearch
    104  27000				   -	       jmp	schedulepokeyX	; we found an unused channel, so use it...
    105  27000				   -schedulespokeysearch
    106  27000				   -	       dex
    107  27000				   -	       dex
    108  27000				   -	       bpl	schedulepokeysfxloop
    109  27000				   -
    110  27000				   -			; if we're here, all 4 channels are presently playing a sound...
    111  27000				   -	       ldy	#1
    112  27000				   -	       lda	(sfxinstrumentlo),y	; peek at the priority of this sfx...
    113  27000				   -	       bne	schedulepokeysfxcont1
    114  27000				   -	       rts		; ...and skip it if it's 0 priority
    115  27000				   -schedulepokeysfxcont1
    116  27000				   -
    117  27000				   -			; figure out which current sound has the lowest priority...
    118  27000				   -	       lda	#0
    119  27000				   -	       sta	temp8
    120  27000				   -	       lda	pokey1priority
    121  27000				   -	       sta	temp9
    122  27000				   -	       ldx	#6
    123  27000				   -findlowprioritypokeyloop
    124  27000				   -	       lda	pokey1priority,x
    125  27000				   -	       cmp	temp9
    126  27000				   -	       bcs	findlowprioritypokeyloopcontinue
    127  27000				   -	       sta	temp9
    128  27000				   -	       stx	temp8
    129  27000				   -findlowprioritypokeyloopcontinue
    130  27000				   -	       dex
    131  27000				   -	       dex
    132  27000				   -	       bne	findlowprioritypokeyloop
    133  27000				   -	       ldx	temp8	; the low priority channel we'll interrupt
    134  27000				   -
    135  27000				   -schedulepokeyX
    136  27000				   -			;called with X=2*pokey channel to play on...
    137  27000				   -	       ldy	#1	; get priority and sound-resolution (in frames)
    138  27000				   -	       lda	(sfxinstrumentlo),y
    139  27000				   -	       sta	pokey1priority,x
    140  27000				   -	       iny
    141  27000				   -	       lda	(sfxinstrumentlo),y
    142  27000				   -	       sta	pokey1frames,x
    143  27000				   -
    144  27000				   -	       lda	sfxinstrumentlo
    145  27000				   -	       clc
    146  27000				   -	       adc	#3
    147  27000				   -	       sta	pokey1pointlo,x
    148  27000				   -	       lda	sfxinstrumenthi
    149  27000				   -	       adc	#0
    150  27000				   -	       sta	pokey1pointhi,x
    151  27000				   -	       lda	temp3
    152  27000				   -	       sta	pokey1offset,x
    153  27000				   -	       lda	#0
    154  27000				   -	       sta	pokey1tick,x
    155  27000				   -	       rts
    156  27000				   -
    157  27000				   -			; pokey detection routine. we check for pokey in the XBOARD/XM location,
    158  27000				   -			; and the standard $4000 location.
    159  27000				   -			; if pokey the pokey is present, this routine will reset it.
    160  27000				   -	       ifconst	pokeyaddress
    161  27000				   -detectpokeylocation
    162  27000				   -	       lda	#<pokeyaddress
    163  27000				   -	       sta	pokeybaselo
    164  27000				   -	       lda	#>pokeyaddress
    165  27000				   -	       sta	pokeybasehi
    166  27000				   -	       lda	#$ff
    167  27000				   -	       sta	pokeydetected
    168  27000				   -
    169  27000				   -	       if	pokeyaddress = $450
    170  27000				   -	       lda	XCTRL1s
    171  27000				   -	       ora	#%00010100
    172  27000				   -	       sta	XCTRL1s
    173  27000				   -	       sta	XCTRL1
    174  27000				   -	       endif
    175  27000				   -
    176  27000				   -
    177  27000				   -	       lda	#0
    178  27000				   -	       ldy	#15
    179  27000				   -clearpokeyloop
    180  27000				   -	       sta	(pokeybase),y
    181  27000				   -	       dey
    182  27000				   -	       bpl	clearpokeyloop
    183  27000				   -			; take pokey out of reset...
    184  27000				   -	       ldy	#PSKCTL
    185  27000				   -	       lda	#3
    186  27000				   -	       sta	(pokeybase),y
    187  27000				   -	       ldy	#PAUDCTL
    188  27000				   -	       lda	#0
    189  27000				   -	       sta	(pokeybase),y
    190  27000				   -	       rts
    191  27000				   -	       else		; !pokeyaddress
    192  27000				   -detectpokeylocation
    193  27000				   -			;XBoard/XM...
    194  27000				   -	       ldx	#2
    195  27000				   -detectpokeyloop
    196  27000				   -	       lda	XCTRL1s
    197  27000				   -	       ora	#%00010100
    198  27000				   -	       and	POKEYXMMASK,x
    199  27000				   -	       sta	XCTRL1s
    200  27000				   -	       sta	XCTRL1
    201  27000				   -
    202  27000				   -	       lda	POKEYCHECKLO,x
    203  27000				   -	       sta	pokeybaselo
    204  27000				   -	       lda	POKEYCHECKHI,x
    205  27000				   -	       sta	pokeybasehi
    206  27000				   -	       jsr	checkforpokey
    207  27000				   -	       lda	pokeydetected
    208  27000				   -	       beq	foundpokeychip
    209  27000				   -	       dex
    210  27000				   -	       bpl	detectpokeyloop
    211  27000				   -foundpokeychip
    212  27000				   -	       eor	#$ff	; invert state for 7800basic if...then test
    213  27000				   -	       sta	pokeydetected
    214  27000				   -	       rts
    215  27000				   -
    216  27000				   -POKEYXMMASK
    217  27000				   -			;     XM POKEY on    XM POKEY off   XM POKEY off
    218  27000				   -	       .byte	%11111111, %11101111, %11101111
    219  27000				   -
    220  27000				   -POKEYCHECKLO
    221  27000				   -	       .byte	<$0450, <$0450, <$4000
    222  27000				   -POKEYCHECKHI
    223  27000				   -	       .byte	>$0450, >$0450, >$4000
    224  27000				   -
    225  27000				   -checkforpokey
    226  27000				   -	       ldy	#$0f
    227  27000				   -	       lda	#$00
    228  27000				   -	       sta	pokeydetected	; start off by assuming pokey will be detected
    229  27000				   -resetpokeyregistersloop
    230  27000				   -	       sta	(pokeybase),y
    231  27000				   -	       dey
    232  27000				   -	       bpl	resetpokeyregistersloop
    233  27000				   -
    234  27000				   -	       ldy	#PAUDCTL
    235  27000				   -	       sta	(pokeybase),y
    236  27000				   -	       ldy	#PSKCTL
    237  27000				   -	       sta	(pokeybase),y
    238  27000				   -
    239  27000				   -			; let the dust settle...
    240  27000				   -	       nop
    241  27000				   -	       nop
    242  27000				   -	       nop
    243  27000				   -
    244  27000				   -	       lda	#4
    245  27000				   -	       sta	temp9
    246  27000				   -pokeycheckloop1
    247  27000				   -			; we're in reset, so the RANDOM register should read $ff...
    248  27000				   -	       ldy	#PRANDOM
    249  27000				   -	       lda	(pokeybase),y
    250  27000				   -	       cmp	#$ff
    251  27000				   -	       bne	nopokeydetected
    252  27000				   -	       dec	temp9
    253  27000				   -	       bne	pokeycheckloop1
    254  27000				   -
    255  27000				   -			; take pokey out of reset...
    256  27000				   -	       ldy	#PSKCTL
    257  27000				   -	       lda	#3
    258  27000				   -	       sta	(pokeybase),y
    259  27000				   -	       ldy	#PAUDCTL
    260  27000				   -	       lda	#0
    261  27000				   -	       sta	(pokeybase),y
    262  27000				   -
    263  27000				   -			; let the dust settle again...
    264  27000				   -	       nop
    265  27000				   -	       nop
    266  27000				   -	       nop
    267  27000				   -
    268  27000				   -	       lda	#4
    269  27000				   -	       sta	temp9
    270  27000				   -pokeycheckloop2
    271  27000				   -			; we're out of reset, so RANDOM should read non-$ff...
    272  27000				   -	       ldy	#PRANDOM
    273  27000				   -	       lda	(pokeybase),y
    274  27000				   -	       cmp	#$ff
    275  27000				   -	       beq	skippokeycheckreturn
    276  27000				   -	       rts
    277  27000				   -skippokeycheckreturn
    278  27000				   -	       dec	temp9
    279  27000				   -	       bne	pokeycheckloop2
    280  27000				   -nopokeydetected
    281  27000				   -	       dec	pokeydetected	; pokeydetected=#$ff
    282  27000				   -	       rts
    283  27000				   -
    284  27000				   -	       endif		; !pokeyaddress
    285  27000				   -
    286  27000				   -pokeysoundmoduleend
    287  27000				   -
    288  27000				   -	       echo	"  (pokeysound module is using ",[(pokeysoundmoduleend-pokeysoundmodulestart)]d," bytes)"
    289  27000				   -
    290  27000					       endif
------- FILE c:\Users\Jag\Desktop\plotmap scrolling doublebuffer\test.78b.asm
   6590  27000					       endif
   6591  27000					       ifnconst	included.tracker.asm
------- FILE tracker.asm LEVEL 2 PASS 3
      0  27000					       include	tracker.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000
      4  27000				   -	       ifconst	MUSICTRACKER
      5  27000				   -
      6  27000				   -trackerstart
      7  27000				   -
      8  27000				   -			; ** songtempo lists how many 256ths of a frame a 16th note lasts
      9  27000				   -			; ** the player operates on a 16th note grid.
     10  27000				   -
     11  27000				   -servicesongover
     12  27000				   -	       rts
     13  27000				   -servicesong
     14  27000				   -	       lda	songtempo
     15  27000				   -	       beq	servicesongover	; ** if song is off/paused then return
     16  27000				   -servicesongcontinue
     17  27000				   -	       lda	sfxschedulelock
     18  27000				   -	       sta	sfxschedulemissed
     19  27000				   -	       bne	servicesongover
     20  27000				   -	       lda	songtempo
     21  27000				   -	       clc
     22  27000				   -	       adc	songtick	; add songtempo to songtick until it rolls over
     23  27000				   -	       sta	songtick	; this is how we break away from 50/60Hz timing.
     24  27000				   -	       bcc	servicesongover
     25  27000				   -			; ** if we're here a new 16th note has passed
     26  27000				   -			; ** check if a new note is due on any of the 4 channels
     27  27000				   -servicesongredo
     28  27000				   -	       ldx	#3
     29  27000				   -checkchannelloop
     30  27000				   -	       dec	songchannel1busywait,x
     31  27000				   -	       bpl	carryoncheckingchannel
     32  27000				   -	       txa
     33  27000				   -	       pha		; save X for the loop
     34  27000				   -	       jsr	processsongdata
     35  27000				   -	       pla		; restore X for the loop
     36  27000				   -	       tax
     37  27000				   -carryoncheckingchannel
     38  27000				   -	       dex
     39  27000				   -	       bpl	checkchannelloop
     40  27000				   -	       lda	inactivechannelcount
     41  27000				   -	       cmp	#15
     42  27000				   -	       bne	skipstopsong
     43  27000				   -	       lda	songloops
     44  27000				   -	       bne	doasongloop
     45  27000				   -			;lda #0
     46  27000				   -	       sta	songtempo	; all channels are done. stop the song
     47  27000				   -	       rts
     48  27000				   -doasongloop
     49  27000				   -	       bmi	skipsongloopadjust
     50  27000				   -	       dec	songloops
     51  27000				   -skipsongloopadjust
     52  27000				   -	       jsr	setsongchannels
     53  27000				   -	       jmp	servicesongredo
     54  27000				   -skipstopsong
     55  27000				   -	       rts
     56  27000				   -
     57  27000				   -processsongdata
     58  27000				   -			; channel needs processing
     59  27000				   -			; X=channel #
     60  27000				   -
     61  27000				   -	       txa
     62  27000				   -	       clc
     63  27000				   -	       adc	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
     64  27000				   -	       tay
     65  27000				   -
     66  27000				   -
     67  27000				   -			; ** indirect x is cumbersome with mult-byte commands.
     68  27000				   -			; ** setup a pointer to the song data for indirect y addressing.
     69  27000				   -	       lda	songchannel1layer1lo,y
     70  27000				   -	       sta	songdatalo
     71  27000				   -	       lda	songchannel1layer1hi,y
     72  27000				   -	       sta	songdatahi
     73  27000				   -	       ora	songdatalo
     74  27000				   -	       bne	channelhasdata
     75  27000				   -			;channel data is pointing at $0000
     76  27000				   -	       lda	#$7F
     77  27000				   -	       sta	songchannel1busywait,x	; skip a bunch of notes
     78  27000				   -setchannelcountbits
     79  27000				   -	       lda	channel2bits,x
     80  27000				   -	       ora	inactivechannelcount
     81  27000				   -	       sta	inactivechannelcount
     82  27000				   -	       rts
     83  27000				   -channelhasdata
     84  27000				   -
     85  27000				   -	       sty	songstackindex
     86  27000				   -	       ldy	#0
     87  27000				   -	       lda	(songdatalo),y	; ** load in the next byte of song data, so we can decode it
     88  27000				   -	       cmp	#$ff
     89  27000				   -	       bne	carryoncheckingdatatype	; ** $ff=pattern end marker
     90  27000				   -	       jmp	handlechannelEOD
     91  27000				   -
     92  27000				   -carryoncheckingdatatype
     93  27000				   -	       and	#$F0
     94  27000				   -	       cmp	#$C0
     95  27000				   -	       beq	handlechannelrest	; 0000XXXX=rest
     96  27000				   -	       cmp	#$F0
     97  27000				   -	       beq	handlemultibytecommand
     98  27000				   -	       cmp	#$D0
     99  27000				   -	       beq	handlesemiup
    100  27000				   -	       cmp	#$E0
    101  27000				   -	       beq	handlesemidown
    102  27000				   -handlenotedata
    103  27000				   -			; ** TODO: note playing is a terrible choice for fall-through
    104  27000				   -
    105  27000				   -			; ** its simple note data, prepare arguments for schedulesfx
    106  27000				   -
    107  27000				   -			; ** set the note length
    108  27000				   -	       lda	(songdatalo),y
    109  27000				   -	       and	#$0F
    110  27000				   -	       sta	songchannel1busywait,x
    111  27000				   -
    112  27000				   -			; ** load the instrument
    113  27000				   -	       lda	songchannel1instrumentlo,x
    114  27000				   -	       sta	sfxinstrumentlo
    115  27000				   -	       lda	songchannel1instrumenthi,x
    116  27000				   -	       sta	sfxinstrumenthi
    117  27000				   -
    118  27000				   -			; ** get the note, and transpose
    119  27000				   -	       lda	(songdatalo),y
    120  27000				   -	       lsr
    121  27000				   -	       lsr
    122  27000				   -	       lsr
    123  27000				   -	       lsr
    124  27000				   -	       clc
    125  27000				   -	       adc	songchannel1transpose,x	; ** add it to the transpose index
    126  27000				   -			; ** its up the respective SFX scheduler to handle and save the note data
    127  27000				   -	       sta	sfxnoteindex
    128  27000				   -
    129  27000				   -	       lda	#0
    130  27000				   -	       sta	sfxpitchoffset
    131  27000				   -
    132  27000				   -	       jsr	schedulesfx
    133  27000				   -
    134  27000				   -	       jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    135  27000				   -
    136  27000				   -handlechannelrest
    137  27000				   -			; ** set the note length
    138  27000				   -	       lda	(songdatalo),y
    139  27000				   -	       and	#$0F
    140  27000				   -	       sta	songchannel1busywait,x
    141  27000				   -	       jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    142  27000				   -
    143  27000				   -handlesemiup
    144  27000				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    145  27000				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    146  27000				   -	       clc
    147  27000				   -handlesemidownentry
    148  27000				   -	       adc	songchannel1transpose,x	; ** add it to the transpose index
    149  27000				   -	       sta	songchannel1transpose,x
    150  27000				   -	       jsr	advancethesongpointer1byte
    151  27000				   -	       jmp	processsongdata	; semi doesn't have note length, so process the next data byte...
    152  27000				   -
    153  27000				   -handlesemidown
    154  27000				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    155  27000				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    156  27000				   -	       eor	#$ff	; ** its easier if we negate it, and then add it instead.
    157  27000				   -	       sec
    158  27000				   -	       jmp	handlesemidownentry
    159  27000				   -
    160  27000				   -handlemultibytecommand
    161  27000				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    162  27000				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    163  27000				   -	       cmp	#$08	; ** load new instrument?
    164  27000				   -	       bne	nothandleinstrumentchange
    165  27000				   -handleinstrumentchange
    166  27000				   -	       iny
    167  27000				   -	       lda	(songdatalo),y
    168  27000				   -	       sta	songchannel1instrumentlo,x
    169  27000				   -	       iny
    170  27000				   -	       lda	(songdatalo),y
    171  27000				   -	       sta	songchannel1instrumenthi,x
    172  27000				   -	       lda	#3
    173  27000				   -	       jsr	advancethesongpointerNbytes	; advance 3 bytes
    174  27000				   -	       jmp	processsongdata
    175  27000				   -
    176  27000				   -nothandleinstrumentchange
    177  27000				   -	       cmp	#$09	; ** absolute tempo change?
    178  27000				   -	       bne	nothandletempochange
    179  27000				   -	       lda	#0
    180  27000				   -	       sta	songtempo
    181  27000				   -handlerelativetempochange
    182  27000				   -	       iny
    183  27000				   -	       lda	(songdatalo),y
    184  27000				   -	       clc
    185  27000				   -	       adc	songtempo
    186  27000				   -	       sta	songtempo
    187  27000				   -	       lda	#2
    188  27000				   -	       jsr	advancethesongpointerNbytes	; advance 2 bytes
    189  27000				   -	       jmp	processsongdata
    190  27000				   -
    191  27000				   -nothandletempochange
    192  27000				   -	       cmp	#$0A	; ** relative tempo change?:
    193  27000				   -	       beq	handlerelativetempochange
    194  27000				   -	       cmp	#$0B	; ** octave/semi change?
    195  27000				   -	       beq	handleoctavesemichange
    196  27000				   -handlepatterndata
    197  27000				   -			; ** if we're here its a pattern/loop "subroutine"
    198  27000				   -			; ** move the channel's "stack" pointer and populate the new stack level
    199  27000				   -
    200  27000				   -	       lda	#4
    201  27000				   -	       clc
    202  27000				   -	       adc	songchannel1stackdepth,x
    203  27000				   -	       sta	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
    204  27000				   -
    205  27000				   -	       stx	inttemp6	; about to invalidate x. save it.
    206  27000				   -	       lda	songstackindex
    207  27000				   -	       adc	#4
    208  27000				   -	       tax
    209  27000				   -
    210  27000				   -	       lda	(songdatalo),y
    211  27000				   -	       and	#$7
    212  27000				   -	       sta	songchannel1layer1loops,x
    213  27000				   -	       iny
    214  27000				   -	       lda	(songdatalo),y
    215  27000				   -	       sta	songchannel1layer1lo,x
    216  27000				   -	       iny
    217  27000				   -	       lda	(songdatalo),y
    218  27000				   -	       sta	songchannel1layer1hi,x
    219  27000				   -
    220  27000				   -	       ldx	inttemp6	; restore x with the channel #
    221  27000				   -
    222  27000				   -			; ** advance will operate on the old stack level, since we didn't store the updated songstackindex...
    223  27000				   -	       lda	#3
    224  27000				   -	       jsr	advancethesongpointerNbytes	; advance 3 bytes
    225  27000				   -
    226  27000				   -			; ** ...but the new stack level will be correctly picked up when we process the next byte.
    227  27000				   -	       jmp	processsongdata
    228  27000				   -
    229  27000				   -handlechannelEOD
    230  27000				   -			; ** check if there are loops remaining on the pattern
    231  27000				   -	       stx	inttemp6
    232  27000				   -	       ldx	songstackindex
    233  27000				   -	       dec	songchannel1layer1loops,x
    234  27000				   -	       bmi	handlechannelEODnoloop
    235  27000				   -			; ** loops are remaining. set the pattern pointer to the pattern start, which is contained after the EOD
    236  27000				   -	       iny
    237  27000				   -	       lda	(songdatalo),y
    238  27000				   -	       sta	songchannel1layer1lo,x
    239  27000				   -	       iny
    240  27000				   -	       lda	(songdatalo),y
    241  27000				   -	       sta	songchannel1layer1hi,x
    242  27000				   -	       ldx	inttemp6
    243  27000				   -	       jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    244  27000				   -
    245  27000				   -handlechannelEODnoloop
    246  27000				   -			; this pattern/loop is done playing. "pop" the stack
    247  27000				   -	       ldx	inttemp6
    248  27000				   -	       lda	songchannel1stackdepth,x
    249  27000				   -	       beq	handlerootchannelEOD
    250  27000				   -	       sec
    251  27000				   -	       sbc	#4
    252  27000				   -	       sta	songchannel1stackdepth,x
    253  27000				   -	       jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    254  27000				   -
    255  27000				   -handlerootchannelEOD
    256  27000				   -			; this channel is done. point it to $ff data so we no longer process this channel.
    257  27000				   -	       lda	#0
    258  27000				   -	       sta	songchannel1layer1lo,x
    259  27000				   -	       sta	songchannel1layer1hi,x
    260  27000				   -	       sta	songchannel1busywait,x
    261  27000				   -	       jmp	setchannelcountbits
    262  27000				   -	       rts
    263  27000				   -
    264  27000				   -nothandlepatternchange
    265  27000				   -handleoctavesemichange
    266  27000				   -	       iny
    267  27000				   -	       lda	(songdatalo),y
    268  27000				   -	       sta	songchannel1transpose,x
    269  27000				   -	       lda	#2
    270  27000				   -	       jsr	advancethesongpointerNbytes	; advance 2 bytes
    271  27000				   -	       jmp	processsongdata
    272  27000				   -
    273  27000				   -advancethesongpointer1byte
    274  27000				   -	       txa
    275  27000				   -	       ldx	songstackindex
    276  27000				   -	       inc	songchannel1layer1lo,x
    277  27000				   -	       bne	skiphiadvancethesongpointer1byte
    278  27000				   -	       inc	songchannel1layer1hi,x
    279  27000				   -skiphiadvancethesongpointer1byte
    280  27000				   -	       tax
    281  27000				   -	       rts
    282  27000				   -
    283  27000				   -advancethesongpointerNbytes
    284  27000				   -			; entered with A=# of byte to advance
    285  27000				   -	       stx	inttemp6
    286  27000				   -	       ldx	songstackindex
    287  27000				   -	       clc
    288  27000				   -	       adc	songchannel1layer1lo,x
    289  27000				   -	       sta	songchannel1layer1lo,x
    290  27000				   -	       lda	#0
    291  27000				   -	       adc	songchannel1layer1hi,x
    292  27000				   -	       sta	songchannel1layer1hi,x
    293  27000				   -	       ldx	inttemp6
    294  27000				   -	       rts
    295  27000				   -
    296  27000				   -clearsongmemory
    297  27000				   -	       lda	#0
    298  27000				   -	       ldx	#(songchannel4instrumenthi-songchannel1layer1lo)
    299  27000				   -clearsongmemoryloop1
    300  27000				   -	       sta	songchannel1layer1lo,x
    301  27000				   -	       dex
    302  27000				   -	       bpl	clearsongmemoryloop1
    303  27000				   -
    304  27000				   -	       ldx	#(songchannel4stackdepth-songchannel1layer1loops)
    305  27000				   -clearsongmemoryloop2
    306  27000				   -	       sta	songchannel1layer1loops,x
    307  27000				   -	       dex
    308  27000				   -	       bpl	clearsongmemoryloop2
    309  27000				   -
    310  27000				   -	       lda	#$ff
    311  27000				   -	       ldx	#3
    312  27000				   -clearsongmemoryloop3
    313  27000				   -	       sta	songchannel1busywait,x
    314  27000				   -	       dex
    315  27000				   -	       bpl	clearsongmemoryloop3
    316  27000				   -	       rts
    317  27000				   -
    318  27000				   -setsongchannels
    319  27000				   -	       jsr	clearsongmemory
    320  27000				   -	       ldy	#7
    321  27000				   -	       ldx	#3
    322  27000				   -setsongchannelsloop
    323  27000				   -	       lda	(songpointerlo),y
    324  27000				   -	       sta	songchannel1layer1hi,x
    325  27000				   -	       dey
    326  27000				   -	       lda	(songpointerlo),y
    327  27000				   -	       sta	songchannel1layer1lo,x
    328  27000				   -	       dex
    329  27000				   -	       dey
    330  27000				   -	       bpl	setsongchannelsloop
    331  27000				   -	       rts
    332  27000				   -
    333  27000				   -channel2bits
    334  27000				   -	       .byte	1,2,4,8
    335  27000				   -
    336  27000				   -tiatrackeroctavenotes
    337  27000				   -	       ifconst	BUZZBASS
    338  27000				   -LOWC       =	15
    339  27000				   -	       else
    340  27000				   -LOWC       =	14
    341  27000				   -	       endif
    342  27000				   -			; ****** ELECTRONIC (0 to 11)
    343  27000				   -	       .byte	LOWC,20	; c0	 16.1Hz
    344  27000				   -	       .byte	LOWC,18	; c#0
    345  27000				   -	       .byte	LOWC,17	; d0
    346  27000				   -	       .byte	LOWC,16	; d#0
    347  27000				   -	       .byte	LOWC,15	; e0
    348  27000				   -	       .byte	LOWC,14	; f0  (very off)
    349  27000				   -	       .byte	LOWC,14	; f#0
    350  27000				   -	       .byte	LOWC,13	; g0
    351  27000				   -	       .byte	LOWC,12	; g#0
    352  27000				   -	       .byte	LOWC,11	; a0
    353  27000				   -	       .byte	LOWC,11	; a#0 (very off)
    354  27000				   -	       .byte	LOWC,10	; b0	 30.7Hz
    355  27000				   -
    356  27000				   -			; ****** SLIGHTLY BUZZY (12 to 23)
    357  27000				   -	       .byte	6,30	; c1	 32.7Hz
    358  27000				   -	       .byte	6,28	; c#1
    359  27000				   -	       .byte	6,27	; d1
    360  27000				   -	       .byte	6,25	; d#1
    361  27000				   -	       .byte	6,24	; e1
    362  27000				   -	       .byte	6,22	; f1
    363  27000				   -	       .byte	6,21	; f#1
    364  27000				   -	       .byte	6,20	; g1
    365  27000				   -	       .byte	6,18	; g#1
    366  27000				   -	       .byte	6,17	; a1
    367  27000				   -	       .byte	6,16	; a#1
    368  27000				   -	       .byte	6,15	; b1	 63.4Hz
    369  27000				   -
    370  27000				   -			; ****** BUZZY (24 to 39)
    371  27000				   -	       .byte	1,31	; c2	 65.5
    372  27000				   -	       .byte	1,30	; c#2	 67.6
    373  27000				   -	       .byte	1,27	; d2	 72.3
    374  27000				   -	       .byte	1,26	; d#2	 77.6
    375  27000				   -	       .byte	1,24	; e2
    376  27000				   -	       .byte	1,23	; f2
    377  27000				   -	       .byte	1,22	; f#2
    378  27000				   -	       .byte	1,20	; g2
    379  27000				   -	       .byte	1,19	; g#2
    380  27000				   -	       .byte	1,18	; a2
    381  27000				   -	       .byte	1,17	; a#2
    382  27000				   -	       .byte	1,16	; b2
    383  27000				   -	       .byte	1,15	; c3	126.8Hz
    384  27000				   -	       .byte	1,14	; c#3
    385  27000				   -	       .byte	1,13	; d3	149.7Hz
    386  27000				   -	       .byte	1,12	; d#3	161.2Hz (very off)
    387  27000				   -			; ****** PURE (40 to 71) - best key is A3 Major
    388  27000				   -	       .byte	12,31	; e3	163.8Hz
    389  27000				   -	       .byte	12,29	; f3
    390  27000				   -	       .byte	12,28	; f#3
    391  27000				   -	       .byte	12,26	; g3
    392  27000				   -	       .byte	12,24	; g#3
    393  27000				   -	       .byte	12,23	; a3  songs in key of A benefit from Perceptual Tuning
    394  27000				   -	       .byte	12,22	; a#3
    395  27000				   -	       .byte	12,20	; b3
    396  27000				   -	       .byte	12,19	; c4  (middle C)
    397  27000				   -	       .byte	12,18	; c#4
    398  27000				   -	       .byte	12,17	; d4
    399  27000				   -	       .byte	12,16	; d#4
    400  27000				   -	       .byte	12,15	; e4
    401  27000				   -	       .byte	12,14	; f4
    402  27000				   -	       .byte	12,13	; f#4
    403  27000				   -	       .byte	12,12	; g4  (very off)
    404  27000				   -	       .byte	12,12	; g#4
    405  27000				   -	       .byte	12,11	; a4
    406  27000				   -	       .byte	12,10	; a#4
    407  27000				   -	       .byte	4,31	; b4
    408  27000				   -	       .byte	4,29	; c5
    409  27000				   -	       .byte	4,28	; c#5
    410  27000				   -	       .byte	4,26	; d5
    411  27000				   -	       .byte	4,24	; d#5
    412  27000				   -	       .byte	4,23	; e5
    413  27000				   -	       .byte	4,22	; f5
    414  27000				   -	       .byte	4,20	; f#5
    415  27000				   -	       .byte	4,19	; g5
    416  27000				   -	       .byte	4,18	; g#5
    417  27000				   -	       .byte	4,17	; a5
    418  27000				   -	       .byte	4,16	; a#5
    419  27000				   -	       .byte	4,15	; b5
    420  27000				   -
    421  27000				   -			; ****** TUNED WIND (72 to 83)
    422  27000				   -	       .byte	8,30	; c
    423  27000				   -	       .byte	8,28	; c#
    424  27000				   -	       .byte	8,27	; d
    425  27000				   -	       .byte	8,25	; d#
    426  27000				   -	       .byte	8,24	; e
    427  27000				   -	       .byte	8,22	; f
    428  27000				   -	       .byte	8,21	; f#
    429  27000				   -	       .byte	8,20	; g
    430  27000				   -	       .byte	8,18	; g#
    431  27000				   -	       .byte	8,17	; a
    432  27000				   -	       .byte	8,16	; a#
    433  27000				   -	       .byte	8,15	; b
    434  27000				   -
    435  27000				   -	       include	"tiadrumkit.asm"
    436  27000				   -
    437  27000				   -trackerend
    438  27000				   -
    439  27000				   -	       echo	"  (tracker module is using ",[(trackerend-trackerstart)]d," bytes)"
    440  27000				   -
    441  27000					       endif		;MUSICTRACKER
------- FILE c:\Users\Jag\Desktop\plotmap scrolling doublebuffer\test.78b.asm
   6593  27000					       endif
   6594  27000					       ifnconst	included.hiscore.asm
------- FILE hiscore.asm LEVEL 2 PASS 3
      0  27000					       include	hiscore.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000				   -	       ifconst	HSSUPPORT
      4  27000				   -
      5  27000				   -hiscorestart
      6  27000				   -
      7  27000				   -detectatarivoxeeprom
      8  27000				   -hiscoremodulestart
      9  27000				   -			; do a test to see if atarivox eeprom can be accessed, and save results
     10  27000				   -	       jsr	AVoxDetect
     11  27000				   -	       eor	#$ff	; invert for easy 7800basic if...then logic
     12  27000				   -	       sta	avoxdetected
     13  27000				   -	       lda	#$0
     14  27000				   -	       sta	SWACNT
     15  27000				   -	       lda	avoxdetected
     16  27000				   -	       rts
     17  27000				   -
     18  27000				   -detecthsc
     19  27000				   -			; check for the HSC ROM signature...
     20  27000				   -	       lda	XCTRL1s
     21  27000				   -	       ora	#%00001100
     22  27000				   -	       sta	XCTRL1s
     23  27000				   -	       sta	XCTRL1
     24  27000				   -	       lda	$3900
     25  27000				   -	       eor	#$C6
     26  27000				   -	       bne	detecthscfail
     27  27000				   -	       lda	$3904
     28  27000				   -	       eor	#$FE
     29  27000				   -	       bne	detecthscfail
     30  27000				   -			; check if it's initialized...
     31  27000				   -	       ldy	#0
     32  27000				   -	       lda	#$ff
     33  27000				   -checkhscinit
     34  27000				   -	       and	$1000,y
     35  27000				   -	       dey
     36  27000				   -	       bpl	checkhscinit
     37  27000				   -	       cmp	#$ff
     38  27000				   -	       bne	hscisalreadyinit
     39  27000				   -			; if we're here, we need to do a minimal HSC init...
     40  27000				   -	       ldy	#$28
     41  27000				   -hscinitloop1
     42  27000				   -	       lda	hscheader,y
     43  27000				   -	       sta	$1000,y
     44  27000				   -	       dey
     45  27000				   -	       bpl	hscinitloop1
     46  27000				   -	       ldy	#$89
     47  27000				   -	       lda	#$7F
     48  27000				   -hscinitloop2
     49  27000				   -	       sta	$10B3,y
     50  27000				   -	       dey
     51  27000				   -	       cpy	#$ff
     52  27000				   -	       bne	hscinitloop2
     53  27000				   -hscisalreadyinit
     54  27000				   -	       lda	#$ff
     55  27000				   -	       rts
     56  27000				   -hscheader
     57  27000				   -	       .byte	$00,$00,$68,$83,$AA,$55,$9C,$FF,$07,$12,$02,$1F,$00,$00,$00,$00
     58  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     59  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$03
     60  27000				   -detecthscfail
     61  27000				   -	       lda	XCTRL1s
     62  27000				   -	       and	#%11110111
     63  27000				   -	       sta	XCTRL1s
     64  27000				   -	       lda	#0
     65  27000				   -	       rts
     66  27000					       endif		; HSSUPPORT
     67  27000
     68  27000				   -	       ifconst	HSSUPPORT
     69  27000				   -	       ifnconst	hiscorefont
     70  27000				   -	       echo	""
     71  27000				   -	       echo	"WARNING: High score support is enabled, but the hiscorefont.png was"
     72  27000				   -	       echo	" NOT imported with incgraphic. The high score display code"
     73  27000				   -	       echo	" has been omitted from this build."
     74  27000				   -	       echo	""
     75  27000				   -	       else
     76  27000				   -hscdrawscreen
     77  27000				   -
     78  27000				   -			; we use 20 lines on a 24 line display
     79  27000				   -			; HSSCOREY to dynamically centers based on
     80  27000				   -			;HSSCOREY = 0
     81  27000				   -HSSCOREY   =	((WZONECOUNT*WZONEHEIGHT/8)-22)/2
     82  27000				   -HSCURSORY  =	((HSSCOREY/(WZONEHEIGHT/8))*WZONEHEIGHT)
     83  27000				   -
     84  27000				   -	       ifconst	HSSCORESIZE
     85  27000				   -SCORESIZE  =	HSSCORESIZE
     86  27000				   -	       else
     87  27000				   -SCORESIZE  =	6
     88  27000				   -	       endif
     89  27000				   -
     90  27000				   -			;save shadow registers for later return...
     91  27000				   -	       lda	sCTRL
     92  27000				   -	       sta	ssCTRL
     93  27000				   -	       lda	sCHARBASE
     94  27000				   -	       sta	ssCHARBASE
     95  27000				   -	       lda	#$60
     96  27000				   -	       sta	charactermode
     97  27000				   -	       jsr	drawwait
     98  27000				   -	       jsr	blacken320colors
     99  27000				   -	       jsr	clearscreen
    100  27000				   -
    101  27000				   -			;set the character base to the HSC font
    102  27000				   -	       lda	#>hiscorefont
    103  27000				   -	       sta	CHARBASE
    104  27000				   -	       sta	sCHARBASE
    105  27000				   -	       lda	#%01000011	;Enable DMA, mode=320A
    106  27000				   -	       sta	CTRL
    107  27000				   -	       sta	sCTRL
    108  27000				   -
    109  27000				   -	       lda	#60
    110  27000				   -	       sta	hsjoydebounce
    111  27000				   -
    112  27000				   -	       lda	#0
    113  27000				   -	       sta	hscursorx
    114  27000				   -	       sta	framecounter
    115  27000				   -	       ifnconst	HSCOLORCHASESTART
    116  27000				   -	       lda	#$8D	; default is blue. why not?
    117  27000				   -	       else
    118  27000				   -	       lda	#HSCOLORCHASESTART
    119  27000				   -	       endif
    120  27000				   -	       sta	hscolorchaseindex
    121  27000				   -
    122  27000				   -	       lda	#$0F
    123  27000				   -	       sta	P0C2	; base text is white
    124  27000				   -
    125  27000				   -	       jsr	hschasecolors
    126  27000				   -			; ** plot all of the initials
    127  27000				   -	       lda	#<HSRAMInitials
    128  27000				   -	       sta	temp1	; charmaplo
    129  27000				   -	       lda	#>HSRAMInitials
    130  27000				   -	       sta	temp2	; charmaphi
    131  27000				   -	       lda	#32+29	; palette=0-29 | 32-(width=3)
    132  27000				   -	       sta	temp3	; palette/width
    133  27000				   -	       lda	#104
    134  27000				   -	       sta	temp4	; X
    135  27000				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    136  27000				   -	       sta	temp5	; Y
    137  27000				   -plothsinitialsloop
    138  27000				   -	       jsr	plotcharacters
    139  27000				   -	       clc
    140  27000				   -	       lda	temp3
    141  27000				   -	       adc	#32
    142  27000				   -	       sta	temp3
    143  27000				   -	       inc	temp5
    144  27000				   -	       if	WZONEHEIGHT = 8
    145  27000				   -	       inc	temp5
    146  27000				   -	       endif
    147  27000				   -	       clc
    148  27000				   -	       lda	#3
    149  27000				   -	       adc	temp1
    150  27000				   -	       sta	temp1
    151  27000				   -	       cmp	#(<(HSRAMInitials+15))
    152  27000				   -	       bcc	plothsinitialsloop
    153  27000				   -
    154  27000				   -	       ifconst	HSGAMENAMELEN
    155  27000				   -			;plot the game name...
    156  27000				   -	       lda	#<HSGAMENAMEtable
    157  27000				   -	       sta	temp1	; charmaplo
    158  27000				   -	       lda	#>HSGAMENAMEtable
    159  27000				   -	       sta	temp2	; charmaphi
    160  27000				   -	       lda	#(32-HSGAMENAMELEN)	; palette=0*29 | 32-(width=3)
    161  27000				   -	       sta	temp3	; palette/width
    162  27000				   -	       lda	#(80-(HSGAMENAMELEN*2))
    163  27000				   -	       sta	temp4	; X
    164  27000				   -	       lda	#((HSSCOREY+0)/(WZONEHEIGHT/8))
    165  27000				   -	       sta	temp5	; Y
    166  27000				   -	       jsr	plotcharacters
    167  27000				   -	       endif		; HSGAMENAMELEN
    168  27000				   -
    169  27000				   -			;plot "difficulty"...
    170  27000				   -	       ldy	gamedifficulty
    171  27000				   -	       ifnconst	HSNOLEVELNAMES
    172  27000				   -	       lda	highscoredifficultytextlo,y
    173  27000				   -	       sta	temp1
    174  27000				   -	       lda	highscoredifficultytexthi,y
    175  27000				   -	       sta	temp2
    176  27000				   -	       sec
    177  27000				   -	       lda	#32
    178  27000				   -	       sbc	highscoredifficultytextlen,y
    179  27000				   -	       sta	temp3	; palette/width
    180  27000				   -	       sec
    181  27000				   -	       lda	#40
    182  27000				   -	       sbc	highscoredifficultytextlen,y
    183  27000				   -	       asl
    184  27000				   -	       sta	temp4	; X
    185  27000				   -	       else
    186  27000				   -	       lda	#<HSHIGHSCOREStext
    187  27000				   -	       sta	temp1	; charmaplo
    188  27000				   -	       lda	#>HSHIGHSCOREStext
    189  27000				   -	       sta	temp2	; charmaphi
    190  27000				   -	       lda	#(32-11)	; palette=0*29 | 32-(width=3)
    191  27000				   -	       sta	temp3	; palette/width
    192  27000				   -	       lda	#(80-(11*2))
    193  27000				   -	       sta	temp4	; X
    194  27000				   -	       endif		; HSNOLEVELNAMES
    195  27000				   -
    196  27000				   -	       lda	#((HSSCOREY+2)/(WZONEHEIGHT/8))
    197  27000				   -	       sta	temp5	; Y
    198  27000				   -	       jsr	plotcharacters
    199  27000				   -	       ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    200  27000				   -	       bne	carronwithscoreevaluation
    201  27000				   -	       jmp	donoscoreevaluation
    202  27000				   -carronwithscoreevaluation
    203  27000				   -	       dey
    204  27000				   -	       lda	highscorelabeltextlo,y
    205  27000				   -	       sta	temp1
    206  27000				   -	       lda	highscorelabeltexthi,y
    207  27000				   -	       sta	temp2
    208  27000				   -	       sec
    209  27000				   -	       lda	#(32-15)	; palette=0*29 | 32-(width=3)
    210  27000				   -	       sta	temp3	; palette/width
    211  27000				   -	       lda	highscorelabeladjust1,y
    212  27000				   -	       sta	temp4	; X
    213  27000				   -	       lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    214  27000				   -	       sta	temp5	; Y
    215  27000				   -	       jsr	plotcharacters
    216  27000				   -
    217  27000				   -	       ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    218  27000				   -	       dey
    219  27000				   -			;plot the current player score...
    220  27000				   -	       lda	#(32-SCORESIZE)	; palette=0*32
    221  27000				   -	       sta	temp3	; palette/width
    222  27000				   -	       lda	highscorelabeladjust2,y
    223  27000				   -	       sta	temp4	; X
    224  27000				   -	       lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    225  27000				   -	       sta	temp5	; Y
    226  27000				   -
    227  27000				   -	       lda	scorevarlo,y
    228  27000				   -	       sta	temp7	; score variable lo
    229  27000				   -	       lda	scorevarhi,y
    230  27000				   -	       sta	temp8	; score variable hi
    231  27000				   -
    232  27000				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    233  27000				   -	       sta	temp9
    234  27000				   -
    235  27000				   -	       lda	#<(hiscorefont+33)	; +33 to get to '0' character
    236  27000				   -	       sta	temp1	; charmaplo
    237  27000				   -	       lda	#>(hiscorefont+33)
    238  27000				   -	       sta	temp2	; charmaphi
    239  27000				   -	       lda	#SCORESIZE
    240  27000				   -	       sta	temp6
    241  27000				   -	       ifnconst	DOUBLEWIDE
    242  27000				   -	       jsr	plotvalue
    243  27000				   -	       else
    244  27000				   -	       jsr	plotvaluedw
    245  27000				   -	       endif
    246  27000				   -
    247  27000				   -USED_PLOTVALUE =	1	; ensure that plotvalue gets compiled in
    248  27000				   -
    249  27000				   -	       ifconst	HSGAMERANKS
    250  27000				   -
    251  27000				   -	       ldx	#$ff	; start at 0 after the inx...
    252  27000				   -comparescore2rankloop
    253  27000				   -	       inx
    254  27000				   -	       ldy	#0
    255  27000				   -	       lda	rankvalue_0,x
    256  27000				   -	       cmp	(temp7),y
    257  27000				   -	       bcc	score2rankloopdone
    258  27000				   -	       bne	comparescore2rankloop
    259  27000				   -	       iny
    260  27000				   -	       lda	rankvalue_1,x
    261  27000				   -	       cmp	(temp7),y
    262  27000				   -	       bcc	score2rankloopdone
    263  27000				   -	       bne	comparescore2rankloop
    264  27000				   -	       iny
    265  27000				   -	       lda	(temp7),y
    266  27000				   -	       cmp	rankvalue_2,x
    267  27000				   -	       bcs	score2rankloopdone
    268  27000				   -	       jmp	comparescore2rankloop
    269  27000				   -score2rankloopdone
    270  27000				   -	       stx	hsnewscorerank
    271  27000				   -
    272  27000				   -	       lda	ranklabello,x
    273  27000				   -	       sta	temp1
    274  27000				   -	       lda	ranklabelhi,x
    275  27000				   -	       sta	temp2
    276  27000				   -	       sec
    277  27000				   -	       lda	#32	; palette=0*29 | 32-(width=3)
    278  27000				   -	       sbc	ranklabellengths,x
    279  27000				   -	       sta	temp3	; palette/width
    280  27000				   -	       sec
    281  27000				   -	       lda	#(40+6)
    282  27000				   -	       sbc	ranklabellengths,x
    283  27000				   -	       asl
    284  27000				   -	       sta	temp4	; X
    285  27000				   -	       lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    286  27000				   -	       sta	temp5	; Y
    287  27000				   -	       jsr	plotcharacters
    288  27000				   -
    289  27000				   -	       ldx	hsnewscorerank
    290  27000				   -
    291  27000				   -	       lda	#<highscoreranklabel
    292  27000				   -	       sta	temp1
    293  27000				   -	       lda	#>highscoreranklabel
    294  27000				   -	       sta	temp2
    295  27000				   -
    296  27000				   -	       lda	#(32-5)	; palette=0*29 | 32-(width=3)
    297  27000				   -	       sta	temp3	; palette/width
    298  27000				   -	       lda	#(40-6)
    299  27000				   -	       sec
    300  27000				   -	       sbc	ranklabellengths,x
    301  27000				   -	       asl
    302  27000				   -	       sta	temp4	; X
    303  27000				   -	       lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    304  27000				   -	       sta	temp5	; Y
    305  27000				   -	       jsr	plotcharacters
    306  27000				   -	       endif
    307  27000				   -
    308  27000				   -
    309  27000				   -			; ** which line did this player beat?
    310  27000				   -	       lda	#$ff
    311  27000				   -	       sta	hsnewscoreline
    312  27000				   -	       ldx	#$fd
    313  27000				   -comparescoreadd2x
    314  27000				   -	       inx
    315  27000				   -comparescoreadd1x
    316  27000				   -	       inx
    317  27000				   -comparescore2lineloop
    318  27000				   -	       inc	hsnewscoreline
    319  27000				   -	       inx		; initialrun, x=0
    320  27000				   -	       cpx	#15
    321  27000				   -	       beq	nohighscoreforyou
    322  27000				   -	       ldy	#0
    323  27000				   -	       lda	HSRAMScores,x
    324  27000				   -	       cmp	(temp7),y	; first score digit
    325  27000				   -	       bcc	score2lineloopdonedel1x
    326  27000				   -	       bne	comparescoreadd2x
    327  27000				   -	       iny
    328  27000				   -	       inx
    329  27000				   -	       lda	HSRAMScores,x
    330  27000				   -	       cmp	(temp7),y
    331  27000				   -	       bcc	score2lineloopdonedel2x
    332  27000				   -	       bne	comparescoreadd1x
    333  27000				   -	       iny
    334  27000				   -	       inx
    335  27000				   -	       lda	(temp7),y
    336  27000				   -	       cmp	HSRAMScores,x
    337  27000				   -	       bcs	score2lineloopdonedel3x
    338  27000				   -	       jmp	comparescore2lineloop
    339  27000				   -nohighscoreforyou
    340  27000				   -	       lda	#$ff
    341  27000				   -	       sta	hsnewscoreline
    342  27000				   -	       sta	countdownseconds
    343  27000				   -	       jmp	donoscoreevaluation
    344  27000				   -score2lineloopdonedel3x
    345  27000				   -	       dex
    346  27000				   -score2lineloopdonedel2x
    347  27000				   -	       dex
    348  27000				   -score2lineloopdonedel1x
    349  27000				   -	       dex
    350  27000				   -
    351  27000				   -			; 0 1 2
    352  27000				   -			; 3 4 5
    353  27000				   -			; 6 7 8
    354  27000				   -			; 9 0 1
    355  27000				   -			; 2 3 4
    356  27000				   -
    357  27000				   -	       stx	temp9
    358  27000				   -	       cpx	#11
    359  27000				   -	       beq	postsortscoresuploop
    360  27000				   -	       ldx	#11
    361  27000				   -sortscoresuploop
    362  27000				   -	       lda	HSRAMScores,x
    363  27000				   -	       sta	HSRAMScores+3,x
    364  27000				   -	       lda	HSRAMInitials,x
    365  27000				   -	       sta	HSRAMInitials+3,x
    366  27000				   -	       dex
    367  27000				   -	       cpx	temp9
    368  27000				   -	       bne	sortscoresuploop
    369  27000				   -postsortscoresuploop
    370  27000				   -
    371  27000				   -			;stick the score and cleared initials in the slot...
    372  27000				   -	       inx
    373  27000				   -	       ldy	#0
    374  27000				   -	       sty	hsinitialhold
    375  27000				   -	       lda	(temp7),y
    376  27000				   -	       sta	HSRAMScores,x
    377  27000				   -	       iny
    378  27000				   -	       lda	(temp7),y
    379  27000				   -	       sta	HSRAMScores+1,x
    380  27000				   -	       iny
    381  27000				   -	       lda	(temp7),y
    382  27000				   -	       sta	HSRAMScores+2,x
    383  27000				   -	       lda	#0
    384  27000				   -	       sta	HSRAMInitials,x
    385  27000				   -	       lda	#29
    386  27000				   -	       sta	HSRAMInitials+1,x
    387  27000				   -	       sta	HSRAMInitials+2,x
    388  27000				   -
    389  27000				   -	       stx	hsinitialpos
    390  27000				   -
    391  27000				   -	       ifconst	vox_highscore
    392  27000				   -	       lda	<#vox_highscore
    393  27000				   -	       sta	speech_addr
    394  27000				   -	       lda	>#vox_highscore
    395  27000				   -	       sta	speech_addr+1
    396  27000				   -	       endif
    397  27000				   -	       ifconst	sfx_highscore
    398  27000				   -	       lda	<#sfx_highscore
    399  27000				   -	       sta	temp1
    400  27000				   -	       lda	>#sfx_highscore
    401  27000				   -	       sta	temp2
    402  27000				   -	       lda	#0
    403  27000				   -	       sta	temp3
    404  27000				   -	       jsr	schedulesfx
    405  27000				   -	       endif
    406  27000				   -	       ifconst	songdatastart_song_highscore
    407  27000				   -	       lda	#<songchanneltable_song_highscore
    408  27000				   -	       sta	songpointerlo
    409  27000				   -	       lda	#>songchanneltable_song_highscore
    410  27000				   -	       sta	songpointerhi
    411  27000				   -	       lda	#73
    412  27000				   -	       sta	songtempo
    413  27000				   -	       jsr	setsongchannels
    414  27000				   -	       endif
    415  27000				   -
    416  27000				   -
    417  27000				   -donoscoreevaluation
    418  27000				   -
    419  27000				   -	       lda	#(32+(32-SCORESIZE))	; palette=0*32 | 32-(width=6)
    420  27000				   -	       sta	temp3	; palette/width
    421  27000				   -	       lda	#(72+(4*(6-SCORESIZE)))
    422  27000				   -	       sta	temp4	; X
    423  27000				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    424  27000				   -	       sta	temp5	; Y
    425  27000				   -	       lda	#<HSRAMScores
    426  27000				   -	       sta	temp7	; score variable lo
    427  27000				   -	       lda	#>HSRAMScores
    428  27000				   -	       sta	temp8	; score variable hi
    429  27000				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    430  27000				   -	       sta	temp9
    431  27000				   -plothsscoresloop
    432  27000				   -	       lda	#<(hiscorefont+33)	; +33 to get to '0' character
    433  27000				   -	       sta	temp1	; charmaplo
    434  27000				   -	       lda	#>(hiscorefont+33)
    435  27000				   -	       sta	temp2	; charmaphi
    436  27000				   -	       lda	#6
    437  27000				   -	       sta	temp6
    438  27000				   -	       ifnconst	DOUBLEWIDE
    439  27000				   -	       jsr	plotvalue
    440  27000				   -	       else
    441  27000				   -	       jsr	plotvaluedw
    442  27000				   -	       endif
    443  27000				   -	       clc
    444  27000				   -	       lda	temp3
    445  27000				   -	       adc	#32
    446  27000				   -	       sta	temp3
    447  27000				   -	       inc	temp5
    448  27000				   -	       if	WZONEHEIGHT = 8
    449  27000				   -	       inc	temp5
    450  27000				   -	       endif
    451  27000				   -	       clc
    452  27000				   -	       lda	#3
    453  27000				   -	       adc	temp7
    454  27000				   -	       sta	temp7
    455  27000				   -	       cmp	#(<(HSRAMScores+15))
    456  27000				   -	       bcc	plothsscoresloop
    457  27000				   -plothsindex
    458  27000				   -	       lda	#32+31	; palette=0*32 | 32-(width=1)
    459  27000				   -	       sta	temp3	; palette/width
    460  27000				   -	       lda	#44
    461  27000				   -	       sta	temp4	; X
    462  27000				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    463  27000				   -	       sta	temp5	; Y
    464  27000				   -	       lda	#<hsgameslotnumbers
    465  27000				   -	       sta	temp7	; score variable lo
    466  27000				   -	       lda	#>hsgameslotnumbers
    467  27000				   -	       sta	temp8	; score variable hi
    468  27000				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    469  27000				   -	       sta	temp9
    470  27000				   -plothsindexloop
    471  27000				   -	       lda	#<(hiscorefont+33)
    472  27000				   -	       sta	temp1	; charmaplo
    473  27000				   -	       lda	#>(hiscorefont+33)
    474  27000				   -	       sta	temp2	; charmaphi
    475  27000				   -	       lda	#1
    476  27000				   -	       sta	temp6	; number of characters
    477  27000				   -	       ifnconst	DOUBLEWIDE
    478  27000				   -	       jsr	plotvalue
    479  27000				   -	       else
    480  27000				   -	       jsr	plotvaluedw
    481  27000				   -	       endif
    482  27000				   -	       clc
    483  27000				   -	       lda	temp3
    484  27000				   -	       adc	#32
    485  27000				   -	       sta	temp3
    486  27000				   -	       inc	temp5
    487  27000				   -	       if	WZONEHEIGHT = 8
    488  27000				   -	       inc	temp5
    489  27000				   -	       endif
    490  27000				   -	       inc	temp7
    491  27000				   -	       lda	temp7
    492  27000				   -	       cmp	#(<(hsgameslotnumbers+5))
    493  27000				   -	       bcc	plothsindexloop
    494  27000				   -
    495  27000				   -	       jsr	savescreen
    496  27000				   -	       ifnconst	HSSECONDS
    497  27000				   -	       lda	#6
    498  27000				   -	       else
    499  27000				   -	       lda	#HSSECONDS
    500  27000				   -	       endif
    501  27000				   -
    502  27000				   -	       sta	countdownseconds
    503  27000				   -
    504  27000				   -keepdisplayinghs
    505  27000				   -	       jsr	restorescreen
    506  27000				   -
    507  27000				   -	       jsr	setuphsinpt1
    508  27000				   -
    509  27000				   -	       lda	hsnewscoreline
    510  27000				   -	       bpl	carryonkeepdisplayinghs
    511  27000				   -	       jmp	skipenterscorecontrol
    512  27000				   -carryonkeepdisplayinghs
    513  27000				   -
    514  27000				   -
    515  27000				   -	       ifnconst	HSSECONDS
    516  27000				   -	       lda	#6
    517  27000				   -	       else
    518  27000				   -	       lda	#HSSECONDS
    519  27000				   -	       endif
    520  27000				   -
    521  27000				   -	       sta	countdownseconds
    522  27000				   -
    523  27000				   -			;plot the "cursor" initial sprite...
    524  27000				   -	       lda	hsinitialhold
    525  27000				   -
    526  27000				   -	       sta	temp1
    527  27000				   -	       lda	#>(hiscorefont+32)
    528  27000				   -	       sta	temp2
    529  27000				   -	       lda	#31	; palette=0*32 | 32-(width=1)
    530  27000				   -	       sta	temp3	; palette/width
    531  27000				   -	       lda	hscursorx
    532  27000				   -	       asl
    533  27000				   -	       asl
    534  27000				   -	       clc
    535  27000				   -	       adc	#104
    536  27000				   -	       sta	temp4	; X
    537  27000				   -	       lda	hsnewscoreline
    538  27000				   -	       asl
    539  27000				   -	       asl
    540  27000				   -	       asl
    541  27000				   -	       asl
    542  27000				   -	       adc	#((3*16)+HSCURSORY)
    543  27000				   -	       sta	temp5	; Y
    544  27000				   -	       lda	#%01000000
    545  27000				   -	       sta	temp6
    546  27000				   -	       jsr	plotsprite
    547  27000				   -
    548  27000				   -	       ldx	hscursorx
    549  27000				   -	       ldy	hsdisplaymode
    550  27000				   -	       lda	SWCHA
    551  27000				   -	       cpy	#3
    552  27000				   -	       bne	hsskipadjustjoystick1
    553  27000				   -	       asl
    554  27000				   -	       asl
    555  27000				   -	       asl
    556  27000				   -	       asl
    557  27000				   -hsskipadjustjoystick1
    558  27000				   -	       sta	hsswcha
    559  27000				   -	       lda	SWCHB
    560  27000				   -	       and	#%00000010
    561  27000				   -	       bne	hsskipselectswitch
    562  27000				   -	       lda	#%00010000
    563  27000				   -	       sta	hsswcha
    564  27000				   -	       bne	hsdodebouncecheck
    565  27000				   -hsskipselectswitch
    566  27000				   -	       lda	hsswcha
    567  27000				   -	       and	#%00110000
    568  27000				   -	       cmp	#%00110000
    569  27000				   -	       beq	hsjoystickskipped
    570  27000				   -hsdodebouncecheck
    571  27000				   -	       lda	hsjoydebounce
    572  27000				   -	       beq	hsdontdebounce
    573  27000				   -	       jmp	hspostjoystick
    574  27000				   -hsdontdebounce
    575  27000				   -	       ldx	#1	; small tick sound
    576  27000				   -	       jsr	playhssfx
    577  27000				   -	       lda	hsswcha
    578  27000				   -	       and	#%00110000
    579  27000				   -	       ldx	hscursorx
    580  27000				   -	       cmp	#%00100000	; check down
    581  27000				   -	       bne	hsjoycheckup
    582  27000				   -	       ldy	hsinitialhold
    583  27000				   -	       cpx	#0
    584  27000				   -	       bne	skipavoid31_1
    585  27000				   -	       cpy	#0	; if we're about to change to the <- char (#31) then double-decrement to skip over it
    586  27000				   -	       bne	skipavoid31_1
    587  27000				   -	       dey
    588  27000				   -skipavoid31_1
    589  27000				   -	       dey
    590  27000				   -	       jmp	hssetdebounce
    591  27000				   -hsjoycheckup
    592  27000				   -	       cmp	#%00010000	; check up
    593  27000				   -	       bne	hsjoystickskipped
    594  27000				   -	       ldy	hsinitialhold
    595  27000				   -	       cpx	#0
    596  27000				   -	       bne	skipavoid31_2
    597  27000				   -	       cpy	#30	; if we're about to change to the <- char (#31) then double-increment to skip over it
    598  27000				   -	       bne	skipavoid31_2
    599  27000				   -	       iny
    600  27000				   -skipavoid31_2
    601  27000				   -	       iny
    602  27000				   -hssetdebounce
    603  27000				   -	       tya
    604  27000				   -	       and	#31
    605  27000				   -	       sta	hsinitialhold
    606  27000				   -	       lda	#15
    607  27000				   -	       sta	hsjoydebounce
    608  27000				   -	       bne	hspostjoystick
    609  27000				   -hsjoystickskipped
    610  27000				   -			; check the fire button only when the stick isn't engaged
    611  27000				   -	       lda	hsinpt1
    612  27000				   -	       bpl	hsbuttonskipped
    613  27000				   -	       lda	hsjoydebounce
    614  27000				   -	       beq	hsfiredontdebounce
    615  27000				   -	       bne	hspostjoystick
    616  27000				   -hsfiredontdebounce
    617  27000				   -	       lda	hsinitialhold
    618  27000				   -	       cmp	#31
    619  27000				   -	       beq	hsmovecursorback
    620  27000				   -	       inc	hscursorx
    621  27000				   -	       inc	hsinitialpos
    622  27000				   -	       lda	hscursorx
    623  27000				   -	       cmp	#3
    624  27000				   -	       bne	skiphsentryisdone
    625  27000				   -	       lda	#0
    626  27000				   -	       sta	framecounter
    627  27000				   -	       lda	#$ff
    628  27000				   -	       sta	hsnewscoreline
    629  27000				   -	       dec	hsinitialpos
    630  27000				   -	       bne	skiphsentryisdone
    631  27000				   -hsmovecursorback
    632  27000				   -	       lda	hscursorx
    633  27000				   -	       beq	skiphsmovecursorback
    634  27000				   -	       lda	#29
    635  27000				   -	       ldx	hsinitialpos
    636  27000				   -	       sta	HSRAMInitials,x
    637  27000				   -	       dec	hsinitialpos
    638  27000				   -	       dec	hscursorx
    639  27000				   -	       dex
    640  27000				   -	       lda	HSRAMInitials,x
    641  27000				   -	       sta	hsinitialhold
    642  27000				   -skiphsmovecursorback
    643  27000				   -skiphsentryisdone
    644  27000				   -	       ldx	#0
    645  27000				   -	       jsr	playhssfx
    646  27000				   -	       lda	#20
    647  27000				   -	       sta	hsjoydebounce
    648  27000				   -	       bne	hspostjoystick
    649  27000				   -
    650  27000				   -hsbuttonskipped
    651  27000				   -	       lda	#0
    652  27000				   -	       sta	hsjoydebounce
    653  27000				   -hspostjoystick
    654  27000				   -
    655  27000				   -	       ldx	hsinitialpos
    656  27000				   -	       lda	hsinitialhold
    657  27000				   -	       sta	HSRAMInitials,x
    658  27000				   -
    659  27000				   -	       jmp	skiphschasecolors
    660  27000				   -
    661  27000				   -skipenterscorecontrol
    662  27000				   -	       jsr	hschasecolors
    663  27000				   -	       jsr	setuphsinpt1
    664  27000				   -	       lda	hsjoydebounce
    665  27000				   -	       bne	skiphschasecolors
    666  27000				   -	       lda	hsinpt1
    667  27000				   -	       bmi	returnfromhs
    668  27000				   -skiphschasecolors
    669  27000				   -
    670  27000				   -	       jsr	drawscreen
    671  27000				   -
    672  27000				   -	       lda	countdownseconds
    673  27000				   -	       beq	returnfromhs
    674  27000				   -	       jmp	keepdisplayinghs
    675  27000				   -returnfromhs
    676  27000				   -
    677  27000				   -	       ifconst	songdatastart_song_highscore
    678  27000				   -	       lda	hsdisplaymode
    679  27000				   -	       beq	skipclearHSCsong
    680  27000				   -	       lda	#0
    681  27000				   -	       sta	songtempo
    682  27000				   -skipclearHSCsong
    683  27000				   -	       endif
    684  27000				   -	       jsr	drawwait
    685  27000				   -	       jsr	clearscreen
    686  27000				   -	       lda	#0
    687  27000				   -	       ldy	#7
    688  27000				   -	       jsr	blacken320colors
    689  27000				   -	       lda	ssCTRL
    690  27000				   -	       sta	sCTRL
    691  27000				   -	       lda	ssCHARBASE
    692  27000				   -	       sta	sCHARBASE
    693  27000				   -	       rts
    694  27000				   -
    695  27000				   -setuphsinpt1
    696  27000				   -	       lda	#$ff
    697  27000				   -	       sta	hsinpt1
    698  27000				   -	       lda	hsjoydebounce
    699  27000				   -	       beq	skipdebounceadjust
    700  27000				   -	       dec	hsjoydebounce
    701  27000				   -	       bne	skipstorefirebuttonstatus
    702  27000				   -skipdebounceadjust
    703  27000				   -	       lda	SWCHB
    704  27000				   -	       and	#%00000001
    705  27000				   -	       bne	hscheckresetover
    706  27000				   -	       lda	#$ff
    707  27000				   -	       sta	hsinpt1
    708  27000				   -	       rts
    709  27000				   -hscheckresetover
    710  27000				   -	       ldx	hsdisplaymode
    711  27000				   -	       cpx	#3
    712  27000				   -	       bne	hsskipadjustjoyfire1
    713  27000				   -	       lda	sINPT3
    714  27000				   -	       jmp	hsskipadjustjoyfire1done
    715  27000				   -hsskipadjustjoyfire1
    716  27000				   -	       lda	sINPT1
    717  27000				   -hsskipadjustjoyfire1done
    718  27000				   -	       sta	hsinpt1
    719  27000				   -skipstorefirebuttonstatus
    720  27000				   -	       rts
    721  27000				   -
    722  27000				   -blacken320colors
    723  27000				   -	       ldy	#7
    724  27000				   -blacken320colorsloop
    725  27000				   -	       sta	P0C2,y
    726  27000				   -	       dey
    727  27000				   -	       bpl	blacken320colorsloop
    728  27000				   -	       rts
    729  27000				   -
    730  27000				   -hschasecolors
    731  27000				   -	       lda	framecounter
    732  27000				   -	       and	#3
    733  27000				   -	       bne	hschasecolorsreturn
    734  27000				   -	       inc	hscolorchaseindex
    735  27000				   -	       lda	hscolorchaseindex
    736  27000				   -
    737  27000				   -	       sta	P5C2
    738  27000				   -	       sbc	#$02
    739  27000				   -	       sta	P4C2
    740  27000				   -	       sbc	#$02
    741  27000				   -	       sta	P3C2
    742  27000				   -	       sbc	#$02
    743  27000				   -	       sta	P2C2
    744  27000				   -	       sbc	#$02
    745  27000				   -	       sta	P1C2
    746  27000				   -hschasecolorsreturn
    747  27000				   -	       rts
    748  27000				   -
    749  27000				   -playhssfx
    750  27000				   -	       lda	hssfx_lo,x
    751  27000				   -	       sta	temp1
    752  27000				   -	       lda	hssfx_hi,x
    753  27000				   -	       sta	temp2
    754  27000				   -	       lda	#0
    755  27000				   -	       sta	temp3
    756  27000				   -	       jmp	schedulesfx
    757  27000				   -
    758  27000				   -hssfx_lo
    759  27000				   -	       .byte	<sfx_hsletterpositionchange, <sfx_hslettertick
    760  27000				   -hssfx_hi
    761  27000				   -	       .byte	>sfx_hsletterpositionchange, >sfx_hslettertick
    762  27000				   -
    763  27000				   -sfx_hsletterpositionchange
    764  27000				   -	       .byte	$10,$18,$00
    765  27000				   -	       .byte	$02,$06,$08
    766  27000				   -	       .byte	$02,$06,$04
    767  27000				   -	       .byte	$00,$00,$00
    768  27000				   -sfx_hslettertick
    769  27000				   -	       .byte	$10,$18,$00
    770  27000				   -	       .byte	$00,$00,$0a
    771  27000				   -	       .byte	$00,$00,$00
    772  27000				   -
    773  27000				   -highscorelabeladjust1
    774  27000				   -	       .byte	(80-(14*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2))
    775  27000				   -highscorelabeladjust2
    776  27000				   -	       .byte	(80+(14*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2))
    777  27000				   -
    778  27000				   -scorevarlo
    779  27000				   -	       .byte	<(score0+((6-SCORESIZE)/2)),<(score0+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2))
    780  27000				   -scorevarhi
    781  27000				   -	       .byte	>(score0+((6-SCORESIZE)/2)),>(score0+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2))
    782  27000				   -
    783  27000				   -	       ifnconst	HSNOLEVELNAMES
    784  27000				   -highscoredifficultytextlo
    785  27000				   -	       .byte	<easylevelname, <mediumlevelname, <hardlevelname, <expertlevelname
    786  27000				   -highscoredifficultytexthi
    787  27000				   -	       .byte	>easylevelname, >mediumlevelname, >hardlevelname, >expertlevelname
    788  27000				   -	       ifnconst	HSCUSTOMLEVELNAMES
    789  27000				   -highscoredifficultytextlen
    790  27000				   -	       .byte	22, 30, 26, 24
    791  27000				   -
    792  27000				   -easylevelname
    793  27000				   -	       .byte	$04,$00,$12,$18,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    794  27000				   -mediumlevelname
    795  27000				   -	       .byte	$08,$0d,$13,$04,$11,$0c,$04,$03,$08,$00,$13,$04,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    796  27000				   -hardlevelname
    797  27000				   -	       .byte	$00,$03,$15,$00,$0d,$02,$04,$03,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    798  27000				   -expertlevelname
    799  27000				   -	       .byte	$04,$17,$0f,$04,$11,$13,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    800  27000				   -	       else
    801  27000				   -	       include	"7800hsgamediffnames.asm"
    802  27000				   -	       endif		; HSCUSTOMLEVELNAMES
    803  27000				   -	       else
    804  27000				   -HSHIGHSCOREStext
    805  27000				   -	       .byte	$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    806  27000				   -	       endif		; HSNOLEVELNAMES
    807  27000				   -
    808  27000				   -highscorelabeltextlo
    809  27000				   -	       .byte	<player0label, <player1label, <player2label, <player2label
    810  27000				   -highscorelabeltexthi
    811  27000				   -	       .byte	>player0label, >player1label, >player2label, >player2label
    812  27000				   -
    813  27000				   -player0label
    814  27000				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$12,$02,$0e,$11,$04,$1a,$1d,$1d
    815  27000				   -
    816  27000				   -player1label
    817  27000				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$22,$1d,$12,$02,$0e,$11,$04,$1a
    818  27000				   -
    819  27000				   -player2label
    820  27000				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$23,$1d,$12,$02,$0e,$11,$04,$1a
    821  27000				   -
    822  27000				   -
    823  27000				   -	       ifconst	HSGAMENAMELEN
    824  27000				   -HSGAMENAMEtable
    825  27000				   -	       include	"7800hsgamename.asm"
    826  27000				   -	       endif
    827  27000				   -	       ifconst	HSGAMERANKS
    828  27000				   -	       include	"7800hsgameranks.asm"
    829  27000				   -highscoreranklabel
    830  27000				   -	       .byte	$11,$00,$0d,$0a,$1a
    831  27000				   -	       endif
    832  27000				   -
    833  27000				   -			;ensure our table doesn't wrap a page...
    834  27000				   -	       if	((<*)>251)
    835  27000				   -	       align	256
    836  27000				   -	       endif
    837  27000				   -hsgameslotnumbers
    838  27000				   -	       .byte	33,34,35,36,37
    839  27000				   -	       endif
    840  27000				   -
    841  27000				   -loaddifficultytable
    842  27000				   -	       lda	gamedifficulty
    843  27000				   -	       and	#$03	; ensure the user hasn't selected an invalid difficulty
    844  27000				   -	       sta	gamedifficulty
    845  27000				   -	       cmp	hsdifficulty	; check game difficulty is the same as RAM table
    846  27000				   -	       bne	loaddifficultytablecontinue1
    847  27000				   -	       rts		; this high score difficulty table is already loaded
    848  27000				   -loaddifficultytablecontinue1
    849  27000				   -	       lda	gamedifficulty
    850  27000				   -	       sta	hsdifficulty
    851  27000				   -			;we need to check the device for the table
    852  27000				   -	       lda	hsdevice
    853  27000				   -	       bne	loaddifficultytablecontinue2
    854  27000				   -			; there's no save device. clear out this table.
    855  27000				   -	       jmp	cleardifficultytablemem
    856  27000				   -loaddifficultytablecontinue2
    857  27000				   -	       lda	hsdevice
    858  27000				   -	       and	#1
    859  27000				   -	       beq	memdeviceisntHSC
    860  27000				   -	       jmp	loaddifficultytableHSC
    861  27000				   -memdeviceisntHSC
    862  27000				   -	       jmp	loaddifficultytableAVOX
    863  27000				   -
    864  27000				   -savedifficultytable
    865  27000				   -			;*** we need to check which device we should use...
    866  27000				   -	       lda	hsdevice
    867  27000				   -	       bne	savedifficultytablerealdevice
    868  27000				   -	       rts		; its a ram device
    869  27000				   -savedifficultytablerealdevice
    870  27000				   -	       and	#1
    871  27000				   -	       beq	savememdeviceisntHSC
    872  27000				   -	       jmp	savedifficultytableHSC
    873  27000				   -savememdeviceisntHSC
    874  27000				   -	       jmp	savedifficultytableAVOX
    875  27000				   -
    876  27000				   -savedifficultytableAVOX
    877  27000				   -			; the load call already setup the memory structure and atarivox memory location
    878  27000				   -	       jsr	savealoadedHSCtablecontinue
    879  27000				   -savedifficultytableAVOXskipconvert
    880  27000				   -	       lda	#HSIDHI
    881  27000				   -	       sta	eeprombuffer
    882  27000				   -	       lda	#HSIDLO
    883  27000				   -	       sta	eeprombuffer+1
    884  27000				   -	       lda	hsdifficulty
    885  27000				   -	       sta	eeprombuffer+2
    886  27000				   -	       lda	#32
    887  27000				   -	       jsr	AVoxWriteBytes
    888  27000				   -	       rts
    889  27000				   -
    890  27000				   -savedifficultytableHSC
    891  27000				   -			;we always load a table before reaching here, so the
    892  27000				   -			;memory structures from the load should be intact...
    893  27000				   -	       ldy	hsgameslot
    894  27000				   -	       bpl	savealoadedHSCtable
    895  27000				   -	       rts
    896  27000				   -savealoadedHSCtable
    897  27000				   -	       lda	HSCGameDifficulty,y
    898  27000				   -	       cmp	#$7F
    899  27000				   -	       bne	savealoadedHSCtablecontinue
    900  27000				   -	       jsr	initializeHSCtableentry
    901  27000				   -savealoadedHSCtablecontinue
    902  27000				   -			;convert our RAM table to HSC format and write it out...
    903  27000				   -	       ldy	#0
    904  27000				   -	       ldx	#0
    905  27000				   -savedifficultytableScores
    906  27000				   -
    907  27000				   -	       lda	HSRAMInitials,x
    908  27000				   -	       sta	temp3
    909  27000				   -	       lda	HSRAMInitials+1,x
    910  27000				   -	       sta	temp4
    911  27000				   -	       lda	HSRAMInitials+2,x
    912  27000				   -	       sta	temp5
    913  27000				   -	       jsr	encodeHSCInitials	; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
    914  27000				   -
    915  27000				   -	       lda	temp1
    916  27000				   -	       sta	(HSGameTableLo),y
    917  27000				   -	       iny
    918  27000				   -	       lda	temp2
    919  27000				   -	       sta	(HSGameTableLo),y
    920  27000				   -	       iny
    921  27000				   -
    922  27000				   -	       lda	HSRAMScores,x
    923  27000				   -	       sta	(HSGameTableLo),y
    924  27000				   -	       iny
    925  27000				   -	       lda	HSRAMScores+1,x
    926  27000				   -	       sta	(HSGameTableLo),y
    927  27000				   -	       iny
    928  27000				   -	       lda	HSRAMScores+2,x
    929  27000				   -	       sta	(HSGameTableLo),y
    930  27000				   -	       iny
    931  27000				   -	       inx
    932  27000				   -	       inx
    933  27000				   -	       inx		; +3
    934  27000				   -	       cpx	#15
    935  27000				   -	       bne	savedifficultytableScores
    936  27000				   -	       rts
    937  27000				   -
    938  27000				   -loaddifficultytableHSC
    939  27000				   -			; routine responsible for loading the difficulty table from HSC
    940  27000				   -	       jsr	findindexHSC
    941  27000				   -	       ldy	hsgameslot
    942  27000				   -	       lda	HSCGameDifficulty,y
    943  27000				   -	       cmp	#$7F
    944  27000				   -	       bne	loaddifficultytableHSCcontinue
    945  27000				   -			;there was an error. use a new RAM table instead...
    946  27000				   -	       jsr	initializeHSCtableentry
    947  27000				   -	       jmp	cleardifficultytablemem
    948  27000				   -loaddifficultytableHSCcontinue
    949  27000				   -			; parse the data into the HS memory...
    950  27000				   -	       ldy	#0
    951  27000				   -	       ldx	#0
    952  27000				   -loaddifficultytableScores
    953  27000				   -	       lda	(HSGameTableLo),y
    954  27000				   -	       sta	temp1
    955  27000				   -	       iny
    956  27000				   -	       lda	(HSGameTableLo),y
    957  27000				   -	       sta	temp2
    958  27000				   -	       jsr	decodeHSCInitials	; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
    959  27000				   -	       iny
    960  27000				   -	       lda	(HSGameTableLo),y
    961  27000				   -	       sta	HSRAMScores,x
    962  27000				   -	       lda	temp3
    963  27000				   -	       sta	HSRAMInitials,x
    964  27000				   -	       inx
    965  27000				   -	       iny
    966  27000				   -	       lda	(HSGameTableLo),y
    967  27000				   -	       sta	HSRAMScores,x
    968  27000				   -	       lda	temp4
    969  27000				   -	       sta	HSRAMInitials,x
    970  27000				   -	       inx
    971  27000				   -	       iny
    972  27000				   -	       lda	(HSGameTableLo),y
    973  27000				   -	       sta	HSRAMScores,x
    974  27000				   -	       lda	temp5
    975  27000				   -	       sta	HSRAMInitials,x
    976  27000				   -	       inx
    977  27000				   -	       iny
    978  27000				   -	       cpx	#15
    979  27000				   -	       bne	loaddifficultytableScores
    980  27000				   -	       rts
    981  27000				   -
    982  27000				   -decodeHSCInitials
    983  27000				   -			; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
    984  27000				   -			; 2 bytes are packed in the form: 22211111 22_33333
    985  27000				   -	       lda	#0
    986  27000				   -	       sta	temp4
    987  27000				   -	       lda	temp1
    988  27000				   -	       and	#%00011111
    989  27000				   -	       sta	temp3
    990  27000				   -
    991  27000				   -	       lda	temp2
    992  27000				   -	       and	#%00011111
    993  27000				   -	       sta	temp5
    994  27000				   -
    995  27000				   -	       lda	temp1
    996  27000				   -	       asl
    997  27000				   -	       rol	temp4
    998  27000				   -	       asl
    999  27000				   -	       rol	temp4
   1000  27000				   -	       asl
   1001  27000				   -	       rol	temp4
   1002  27000				   -	       lda	temp2
   1003  27000				   -	       asl
   1004  27000				   -	       rol	temp4
   1005  27000				   -	       asl
   1006  27000				   -	       rol	temp4
   1007  27000				   -	       rts
   1008  27000				   -encodeHSCInitials
   1009  27000				   -			; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
   1010  27000				   -			; 2 bytes are packed in the form: 22211111 22_33333
   1011  27000				   -			; start with packing temp1...
   1012  27000				   -	       lda	temp4
   1013  27000				   -	       and	#%00011100
   1014  27000				   -	       sta	temp1
   1015  27000				   -	       asl	temp1
   1016  27000				   -	       asl	temp1
   1017  27000				   -	       asl	temp1
   1018  27000				   -	       lda	temp3
   1019  27000				   -	       and	#%00011111
   1020  27000				   -	       ora	temp1
   1021  27000				   -	       sta	temp1
   1022  27000				   -			; ...temp1 is now packed, on to temp2...
   1023  27000				   -	       lda	temp5
   1024  27000				   -	       asl
   1025  27000				   -	       asl
   1026  27000				   -	       ror	temp4
   1027  27000				   -	       ror
   1028  27000				   -	       ror	temp4
   1029  27000				   -	       ror
   1030  27000				   -	       sta	temp2
   1031  27000				   -	       rts
   1032  27000				   -
   1033  27000				   -findindexHSCerror
   1034  27000				   -			;the HSC is stuffed. return the bad slot flag
   1035  27000				   -	       ldy	#$ff
   1036  27000				   -	       sty	hsgameslot
   1037  27000				   -	       rts
   1038  27000				   -
   1039  27000				   -findindexHSC
   1040  27000				   -HSCGameID1 =	$1029
   1041  27000				   -HSCGameID2 =	$106E
   1042  27000				   -HSCGameDifficulty =	$10B3
   1043  27000				   -HSCGameIndex =	$10F8
   1044  27000				   -			; routine responsible for finding the game index from HSC
   1045  27000				   -			; call with x=0 to create a new table if none exist, call with x=$ff to avoid creating new tables
   1046  27000				   -			; the HS loading routine will use x=$ff, the HS saving routine will use x=0
   1047  27000				   -	       ldy	#69	; start +1 to account for the dey
   1048  27000				   -findindexHSCloop
   1049  27000				   -	       dey
   1050  27000				   -	       bmi	findindexHSCerror
   1051  27000				   -	       lda	HSCGameDifficulty,y
   1052  27000				   -	       cmp	#$7F
   1053  27000				   -	       beq	findourindexHSC
   1054  27000				   -	       cmp	gamedifficulty
   1055  27000				   -	       bne	findindexHSCloop
   1056  27000				   -	       lda	HSCGameID1,y
   1057  27000				   -	       cmp	#HSIDHI
   1058  27000				   -	       bne	findindexHSCloop
   1059  27000				   -	       lda	HSCGameID2,y
   1060  27000				   -	       cmp	#HSIDLO
   1061  27000				   -	       bne	findindexHSCloop
   1062  27000				   -findourindexHSC
   1063  27000				   -			; if we're here we found our index in the table
   1064  27000				   -			; or we found the first empty one
   1065  27000				   -	       sty	hsgameslot
   1066  27000				   -	       jsr	setupHSCGamepointer	; setup the pointer to the HS Table for this game...
   1067  27000				   -	       rts
   1068  27000				   -
   1069  27000				   -
   1070  27000				   -initializeHSCtableentry
   1071  27000				   -	       ldy	hsgameslot
   1072  27000				   -			; we need to make a new entry...
   1073  27000				   -	       lda	#HSIDHI
   1074  27000				   -	       sta	HSCGameID1,y
   1075  27000				   -	       lda	#HSIDLO
   1076  27000				   -	       sta	HSCGameID2,y
   1077  27000				   -	       lda	gamedifficulty
   1078  27000				   -	       sta	HSCGameDifficulty,y
   1079  27000				   -	       ldx	#0
   1080  27000				   -fixHSDGameDifficultylistLoop
   1081  27000				   -	       inx
   1082  27000				   -	       txa
   1083  27000				   -	       sta	HSCGameIndex,y
   1084  27000				   -	       iny
   1085  27000				   -	       cpy	#69
   1086  27000				   -	       bne	fixHSDGameDifficultylistLoop
   1087  27000				   -	       rts
   1088  27000				   -
   1089  27000				   -setupHSCGamepointer
   1090  27000				   -			; this routines sets (HSGameTableLo) pointing to the game's HS table
   1091  27000				   -	       lda	#$17
   1092  27000				   -	       sta	HSGameTableHi
   1093  27000				   -	       lda	#$FA
   1094  27000				   -	       sta	HSGameTableLo
   1095  27000				   -setupHSCGamepointerLoop
   1096  27000				   -	       lda	HSGameTableLo
   1097  27000				   -	       sec
   1098  27000				   -	       sbc	#25
   1099  27000				   -	       sta	HSGameTableLo
   1100  27000				   -	       lda	HSGameTableHi
   1101  27000				   -	       sbc	#0
   1102  27000				   -	       sta	HSGameTableHi
   1103  27000				   -	       iny
   1104  27000				   -	       cpy	#69
   1105  27000				   -	       bne	setupHSCGamepointerLoop
   1106  27000				   -	       rts
   1107  27000				   -
   1108  27000				   -loaddifficultytableAVOX
   1109  27000				   -			; routine responsible for loading the difficulty table from Avox
   1110  27000				   -			; we reuse HSC routines to format data to/from our Avox RAM buffer...
   1111  27000				   -	       lda	#>(eeprombuffer+3)
   1112  27000				   -	       sta	HSGameTableHi
   1113  27000				   -	       lda	#<(eeprombuffer+3)
   1114  27000				   -	       sta	HSGameTableLo
   1115  27000				   -
   1116  27000				   -			; the start location in EEPROM, subtract 32...
   1117  27000				   -	       lda	#$5F
   1118  27000				   -	       sta	HSVoxHi
   1119  27000				   -	       lda	#$E0
   1120  27000				   -	       sta	HSVoxLo
   1121  27000				   -	       lda	#0
   1122  27000				   -	       sta	temp1
   1123  27000				   -loaddifficultytableAVOXloop
   1124  27000				   -	       inc	temp1
   1125  27000				   -	       beq	loaddifficultytableAVOXfull
   1126  27000				   -	       clc
   1127  27000				   -	       lda	HSVoxLo
   1128  27000				   -	       adc	#32
   1129  27000				   -	       sta	HSVoxLo
   1130  27000				   -	       lda	HSVoxHi
   1131  27000				   -	       adc	#0
   1132  27000				   -	       sta	HSVoxHi
   1133  27000				   -	       lda	#3
   1134  27000				   -	       jsr	AVoxReadBytes	; read in 3 bytes, ID1,ID2,Difficulty
   1135  27000				   -	       lda	eeprombuffer
   1136  27000				   -	       cmp	#$FF
   1137  27000				   -	       beq	loaddifficultytableAVOXempty
   1138  27000				   -	       cmp	#HSIDHI
   1139  27000				   -	       bne	loaddifficultytableAVOXloop
   1140  27000				   -	       lda	eeprombuffer+1
   1141  27000				   -	       cmp	#HSIDLO
   1142  27000				   -	       bne	loaddifficultytableAVOXloop
   1143  27000				   -	       lda	eeprombuffer+2
   1144  27000				   -	       cmp	gamedifficulty
   1145  27000				   -	       bne	loaddifficultytableAVOXloop
   1146  27000				   -loaddifficultytableAVOXdone
   1147  27000				   -	       lda	#32
   1148  27000				   -	       jsr	AVoxReadBytes
   1149  27000				   -	       jsr	loaddifficultytableHSCcontinue
   1150  27000				   -	       rts
   1151  27000				   -loaddifficultytableAVOXfull
   1152  27000				   -	       lda	#0
   1153  27000				   -	       sta	hsdevice	; looks like all 255 entries are taken... disable it.
   1154  27000				   -loaddifficultytableAVOXempty
   1155  27000				   -	       jmp	cleardifficultytablemem
   1156  27000				   -	       rts
   1157  27000				   -
   1158  27000				   -cleardifficultytablemem
   1159  27000				   -	       ldy	#29
   1160  27000				   -	       lda	#0
   1161  27000				   -cleardifficultytablememloop
   1162  27000				   -	       sta	HSRAMTable,y
   1163  27000				   -	       dey
   1164  27000				   -	       bpl	cleardifficultytablememloop
   1165  27000				   -	       rts
   1166  27000				   -hiscoremoduleend
   1167  27000				   -
   1168  27000				   -	       ifconst	DOUBLEWIDE
   1169  27000				   -plotvaluedw
   1170  27000				   -plotdigitcount =	temp6
   1171  27000				   -	       lda	#0
   1172  27000				   -	       tay
   1173  27000				   -	       ldx	valbufend
   1174  27000				   -
   1175  27000				   -	       lda	plotdigitcount
   1176  27000				   -	       and	#1
   1177  27000				   -	       beq	pvnibble2chardw
   1178  27000				   -	       lda	#0
   1179  27000				   -	       sta	VALBUFFER,x	; just in case we skip this digit
   1180  27000				   -	       beq	pvnibble2char_skipnibbledw
   1181  27000				   -
   1182  27000				   -pvnibble2chardw
   1183  27000				   -			; high nibble...
   1184  27000				   -	       lda	(temp7),y
   1185  27000				   -	       and	#$f0
   1186  27000				   -	       lsr
   1187  27000				   -	       lsr
   1188  27000				   -	       lsr
   1189  27000				   -	       lsr
   1190  27000				   -
   1191  27000				   -	       clc
   1192  27000				   -	       adc	temp1	; add the offset to character graphics to our value
   1193  27000				   -	       sta	VALBUFFER,x
   1194  27000				   -	       inx
   1195  27000				   -	       dec	plotdigitcount
   1196  27000				   -pvnibble2char_skipnibbledw
   1197  27000				   -			; low nibble...
   1198  27000				   -	       lda	(temp7),y
   1199  27000				   -	       and	#$0f
   1200  27000				   -	       clc
   1201  27000				   -	       adc	temp1	; add the offset to character graphics to our value
   1202  27000				   -	       sta	VALBUFFER,x
   1203  27000				   -	       inx
   1204  27000				   -	       iny
   1205  27000				   -
   1206  27000				   -	       dec	plotdigitcount
   1207  27000				   -	       bne	pvnibble2chardw
   1208  27000				   -			;point to the start of our valuebuffer
   1209  27000				   -	       clc
   1210  27000				   -	       lda	#<VALBUFFER
   1211  27000				   -	       adc	valbufend
   1212  27000				   -	       sta	temp1
   1213  27000				   -	       lda	#>VALBUFFER
   1214  27000				   -	       adc	#0
   1215  27000				   -	       sta	temp2
   1216  27000				   -
   1217  27000				   -			;advance valbufend to the end of our value buffer
   1218  27000				   -	       stx	valbufend
   1219  27000				   -
   1220  27000				   -	       ifnconst	plotvalueonscreen
   1221  27000				   -	       jmp	plotcharacters
   1222  27000				   -	       else
   1223  27000				   -	       jmp	plotcharacterslive
   1224  27000				   -	       endif
   1225  27000				   -	       endif		; DOUBLEWIDE
   1226  27000				   -
   1227  27000				   -hiscoreend
   1228  27000				   -	       echo	"  (hiscore module is using ",[(hiscoreend-hiscorestart)]d," bytes)"
   1229  27000					       endif		; HSSUPPORT
   1230  27000
------- FILE c:\Users\Jag\Desktop\plotmap scrolling doublebuffer\test.78b.asm
   6596  27000					       endif
   6597  27000					       ifnconst	included.fourbitfade.asm
------- FILE fourbitfade.asm LEVEL 2 PASS 3
      0  27000					       include	fourbitfade.asm
      1  27000							; ** fourbit fade, which is useful for audio levels and brightness fades
      2  27000							; ** input:  A=value to fade, fourbitfadevalue=global fade value
      3  27000							; **	      N.B. the global fade value is in the upper nibble. i.e. $Fx-0x
      4  27000							; ** output: A=faded value in lo nibble. orig top nibble is preserved,
      5  27000							; **	      other registers are preserved
      6  27000
      7  27000				   -	       ifconst	FOURBITFADE
      8  27000				   -
      9  27000				   -			; non-interrupt routine
     10  27000				   -
     11  27000				   -fourbitfade
     12  27000				   -	       sty	fourbittemp1
     13  27000				   -	       pha
     14  27000				   -	       and	#$0F
     15  27000				   -	       ora	fourbitfadevalue
     16  27000				   -	       tay
     17  27000				   -	       pla
     18  27000				   -	       and	#$F0
     19  27000				   -	       ora	fourbitfadelut,y
     20  27000				   -	       ldy	fourbittemp1	; restore Y
     21  27000				   -	       rts
     22  27000				   -
     23  27000				   -			; interrupt routine
     24  27000				   -
     25  27000				   -fourbitfadeint
     26  27000				   -	       sty	fourbittemp1int
     27  27000				   -	       pha
     28  27000				   -	       and	#$0F
     29  27000				   -	       ora	fourbitfadevalueint
     30  27000				   -	       tay
     31  27000				   -	       pla
     32  27000				   -	       and	#$F0
     33  27000				   -	       ora	fourbitfadelut,y
     34  27000				   -	       ldy	fourbittemp1int	; restore Y
     35  27000				   -	       rts
     36  27000				   -
     37  27000				   -fourbitfadelut
     38  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     39  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
     40  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02
     41  27000				   -	       .byte	$00,$00,$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03
     42  27000				   -	       .byte	$00,$00,$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04
     43  27000				   -	       .byte	$00,$00,$00,$01,$01,$01,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
     44  27000				   -	       .byte	$00,$00,$00,$01,$01,$02,$02,$03,$03,$03,$04,$04,$05,$05,$06,$06
     45  27000				   -	       .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
     46  27000				   -	       .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$05,$05,$06,$06,$07,$07,$08
     47  27000				   -	       .byte	$00,$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$06,$07,$08,$08,$09
     48  27000				   -	       .byte	$00,$00,$01,$02,$02,$03,$04,$04,$05,$06,$06,$07,$08,$08,$09,$0a
     49  27000				   -	       .byte	$00,$00,$01,$02,$03,$03,$04,$05,$06,$06,$07,$08,$09,$09,$0a,$0b
     50  27000				   -	       .byte	$00,$00,$01,$02,$03,$04,$04,$05,$06,$07,$08,$08,$09,$0a,$0b,$0c
     51  27000				   -	       .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0a,$0b,$0c,$0d
     52  27000				   -	       .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e
     53  27000				   -	       .byte	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e,$0f
     54  27000				   -
     55  27000				   -fourbitfadeend
     56  27000				   -
     57  27000				   -	       echo	"  (fourbitfade module is using ",[(fourbitfadeend-fourbitfade)]d," bytes)"
     58  27000				   -
     59  27000					       endif
------- FILE c:\Users\Jag\Desktop\plotmap scrolling doublebuffer\test.78b.asm
   6599  27000					       endif
   6600  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6601  27000
   6602  27000							;standard routimes needed for pretty much all games
   6603  27000
   6604  27000							; some definitions used with "set debug color"
   6605  27000			00 91	    DEBUGCALC  =	$91
   6606  27000			00 41	    DEBUGWASTE =	$41
   6607  27000			00 c1	    DEBUGDRAW  =	$C1
   6608  27000
   6609  27000							;NMI and IRQ handlers
   6610  27000				    NMI
   6611  27000							;VISIBLEOVER is 255 while the screen is drawn, and 0 right after the visible screen is done.
   6612  27000			48		       pha		; save A
   6613  27001			d8		       cld
   6614  27002			a5 4d		       lda	visibleover
   6615  27004			49 ff		       eor	#255
   6616  27006			85 4d		       sta	visibleover
   6617  27008				   -	       ifconst	DEBUGINTERRUPT
   6618  27008				   -	       and	#$93
   6619  27008				   -	       sta	BACKGRND
   6620  27008					       endif
   6621  27008			8a		       txa		; save X
   6622  27009			48		       pha
   6623  2700a			98		       tya		; save Y
   6624  2700b			48		       pha
   6625  2700c			ce b2 01	       dec	interruptindex
   6626  2700f			d0 03		       bne	skipreallyoffvisible
   6627  27011			4c 73 f0	       jmp	reallyoffvisible
   6628  27014				    skipreallyoffvisible
   6629  27014			a5 4d		       lda	visibleover
   6630  27016			d0 03		       bne	carryontopscreenroutine
   6631  27018				   -	       ifconst	.bottomscreenroutine
   6632  27018				   -	       lda	interrupthold
   6633  27018				   -	       beq	skipbottomroutine
   6634  27018				   -	       jsr	.bottomscreenroutine
   6635  27018				   -skipbottomroutine
   6636  27018					       endif
   6637  27018			4c 81 f0	       jmp	NMIexit
   6638  2701b				    carryontopscreenroutine
   6639  2701b				   -	       ifconst	.topscreenroutine
   6640  2701b				   -	       lda	interrupthold
   6641  2701b				   -	       beq	skiptoproutine
   6642  2701b				   -	       jsr	.topscreenroutine
   6643  2701b				   -skiptoproutine
   6644  2701b					       endif
   6645  2701b					       ifnconst	CANARYOFF
   6646  2701b			ad c3 01	       lda	canary
   6647  2701e			f0 07		       beq	skipcanarytriggered
   6648  27020			a9 45		       lda	#$45
   6649  27022			85 20		       sta	BACKGRND
   6650  27024			4c 6b f0	       jmp	skipbrkolorset	; common crash dump routine, if available
   6651  27027				    skipcanarytriggered
   6652  27027					       endif
   6653  27027
   6654  27027			ee 3e 21	       inc	frameslost	; this is balanced with a "dec frameslost" when drawscreen is called.
   6655  2702a
   6656  2702a							; ** Other important routines that need to regularly run, and can run onscreen.
   6657  2702a							; ** Atarivox can't go here, because Maria might interrupt it while it's bit-banging.
   6658  2702a
   6659  2702a				   -	       ifconst	LONGCONTROLLERREAD
   6660  2702a				   -longcontrollerreads 		; ** controllers that take a lot of time to read. We use much of the visible screen here.
   6661  2702a				   -	       ldy	port1control
   6662  2702a				   -	       lda	longreadtype,y
   6663  2702a				   -	       beq	LLRET1
   6664  2702a				   -	       tay
   6665  2702a				   -	       lda	longreadroutinehiP1,y
   6666  2702a				   -	       sta	inttemp4
   6667  2702a				   -	       lda	longreadroutineloP1,y
   6668  2702a				   -	       sta	inttemp3
   6669  2702a				   -	       jmp	(inttemp3)
   6670  2702a				   -LLRET1
   6671  2702a				   -	       ldy	port0control
   6672  2702a				   -	       lda	longreadtype,y
   6673  2702a				   -	       beq	LLRET0
   6674  2702a				   -	       tay
   6675  2702a				   -	       lda	longreadroutinehiP0,y
   6676  2702a				   -	       sta	inttemp4
   6677  2702a				   -	       lda	longreadroutineloP0,y
   6678  2702a				   -	       sta	inttemp3
   6679  2702a				   -	       jmp	(inttemp3)
   6680  2702a				   -LLRET0
   6681  2702a				   -
   6682  2702a				   -
   6683  2702a				   -	       ifconst	PADDLERANGE
   6684  2702a				   -TIMEVAL    =	PADDLERANGE
   6685  2702a				   -	       else
   6686  2702a				   -TIMEVAL    =	160
   6687  2702a				   -	       endif
   6688  2702a				   -TIMEOFFSET =	10
   6689  2702a				   -
   6690  2702a					       endif		; LONGCONTROLLERREAD
   6691  2702a
   6692  2702a
   6693  2702a			20 fa f1	       jsr	servicesfxchannels
   6694  2702d				   -	       ifconst	MUSICTRACKER
   6695  2702d				   -	       jsr	servicesong
   6696  2702d					       endif		; MUSICTRACKER
   6697  2702d				   -	       ifconst	RMT
   6698  2702d				   -	       lda	rasterpause
   6699  2702d				   -	       beq	skiprasterupdate
   6700  2702d				   -	       jsr	RASTERMUSICTRACKER+3
   6701  2702d				   -skiprasterupdate
   6702  2702d				   -RMT_Iend
   6703  2702d					       endif
   6704  2702d
   6705  2702d			ee a4 01	       inc	framecounter
   6706  27030			ad a4 01	       lda	framecounter
   6707  27033			29 3f		       and	#63
   6708  27035			d0 08		       bne	skipcountdownseconds
   6709  27037			ad a5 01	       lda	countdownseconds
   6710  2703a			f0 03		       beq	skipcountdownseconds
   6711  2703c			ce a5 01	       dec	countdownseconds
   6712  2703f				    skipcountdownseconds
   6713  2703f
   6714  2703f			a2 01		       ldx	#1
   6715  27041				    buttonreadloop
   6716  27041			8a		       txa
   6717  27042			48		       pha
   6718  27043			bc b9 01	       ldy	port0control,x
   6719  27046			b9 d7 f1	       lda	buttonhandlerlo,y
   6720  27049			85 da		       sta	inttemp3
   6721  2704b			b9 cb f1	       lda	buttonhandlerhi,y
   6722  2704e			85 db		       sta	inttemp4
   6723  27050			05 da		       ora	inttemp3
   6724  27052			f0 03		       beq	buttonreadloopreturn
   6725  27054			6c da 00	       jmp	(inttemp3)
   6726  27057				    buttonreadloopreturn
   6727  27057			68		       pla
   6728  27058			aa		       tax
   6729  27059			ca		       dex
   6730  2705a			10 e5		       bpl	buttonreadloop
   6731  2705c
   6732  2705c				   -	       ifconst	KEYPADSUPPORT
   6733  2705c				   -	       jsr	keypadrowselect
   6734  2705c					       endif		; KEYPADSUPPORT
   6735  2705c
   6736  2705c
   6737  2705c					       ifconst	DOUBLEBUFFER
   6738  2705c			ad b4 01	       lda	doublebufferminimumframeindex
   6739  2705f			f0 03		       beq	skipdoublebufferminimumframeindexadjust
   6740  27061			ce b4 01	       dec	doublebufferminimumframeindex
   6741  27064				    skipdoublebufferminimumframeindexadjust
   6742  27064					       endif
   6743  27064
   6744  27064			4c 81 f0	       jmp	NMIexit
   6745  27067
   6746  27067				    IRQ 		; the only source of non-nmi interrupt should be the BRK opcode.
   6747  27067					       ifnconst	BREAKPROTECTOFF
   6748  27067			a9 1a		       lda	#$1A
   6749  27069			85 20		       sta	BACKGRND
   6750  2706b				    skipbrkolorset
   6751  2706b				    skipbrkdetected
   6752  2706b			a9 60		       lda	#$60
   6753  2706d			8d 07 21	       sta	sCTRL
   6754  27070			85 3c		       sta	CTRL
   6755  27072					       ifnconst	hiscorefont
   6756  27072			02		       .byte.b	$02	; KIL/JAM
   6757  27073				   -	       else		; hiscorefont is present
   6758  27073				   -	       ifconst	CRASHDUMP
   6759  27073				   -	       bit	MSTAT
   6760  27073				   -	       bpl	skipbrkdetected	; wait for vblank to ensure we're clear of NMI
   6761  27073				   -
   6762  27073				   -	       ifconst	dumpbankswitch
   6763  27073				   -	       lda	dumpbankswitch
   6764  27073				   -	       pha
   6765  27073				   -	       endif
   6766  27073				   -
   6767  27073				   -			; bankswitch if needed, to get to the hiscore font
   6768  27073				   -	       ifconst	bankswitchmode
   6769  27073				   -	       ifconst	included.hiscore.asm.bank
   6770  27073				   -	       ifconst	MCPDEVCART
   6771  27073				   -	       lda	#($18 | included.hiscore.asm.bank)
   6772  27073				   -	       sta	$3000
   6773  27073				   -	       else
   6774  27073				   -	       lda	#(included.hiscore.asm.bank)
   6775  27073				   -	       sta	$8000
   6776  27073				   -	       endif
   6777  27073				   -	       endif		; included.hiscore.asm.bank
   6778  27073				   -	       endif		; bankswitchmode
   6779  27073				   -
   6780  27073				   -	       ifconst	DOUBLEBUFFER
   6781  27073				   -			;turn off double-buffering, if on...
   6782  27073				   -	       lda	#>DLLMEM
   6783  27073				   -	       sta	DPPH
   6784  27073				   -	       lda	#<DLLMEM
   6785  27073				   -	       sta	DPPL
   6786  27073				   -	       endif
   6787  27073				   -
   6788  27073				   -	       lda	#$00
   6789  27073				   -	       sta	P0C2
   6790  27073				   -
   6791  27073				   -			;update the second-from-top DL...
   6792  27073				   -	       ldy	#8
   6793  27073				   -NMIupdatetopDL
   6794  27073				   -	       lda	show2700,y
   6795  27073				   -	       sta	ZONE1ADDRESS,y
   6796  27073				   -	       dey
   6797  27073				   -	       bpl	NMIupdatetopDL
   6798  27073				   -
   6799  27073				   -			; the hiscore font is present, so we try to output the stack
   6800  27073				   -	       ldy	#0
   6801  27073				   -copystackloop
   6802  27073				   -	       pla
   6803  27073				   -	       pha
   6804  27073				   -	       lsr
   6805  27073				   -	       lsr
   6806  27073				   -	       lsr
   6807  27073				   -	       lsr
   6808  27073				   -	       tax
   6809  27073				   -	       lda	hiscorehexlut,x
   6810  27073				   -	       sta	$2700,y
   6811  27073				   -	       iny
   6812  27073				   -
   6813  27073				   -	       pla
   6814  27073				   -	       and	#$0F
   6815  27073				   -	       tax
   6816  27073				   -	       lda	hiscorehexlut,x
   6817  27073				   -	       sta	$2700,y
   6818  27073				   -	       iny
   6819  27073				   -
   6820  27073				   -	       lda	#27	; period
   6821  27073				   -	       sta	$2700,y
   6822  27073				   -	       iny
   6823  27073				   -
   6824  27073				   -	       cpy	#30
   6825  27073				   -	       bne	copystackloop
   6826  27073				   -
   6827  27073				   -	       lda	#>hiscorefont
   6828  27073				   -	       sta	CHARBASE
   6829  27073				   -	       sta	sCHARBASE
   6830  27073				   -	       lda	#%01000011	;Enable DMA, mode=320A
   6831  27073				   -	       sta	CTRL
   6832  27073				   -	       sta	sCTRL
   6833  27073				   -	       .byte	$02	; KIL/JAM
   6834  27073				   -hiscorehexlut
   6835  27073				   -			;	  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
   6836  27073				   -	       .byte	33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 0, 1, 2, 3, 4, 5
   6837  27073				   -show2700
   6838  27073				   -			;	 lo   mode	   hi	width=29  x   EODL
   6839  27073				   -	       .byte	$00, %01100000, $27, 3, 20, 0,0,0
   6840  27073				   -	       else		; CRASHDUMP
   6841  27073				   -	       .byte	$02	; KIL/JAM
   6842  27073				   -	       endif		; crashdump
   6843  27073					       endif		; hiscorefont
   6844  27073				   -	       else
   6845  27073				   -	       RTI
   6846  27073					       endif
   6847  27073
   6848  27073				   -	       ifconst	LONGCONTROLLERREAD
   6849  27073				   -
   6850  27073				   -longreadtype
   6851  27073				   -	       .byte	0, 0, 0, 1	; NONE     PROLINE   LIGHTGUN	PADDLE
   6852  27073				   -	       .byte	2, 0, 3, 0	; TRKBALL  VCSSTICK  DRIVING	KEYPAD
   6853  27073				   -	       .byte	3, 3, 0, 0	; STMOUSE  AMOUSE    ATARIVOX	SNES
   6854  27073				   -
   6855  27073				   -longreadroutineloP0
   6856  27073				   -	       .byte	<LLRET0	;  0 = no routine
   6857  27073				   -	       .byte	<paddleport0update	;  1 = paddle
   6858  27073				   -	       .byte	<trakball0update	;  2 = trakball
   6859  27073				   -	       .byte	<mouse0update	;  3 = mouse
   6860  27073				   -
   6861  27073				   -longreadroutinehiP0
   6862  27073				   -	       .byte	>LLRET0	;  0 = no routine
   6863  27073				   -	       .byte	>paddleport0update	;  1 = paddle
   6864  27073				   -	       .byte	>trakball0update	;  2 = trackball
   6865  27073				   -	       .byte	>mouse0update	;  3 = mouse
   6866  27073				   -
   6867  27073				   -longreadroutineloP1
   6868  27073				   -	       .byte	<LLRET1	;  0 = no routine
   6869  27073				   -	       .byte	<paddleport1update	;  1 = paddle
   6870  27073				   -	       .byte	<trakball1update	;  2 = trakball
   6871  27073				   -	       .byte	<mouse1update	;  3 = mouse
   6872  27073				   -
   6873  27073				   -longreadroutinehiP1
   6874  27073				   -	       .byte	>LLRET1	;  0 = no routine
   6875  27073				   -	       .byte	>paddleport1update	;  1 = paddle
   6876  27073				   -	       .byte	>trakball1update	;  2 = trackball
   6877  27073				   -	       .byte	>mouse1update	;  3 = mouse
   6878  27073				   -
   6879  27073				   -
   6880  27073				   -SETTIM64T
   6881  27073				   -	       bne	skipdefaulttime
   6882  27073				   -	       ifnconst	PADDLESMOOTHINGOFF
   6883  27073				   -	       lda	#(TIMEVAL+TIMEOFFSET+1)
   6884  27073				   -	       else
   6885  27073				   -	       lda	#(TIMEVAL+TIMEOFFSET)
   6886  27073				   -	       endif
   6887  27073				   -skipdefaulttime
   6888  27073				   -	       tay
   6889  27073				   -	       dey
   6890  27073				   -.setTIM64Tloop
   6891  27073				   -	       sta	TIM64T
   6892  27073				   -	       cpy	INTIM
   6893  27073				   -	       bne	.setTIM64Tloop
   6894  27073				   -	       rts
   6895  27073					       endif		; LONGCONTROLLERREAD
   6896  27073
   6897  27073				    reallyoffvisible
   6898  27073			85 24		       sta	WSYNC
   6899  27075
   6900  27075			a9 00		       lda	#0
   6901  27077			85 4d		       sta	visibleover
   6902  27079				   -	       ifconst	DEBUGINTERRUPT
   6903  27079				   -	       sta	BACKGRND
   6904  27079					       endif
   6905  27079
   6906  27079			a9 03		       lda	#3
   6907  2707b			8d b2 01	       sta	interruptindex
   6908  2707e
   6909  2707e			20 6c f1	       jsr	uninterruptableroutines
   6910  27081
   6911  27081				   -	       ifconst	.userinterrupt
   6912  27081				   -	       lda	interrupthold
   6913  27081				   -	       beq	skipuserintroutine
   6914  27081				   -	       jsr	.userinterrupt
   6915  27081				   -skipuserintroutine
   6916  27081					       endif
   6917  27081
   6918  27081				   -	       ifconst	KEYPADSUPPORT
   6919  27081				   -	       jsr	keypadcolumnread
   6920  27081					       endif
   6921  27081
   6922  27081				    NMIexit
   6923  27081			68		       pla
   6924  27082			a8		       tay
   6925  27083			68		       pla
   6926  27084			aa		       tax
   6927  27085			68		       pla
   6928  27086			40		       RTI
   6929  27087
   6930  27087				    clearscreen
   6931  27087			a2 0d		       ldx	#(WZONECOUNT-1)
   6932  27089			a9 00		       lda	#0
   6933  2708b				    clearscreenloop
   6934  2708b			95 65		       sta	dlend,x
   6935  2708d			ca		       dex
   6936  2708e			10 fb		       bpl	clearscreenloop
   6937  27090			a9 00		       lda	#0
   6938  27092			8d ad 01	       sta	valbufend	; clear the bcd value buffer
   6939  27095			8d ae 01	       sta	valbufendsave
   6940  27098			60		       rts
   6941  27099
   6942  27099				    restorescreen
   6943  27099			a2 0d		       ldx	#(WZONECOUNT-1)
   6944  2709b			a9 00		       lda	#0
   6945  2709d				    restorescreenloop
   6946  2709d			b5 82		       lda	dlendsave,x
   6947  2709f			95 65		       sta	dlend,x
   6948  270a1			ca		       dex
   6949  270a2			10 f9		       bpl	restorescreenloop
   6950  270a4			ad ae 01	       lda	valbufendsave
   6951  270a7			8d ad 01	       sta	valbufend
   6952  270aa			60		       rts
   6953  270ab
   6954  270ab				    savescreen
   6955  270ab			a2 0d		       ldx	#(WZONECOUNT-1)
   6956  270ad				    savescreenloop
   6957  270ad			b5 65		       lda	dlend,x
   6958  270af			95 82		       sta	dlendsave,x
   6959  270b1			ca		       dex
   6960  270b2			10 f9		       bpl	savescreenloop
   6961  270b4			ad ad 01	       lda	valbufend
   6962  270b7			8d ae 01	       sta	valbufendsave
   6963  270ba					       ifconst	DOUBLEBUFFER
   6964  270ba			a5 d5		       lda	doublebufferstate
   6965  270bc			f0 04		       beq	savescreenrts
   6966  270be			a9 01		       lda	#1
   6967  270c0			85 d7		       sta	doublebufferbufferdirty
   6968  270c2				    savescreenrts
   6969  270c2					       endif		; DOUBLEBUFFER
   6970  270c2			60		       rts
   6971  270c3
   6972  270c3				    drawscreen
   6973  270c3
   6974  270c3				   -	       ifconst	interrupthold
   6975  270c3				   -	       lda	#$FF
   6976  270c3				   -	       sta	interrupthold	; if the user called drawscreen, we're ready for interrupts
   6977  270c3					       endif
   6978  270c3
   6979  270c3			a9 00		       lda	#0
   6980  270c5			85 42		       sta	temp1	; not B&W if we're here...
   6981  270c7
   6982  270c7				    drawscreenwait
   6983  270c7			a5 4d		       lda	visibleover
   6984  270c9			d0 fc		       bne	drawscreenwait	; make sure the visible screen isn't being drawn
   6985  270cb
   6986  270cb							;restore some registers in case the game changed them mid-screen...
   6987  270cb			ad 07 21	       lda	sCTRL
   6988  270ce			05 42		       ora	temp1
   6989  270d0			85 3c		       sta	CTRL
   6990  270d2			ad 0b 21	       lda	sCHARBASE
   6991  270d5			85 34		       sta	CHARBASE
   6992  270d7
   6993  270d7							;ensure all of the display list is terminated...
   6994  270d7			20 49 f1	       jsr	terminatedisplaylist
   6995  270da
   6996  270da					       ifnconst	pauseroutineoff
   6997  270da			20 e5 f0	       jsr	pauseroutine
   6998  270dd					       endif		; pauseroutineoff
   6999  270dd
   7000  270dd							; Make sure the visible screen has *started* before we exit. That way we can rely on drawscreen
   7001  270dd							; delaying a full frame, but still allowing time for basic calculations.
   7002  270dd				    visiblescreenstartedwait
   7003  270dd			a5 4d		       lda	visibleover
   7004  270df			f0 fc		       beq	visiblescreenstartedwait
   7005  270e1				    visiblescreenstartedwaitdone
   7006  270e1			ce 3e 21	       dec	frameslost	; ; this gets balanced with an "inc frameslost" by an NMI at the top of the screen
   7007  270e4			60		       rts
   7008  270e5
   7009  270e5					       ifnconst	pauseroutineoff
   7010  270e5							; check to see if pause was pressed and released
   7011  270e5				    pauseroutine
   7012  270e5			ad b5 01	       lda	pausedisable
   7013  270e8			d0 4e		       bne	leavepauseroutine
   7014  270ea			a9 08		       lda	#8
   7015  270ec			2c 82 02	       bit	SWCHB
   7016  270ef			f0 29		       beq	pausepressed
   7017  270f1
   7018  270f1					       ifnconst	SOFTRESETASPAUSEOFF
   7019  270f1					       ifnconst	MOUSESUPPORT
   7020  270f1					       ifnconst	TRAKBALLSUPPORT
   7021  270f1			ad 80 02	       lda	SWCHA	; then check the soft "RESET" joysick code...
   7022  270f4			29 70		       and	#%01110000	; _LDU
   7023  270f6			f0 22		       beq	pausepressed
   7024  270f8					       endif
   7025  270f8					       endif
   7026  270f8					       endif
   7027  270f8
   7028  270f8							;pause isn't pressed
   7029  270f8			a9 00		       lda	#0
   7030  270fa			8d ac 01	       sta	pausebuttonflag	; clear pause hold state in case its set
   7031  270fd
   7032  270fd							;check if we're in an already paused state
   7033  270fd			ad 00 21	       lda	pausestate
   7034  27100			f0 36		       beq	leavepauseroutine	; nope, leave
   7035  27102
   7036  27102			c9 01		       cmp	#1	; last frame was the start of pausing
   7037  27104			f0 2b		       beq	enterpausestate2	; move from state 1 to 2
   7038  27106
   7039  27106			c9 02		       cmp	#2
   7040  27108			f0 34		       beq	carryonpausing
   7041  2710a
   7042  2710a							;pausestate must be >2, which means we're ending an unpause 
   7043  2710a			a9 00		       lda	#0
   7044  2710c			8d ac 01	       sta	pausebuttonflag
   7045  2710f			8d 00 21	       sta	pausestate
   7046  27112			ad 07 21	       lda	sCTRL
   7047  27115			85 3c		       sta	CTRL
   7048  27117			4c 38 f1	       jmp	leavepauseroutine
   7049  2711a
   7050  2711a				    pausepressed
   7051  2711a							;pause is pressed
   7052  2711a			ad ac 01	       lda	pausebuttonflag
   7053  2711d			c9 ff		       cmp	#$ff
   7054  2711f			f0 1d		       beq	carryonpausing
   7055  27121
   7056  27121							;its a new press, increment the state
   7057  27121			ee 00 21	       inc	pausestate
   7058  27124
   7059  27124							;silence volume at the start and end of pausing
   7060  27124			a9 00		       lda	#0
   7061  27126			85 19		       sta	AUDV0
   7062  27128			85 1a		       sta	AUDV1
   7063  2712a
   7064  2712a				   -	       ifconst	pokeysupport
   7065  2712a				   -	       ldy	#7
   7066  2712a				   -pausesilencepokeyaudioloop
   7067  2712a				   -	       sta	(pokeybase),y
   7068  2712a				   -	       dey
   7069  2712a				   -	       bpl	pausesilencepokeyaudioloop
   7070  2712a					       endif		; pokeysupport
   7071  2712a
   7072  2712a			a9 ff		       lda	#$ff
   7073  2712c			8d ac 01	       sta	pausebuttonflag
   7074  2712f			d0 0d		       bne	carryonpausing
   7075  27131
   7076  27131				    enterpausestate2
   7077  27131			a9 02		       lda	#2
   7078  27133			8d 00 21	       sta	pausestate
   7079  27136			d0 06		       bne	carryonpausing
   7080  27138				    leavepauseroutine
   7081  27138			ad 07 21	       lda	sCTRL
   7082  2713b			85 3c		       sta	CTRL
   7083  2713d			60		       rts
   7084  2713e				    carryonpausing
   7085  2713e				   -	       ifconst	.pause
   7086  2713e				   -	       jsr	.pause
   7087  2713e					       endif		; .pause
   7088  2713e			ad 07 21	       lda	sCTRL
   7089  27141			09 80		       ora	#%10000000	; turn off colorburst during pause...
   7090  27143			85 3c		       sta	CTRL
   7091  27145			4c e5 f0	       jmp	pauseroutine
   7092  27148					       endif		; pauseroutineoff
   7093  27148
   7094  27148
   7095  27148					       ifconst	DOUBLEBUFFER
   7096  27148				    skipterminatedisplaylistreturn
   7097  27148			60		       rts
   7098  27149					       endif		; DOUBLEBUFFER
   7099  27149				    terminatedisplaylist
   7100  27149					       ifconst	DOUBLEBUFFER
   7101  27149			a5 d5		       lda	doublebufferstate
   7102  2714b			d0 fb		       bne	skipterminatedisplaylistreturn	; double-buffering runs it's own DL termination code
   7103  2714d					       endif		; DOUBLEBUFFER
   7104  2714d				    terminatedisplaybuffer
   7105  2714d							;add DL end entry on each DL
   7106  2714d			a2 0d		       ldx	#(WZONECOUNT-1)
   7107  2714f				    dlendloop
   7108  2714f			bd 98 f6	       lda	DLPOINTL,x
   7109  27152					       ifconst	DOUBLEBUFFER
   7110  27152			18		       clc
   7111  27153			65 d6		       adc	doublebufferdloffset
   7112  27155					       endif		; DOUBLEBUFFER
   7113  27155			85 63		       sta	dlpnt
   7114  27157			bd 8a f6	       lda	DLPOINTH,x
   7115  2715a					       ifconst	DOUBLEBUFFER
   7116  2715a			69 00		       adc	#0
   7117  2715c					       endif		; DOUBLEBUFFER
   7118  2715c			85 64		       sta	dlpnt+1
   7119  2715e			b4 65		       ldy	dlend,x
   7120  27160			a9 00		       lda	#$00
   7121  27162				    dlendmoreloops
   7122  27162			c8		       iny
   7123  27163			91 63		       sta	(dlpnt),y
   7124  27165				   -	       ifconst	FRAMESKIPGLITCHFIXWEAK
   7125  27165				   -	       cpy	#DLLASTOBJ+1
   7126  27165				   -	       beq	dlendthiszonedone
   7127  27165				   -	       iny
   7128  27165				   -	       iny
   7129  27165				   -	       iny
   7130  27165				   -	       iny
   7131  27165				   -	       iny
   7132  27165				   -	       sta	(dlpnt),y
   7133  27165				   -dlendthiszonedone
   7134  27165					       endif	FRAMESKIPGLITCHFIXWEAK
   7135  27165				   -	       ifconst	FRAMESKIPGLITCHFIX
   7136  27165				   -	       iny
   7137  27165				   -	       iny
   7138  27165				   -	       iny
   7139  27165				   -	       iny
   7140  27165				   -	       cpy	#DLLASTOBJ-1
   7141  27165				   -	       bcc	dlendmoreloops
   7142  27165					       endif		; FRAMESKIPGLITCHFIX
   7143  27165			ca		       dex
   7144  27166			10 e7		       bpl	dlendloop
   7145  27168
   7146  27168					       ifnconst	pauseroutineoff
   7147  27168			20 e5 f0	       jsr	pauseroutine
   7148  2716b					       endif		; pauseroutineoff
   7149  2716b			60		       rts
   7150  2716c
   7151  2716c				    uninterruptableroutines
   7152  2716c							; this is for routines that must happen off the visible screen, each frame.
   7153  2716c
   7154  2716c				   -	       ifconst	AVOXVOICE
   7155  2716c				   -	       jsr	serviceatarivoxqueue
   7156  2716c					       endif
   7157  2716c
   7158  2716c			a9 00		       lda	#0
   7159  2716e			8d b8 01	       sta	palfastframe
   7160  27171			ad 09 21	       lda	paldetected
   7161  27174			f0 10		       beq	skippalframeadjusting
   7162  27176							; ** PAL console is detected. we increment palframes to accurately count 5 frames,
   7163  27176			ae b7 01	       ldx	palframes
   7164  27179			e8		       inx
   7165  2717a			e0 05		       cpx	#5
   7166  2717c			d0 05		       bne	palframeskipdone
   7167  2717e			ee b8 01	       inc	palfastframe
   7168  27181			a2 00		       ldx	#0
   7169  27183				    palframeskipdone
   7170  27183			8e b7 01	       stx	palframes
   7171  27186				    skippalframeadjusting
   7172  27186
   7173  27186				   -	       ifconst	MUSICTRACKER
   7174  27186				   -			; We normally run the servicesong routine from the top-screen interrupt, but if it
   7175  27186				   -			; happens to interrupt the scheduling of a sound effect in the game code, we skip it.
   7176  27186				   -			; If that happens, we try again here. Chances are very small we'll run into the same
   7177  27186				   -			; problem twice, and if we do, we just drop a musical note or two.
   7178  27186				   -	       lda	sfxschedulemissed
   7179  27186				   -	       beq	servicesongwasnotmissed
   7180  27186				   -	       jsr	servicesong
   7181  27186				   -servicesongwasnotmissed
   7182  27186					       endif		; MUSICTRACKER
   7183  27186
   7184  27186			60		       rts
   7185  27187
   7186  27187				    serviceatarivoxqueue
   7187  27187				   -	       ifconst	AVOXVOICE
   7188  27187				   -	       lda	voxlock
   7189  27187				   -	       bne	skipvoxprocessing	; the vox is in the middle of speech address update
   7190  27187				   -skipvoxqueuesizedec
   7191  27187				   -	       jmp	processavoxvoice
   7192  27187				   -skipvoxprocessing
   7193  27187				   -	       rts
   7194  27187				   -
   7195  27187				   -processavoxvoice
   7196  27187				   -	       lda	avoxenable
   7197  27187				   -	       bne	avoxfixport
   7198  27187				   -	       SPKOUT	tempavox
   7199  27187				   -	       rts
   7200  27187				   -avoxfixport
   7201  27187				   -	       lda	#0	; restore the port to all bits as inputs...
   7202  27187				   -	       sta	CTLSWA
   7203  27187				   -	       rts
   7204  27187				   -silenceavoxvoice
   7205  27187				   -	       SPEAK	avoxsilentdata
   7206  27187				   -	       rts
   7207  27187				   -avoxsilentdata
   7208  27187				   -	       .byte	31,255
   7209  27187					       else
   7210  27187			60		       rts
   7211  27188					       endif		; AVOXVOICE
   7212  27188
   7213  27188				    joybuttonhandler
   7214  27188			8a		       txa
   7215  27189			0a		       asl
   7216  2718a			a8		       tay
   7217  2718b			b9 08 00	       lda	INPT0,y
   7218  2718e			4a		       lsr
   7219  2718f			9d 02 21	       sta	sINPT1,x
   7220  27192			b9 09 00	       lda	INPT1,y
   7221  27195			29 80		       and	#%10000000
   7222  27197			1d 02 21	       ora	sINPT1,x
   7223  2719a			9d 02 21	       sta	sINPT1,x
   7224  2719d
   7225  2719d			b5 0c		       lda	INPT4,x
   7226  2719f			30 19		       bmi	.skip1bjoyfirecheck
   7227  271a1							;one button joystick is down
   7228  271a1			49 80		       eor	#%10000000
   7229  271a3			9d 02 21	       sta	sINPT1,x
   7230  271a6
   7231  271a6			ad b1 01	       lda	joybuttonmode
   7232  271a9			3d bd f1	       and	twobuttonmask,x
   7233  271ac			f0 0c		       beq	.skip1bjoyfirecheck
   7234  271ae			ad b1 01	       lda	joybuttonmode
   7235  271b1			1d bd f1	       ora	twobuttonmask,x
   7236  271b4			8d b1 01	       sta	joybuttonmode
   7237  271b7			8d 82 02	       sta	SWCHB
   7238  271ba				    .skip1bjoyfirecheck
   7239  271ba			4c 57 f0	       jmp	buttonreadloopreturn
   7240  271bd
   7241  271bd				    twobuttonmask
   7242  271bd			04 10		       .byte.b	%00000100,%00010000
   7243  271bf
   7244  271bf				   -	       ifconst	SNES2ATARISUPPORT
   7245  271bf				   -
   7246  271bf				   -SNES_CLOCK_PORT_BIT
   7247  271bf				   -	       .byte	$10,$01
   7248  271bf				   -SNES_CTLSWA_MASK
   7249  271bf				   -	       .byte	$30,$03
   7250  271bf				   -SNES_CTLSWA_SIGNAL
   7251  271bf				   -	       .byte	$C0,$0C
   7252  271bf				   -SWCHA_DIRMASK
   7253  271bf				   -	       .byte	$F0,$0F
   7254  271bf				   -SWCHA_INVDIRMASK
   7255  271bf				   -	       .byte	$0F,$F0
   7256  271bf				   -
   7257  271bf				   -			; Probe each port for SNES, and see if autodetection succeeds anywhere.
   7258  271bf				   -SNES_AUTODETECT
   7259  271bf				   -	       ldx	#1
   7260  271bf				   -SNES_AUTODETECT_LOOP
   7261  271bf				   -	       lda	#1	; proline
   7262  271bf				   -	       sta	port0control,x
   7263  271bf				   -	       jsr	setportforinput
   7264  271bf				   -	       jsr	setonebuttonmode
   7265  271bf				   -	       jsr	SNES_READ
   7266  271bf				   -	       lda	snesdetected0,x
   7267  271bf				   -	       bne	SNES_AUTODETECT_FOUND
   7268  271bf				   -			; detection failed
   7269  271bf				   -	       jsr	setportforinput
   7270  271bf				   -	       jsr	settwobuttonmode
   7271  271bf				   -	       dex
   7272  271bf				   -	       bpl	SNES_AUTODETECT_LOOP
   7273  271bf				   -	       rts
   7274  271bf				   -SNES_AUTODETECT_FOUND
   7275  271bf				   -	       lda	#11	; formally set the snes controller
   7276  271bf				   -	       sta	port0control,x
   7277  271bf				   -	       stx	snesport
   7278  271bf				   -	       rts
   7279  271bf					       endif		; SNES2ATARISUPPORT
   7280  271bf
   7281  271bf				    snes2atarihandler
   7282  271bf				   -	       ifconst	SNES2ATARISUPPORT
   7283  271bf				   -SNES2ATARI
   7284  271bf				   -	       jsr	SNES_READ
   7285  271bf				   -	       jmp	buttonreadloopreturn
   7286  271bf				   -
   7287  271bf				   -SNES_READ
   7288  271bf				   -			; x=0 for left port, x=1 for right
   7289  271bf				   -
   7290  271bf				   -			; Start by checking if any port directions are pressed. 
   7291  271bf				   -			; Abort the autodetect for this port if so, as snes2atari doesn't ground any 
   7292  271bf				   -			; direction pins. if directions are pressed and the port is changed to output,
   7293  271bf				   -			; that means the output is direct-shorted, and nobody seems to know if riot's
   7294  271bf				   -			; output mode has current protection.
   7295  271bf				   -
   7296  271bf				   -	       lda	SWCHA
   7297  271bf				   -	       ora	SWCHA_INVDIRMASK,x
   7298  271bf				   -	       eor	SWCHA_DIRMASK,x
   7299  271bf				   -	       beq	SNES_ABORT
   7300  271bf				   -
   7301  271bf				   -	       lda	port0control,x
   7302  271bf				   -	       cmp	#11	; snes
   7303  271bf				   -	       bne	snes2atari_signal_go	; if this is a first auto-detection read, go ahead and signal
   7304  271bf				   -	       lda	snesdetected0,x
   7305  271bf				   -	       bne	snes2atari_signal_skip	; if snes was available in previous frames, skip signalling
   7306  271bf				   -snes2atari_signal_go
   7307  271bf				   -	       jsr	SNES2ATARI_SIGNAL
   7308  271bf				   -snes2atari_signal_skip
   7309  271bf				   -
   7310  271bf				   -	       lda	SNES_CTLSWA_MASK,x
   7311  271bf				   -	       sta	CTLSWA	; enable pins UP/DOWN to work as outputs
   7312  271bf				   -	       lda	#$0
   7313  271bf				   -	       sta	SWCHA	; make both latch and clock down
   7314  271bf				   -	       ldy	#16	; 16 bits 
   7315  271bf				   -SNES2ATARILOOP
   7316  271bf				   -	       rol	INPT4,x	; sample data into carry
   7317  271bf				   -	       lda	SNES_CLOCK_PORT_BIT,x
   7318  271bf				   -	       sta	SWCHA	; clock low
   7319  271bf				   -	       rol	snes2atari0lo,x
   7320  271bf				   -	       rol	snes2atari0hi,x
   7321  271bf				   -	       lda	#0
   7322  271bf				   -	       sta	SWCHA	; clock high
   7323  271bf				   -	       dey		; next bit
   7324  271bf				   -	       bne	SNES2ATARILOOP
   7325  271bf				   -	       rol	INPT4,x	; 17th bit should be lo if controller is there.
   7326  271bf				   -	       rol		; 17th snes bit into A low bit
   7327  271bf				   -	       eor	snes2atari0lo,x	; 16th bit should be hi if controller is there.
   7328  271bf				   -	       and	#1
   7329  271bf				   -	       sta	snesdetected0,x
   7330  271bf				   -	       beq	SNES_STOP_CLOCK	; if snes isn't detected, leave port in default state
   7331  271bf				   -	       stx	snesport	; snesport keeps the index of the latest autodetected controller
   7332  271bf				   -	       lda	SNES_CLOCK_PORT_BIT,x
   7333  271bf				   -SNES_STOP_CLOCK
   7334  271bf				   -	       sta	SWCHA	; clock low
   7335  271bf				   -	       sta	CTLSWA	; set port bits to input avoid conflict with other drivers
   7336  271bf				   -	       rts
   7337  271bf				   -SNES_ABORT
   7338  271bf				   -	       sta	snesdetected0,x
   7339  271bf				   -	       rts
   7340  271bf				   -SNES2ATARI_SIGNAL
   7341  271bf				   -			; signal to SNES2ATARI++ that we want SNES mode...
   7342  271bf				   -	       lda	SNES_CTLSWA_SIGNAL,x
   7343  271bf				   -	       sta	CTLSWA
   7344  271bf				   -	       lda	#0
   7345  271bf				   -	       sta	SWCHA
   7346  271bf				   -	       ldy	#0
   7347  271bf				   -SNES_SIGNAL_LOOP
   7348  271bf				   -	       dey
   7349  271bf				   -	       bne	SNES_SIGNAL_LOOP
   7350  271bf				   -	       lda	#$FF
   7351  271bf				   -	       sta	SWCHA
   7352  271bf				   -	       rts
   7353  271bf					       endif
   7354  271bf
   7355  271bf				    gunbuttonhandler		; outside of the conditional, so our button handler LUT is valid
   7356  271bf				   -	       ifconst	LIGHTGUNSUPPORT
   7357  271bf				   -	       cpx	#0
   7358  271bf				   -	       bne	secondportgunhandler
   7359  271bf				   -firstportgunhandler
   7360  271bf				   -	       lda	SWCHA
   7361  271bf				   -	       asl
   7362  271bf				   -	       asl
   7363  271bf				   -	       asl		; shift D4 to D7
   7364  271bf				   -	       and	#%10000000
   7365  271bf				   -	       eor	#%10000000
   7366  271bf				   -	       sta	sINPT1
   7367  271bf				   -	       jmp	buttonreadloopreturn
   7368  271bf				   -secondportgunhandler
   7369  271bf				   -	       lda	SWCHA
   7370  271bf				   -	       lsr		; shift D0 into carry
   7371  271bf				   -	       lsr		; shift carry into D7
   7372  271bf				   -	       and	#%10000000
   7373  271bf				   -	       eor	#%10000000
   7374  271bf				   -	       sta	sINPT3
   7375  271bf				   -	       jmp	buttonreadloopreturn
   7376  271bf					       endif		; LIGHTGUNSUPPORT
   7377  271bf
   7378  271bf				    controlsusing2buttoncode
   7379  271bf			00		       .byte.b	0	; 00=no controller plugged in
   7380  271c0			01		       .byte.b	1	; 01=proline joystick
   7381  271c1			00		       .byte.b	0	; 02=lightgun
   7382  271c2			00		       .byte.b	0	; 03=paddle
   7383  271c3			01		       .byte.b	1	; 04=trakball
   7384  271c4			01		       .byte.b	1	; 05=vcs joystick
   7385  271c5			01		       .byte.b	1	; 06=driving control
   7386  271c6			00		       .byte.b	0	; 07=keypad control
   7387  271c7			00		       .byte.b	0	; 08=st mouse/cx80
   7388  271c8			00		       .byte.b	0	; 09=amiga mouse
   7389  271c9			01		       .byte.b	1	; 10=atarivox
   7390  271ca			00		       .byte.b	0	; 11=snes2atari
   7391  271cb
   7392  271cb				    buttonhandlerhi
   7393  271cb			00		       .byte.b	0	; 00=no controller plugged in
   7394  271cc			f1		       .byte.b	>joybuttonhandler	; 01=proline joystick
   7395  271cd			f1		       .byte.b	>gunbuttonhandler	; 02=lightgun
   7396  271ce			f5		       .byte.b	>paddlebuttonhandler	; 03=paddle
   7397  271cf			f1		       .byte.b	>joybuttonhandler	; 04=trakball
   7398  271d0			f1		       .byte.b	>joybuttonhandler	; 05=vcs joystick
   7399  271d1			f1		       .byte.b	>joybuttonhandler	; 06=driving control
   7400  271d2			00		       .byte.b	0	; 07=keypad
   7401  271d3			f5		       .byte.b	>mousebuttonhandler	; 08=st mouse
   7402  271d4			f5		       .byte.b	>mousebuttonhandler	; 09=amiga mouse
   7403  271d5			f1		       .byte.b	>joybuttonhandler	; 10=atarivox
   7404  271d6			f1		       .byte.b	>snes2atarihandler	; 11=snes
   7405  271d7				    buttonhandlerlo
   7406  271d7			00		       .byte.b	0	; 00=no controller plugged in
   7407  271d8			88		       .byte.b	<joybuttonhandler	; 01=proline joystick
   7408  271d9			bf		       .byte.b	<gunbuttonhandler	; 02=lightgun 
   7409  271da			ce		       .byte.b	<paddlebuttonhandler	; 03=paddle
   7410  271db			88		       .byte.b	<joybuttonhandler	; 04=trakball
   7411  271dc			88		       .byte.b	<joybuttonhandler	; 05=vcs joystick
   7412  271dd			88		       .byte.b	<joybuttonhandler	; 06=driving control
   7413  271de			00		       .byte.b	0	; 07=keypad
   7414  271df			ce		       .byte.b	<mousebuttonhandler	; 08=st mouse
   7415  271e0			ce		       .byte.b	<mousebuttonhandler	; 09=amiga mouse
   7416  271e1			88		       .byte.b	<joybuttonhandler	; 10=atarivox
   7417  271e2			bf		       .byte.b	<snes2atarihandler	; 11=snes
   7418  271e3
   7419  271e3				    drawwait
   7420  271e3			24 4d		       bit	visibleover	; 255 if screen is being drawn, 0 when not.
   7421  271e5			30 fc		       bmi	drawwait	; make sure the visible screen isn't being drawn
   7422  271e7			60		       rts
   7423  271e8
   7424  271e8				    drawoverwait
   7425  271e8			24 4d		       bit	visibleover	; 255 if screen is being drawn, 0 when not.
   7426  271ea			10 fc		       bpl	drawoverwait	; make sure the visible screen is being drawn
   7427  271ec			60		       rts
   7428  271ed
   7429  271ed
   7430  271ed				    mutetia
   7431  271ed			a9 00		       lda	#0
   7432  271ef			a2 03		       ldx	#3
   7433  271f1				    mutetialoop
   7434  271f1			95 4e		       sta	sfx1pointlo,x
   7435  271f3			95 17		       sta	AUDF0,x
   7436  271f5			ca		       dex
   7437  271f6			10 f9		       bpl	mutetialoop
   7438  271f8			60		       rts
   7439  271f9
   7440  271f9				    servicesfxchannelsdone
   7441  271f9					       ifnconst	pokeysupport
   7442  271f9			60		       rts
   7443  271fa				   -	       else
   7444  271fa				   -	       jmp	checkpokeyplaying
   7445  271fa					       endif
   7446  271fa				    servicesfxchannels
   7447  271fa			a2 ff		       ldx	#255
   7448  271fc				    servicesfxchannelsloop
   7449  271fc			e8		       inx
   7450  271fd					       ifnconst	TIASFXMONO
   7451  271fd			e0 02		       cpx	#2
   7452  271ff				   -	       else
   7453  271ff				   -	       cpx	#1
   7454  271ff					       endif
   7455  271ff			f0 f8		       beq	servicesfxchannelsdone
   7456  27201
   7457  27201			a5 de		       lda	sfxschedulelock	; =1 if locked
   7458  27203			d0 f4		       bne	servicesfxchannelsdone	; exit if a pointer may be mid-way change
   7459  27205
   7460  27205			b5 4e		       lda	sfx1pointlo,x
   7461  27207			85 dc		       sta	inttemp5
   7462  27209			15 50		       ora	sfx1pointhi,x
   7463  2720b			f0 ef		       beq	servicesfxchannelsloop
   7464  2720d			b5 50		       lda	sfx1pointhi,x
   7465  2720f			85 dd		       sta	inttemp6
   7466  27211
   7467  27211			b5 58		       lda	sfx1tick,x
   7468  27213			f0 05		       beq	servicesfx_cont1	; this chunk is over, load the next!
   7469  27215			d6 58		       dec	sfx1tick,x	; frame countdown is non-zero, subtract one
   7470  27217			4c fc f1	       jmp	servicesfxchannelsloop
   7471  2721a				    servicesfx_cont1
   7472  2721a
   7473  2721a			a0 01		       ldy	#1	; check to see if they're changing the frame countdown
   7474  2721c			b1 dc		       lda	(inttemp5),y
   7475  2721e			c9 10		       cmp	#$10
   7476  27220			d0 1b		       bne	servicesfx_cont1a
   7477  27222			a0 02		       ldy	#2
   7478  27224			b1 dc		       lda	(inttemp5),y
   7479  27226			95 56		       sta	sfx1frames,x	; change the frame countdown
   7480  27228			a9 00		       lda	#0
   7481  2722a			95 58		       sta	sfx1tick,x
   7482  2722c							; advance the sound pointer by 3...
   7483  2722c			b5 4e		       lda	sfx1pointlo,x
   7484  2722e			18		       clc
   7485  2722f			69 03		       adc	#3
   7486  27231			95 4e		       sta	sfx1pointlo,x
   7487  27233			b5 50		       lda	sfx1pointhi,x
   7488  27235			69 00		       adc	#0
   7489  27237			95 50		       sta	sfx1pointhi,x
   7490  27239							; and then fetch another sample for this channel...
   7491  27239			ca		       dex
   7492  2723a			4c fc f1	       jmp	servicesfxchannelsloop
   7493  2723d				    servicesfx_cont1a
   7494  2723d
   7495  2723d			b5 56		       lda	sfx1frames,x	; set the frame countdown for this sound chunk
   7496  2723f			95 58		       sta	sfx1tick,x
   7497  27241
   7498  27241			b5 52		       lda	sfx1priority,x	; decrease the sound's priority if its non-zero
   7499  27243			f0 02		       beq	servicesfx_cont2
   7500  27245			d6 52		       dec	sfx1priority,x
   7501  27247				    servicesfx_cont2
   7502  27247
   7503  27247			a0 00		       ldy	#0	; play the sound
   7504  27249			b1 dc		       lda	(inttemp5),y
   7505  2724b			85 d8		       sta	inttemp1
   7506  2724d
   7507  2724d				   -	       ifconst	MUSICTRACKER
   7508  2724d				   -	       lda	sfx1notedata,x
   7509  2724d				   -	       beq	exitmusictracker	; exit if this isn't a pitched instrument
   7510  2724d				   -	       ldy	#0
   7511  2724d				   -	       sty	inttemp2
   7512  2724d				   -	       clc
   7513  2724d				   -	       adc	(inttemp5),y
   7514  2724d				   -	       asl		; x2
   7515  2724d				   -	       tay
   7516  2724d				   -	       lda	tiatrackeroctavenotes,y
   7517  2724d				   -	       sta	AUDC0,x
   7518  2724d				   -	       iny
   7519  2724d				   -	       lda	tiatrackeroctavenotes,y
   7520  2724d				   -	       sta	AUDF0,x
   7521  2724d				   -	       ldy	#1
   7522  2724d				   -	       jmp	sfxvolumeentrypt
   7523  2724d				   -exitmusictracker
   7524  2724d				   -	       lda	inttemp1
   7525  2724d					       endif		; MUSICTRACKER
   7526  2724d
   7527  2724d			18		       clc
   7528  2724e			75 54		       adc	sfx1poffset,x	; take into account any pitch modification
   7529  27250			95 17		       sta	AUDF0,x
   7530  27252			c8		       iny
   7531  27253			b1 dc		       lda	(inttemp5),y
   7532  27255			95 15		       sta	AUDC0,x
   7533  27257			85 d9		       sta	inttemp2
   7534  27259			c8		       iny
   7535  2725a				    sfxvolumeentrypt
   7536  2725a				   -	       ifconst	TIAVOLUME
   7537  2725a				   -	       lda	tiavolume
   7538  2725a				   -	       sta	fourbitfadevalueint
   7539  2725a					       endif		; TIAVOLUME
   7540  2725a			b1 dc		       lda	(inttemp5),y
   7541  2725c				   -	       ifconst	TIAVOLUME
   7542  2725c				   -	       jsr	fourbitfadeint
   7543  2725c					       endif		; TIAVOLUME
   7544  2725c			95 19		       sta	AUDV0,x
   7545  2725e			c9 10		       cmp	#$10
   7546  27260			b0 19		       bcs	sfxsoundloop	; AUDV0>$0F means the sound is looped while priority is active
   7547  27262
   7548  27262			05 d9		       ora	inttemp2
   7549  27264			05 d8		       ora	inttemp1	; check if F|C|V=0
   7550  27266			f0 23		       beq	zerosfx	; if so, we're at the end of the sound.
   7551  27268
   7552  27268				    advancesfxpointer
   7553  27268							; advance the pointer to the next sound chunk
   7554  27268			c8		       iny
   7555  27269			84 da		       sty	inttemp3
   7556  2726b			18		       clc
   7557  2726c			b5 4e		       lda	sfx1pointlo,x
   7558  2726e			65 da		       adc	inttemp3
   7559  27270			95 4e		       sta	sfx1pointlo,x
   7560  27272			b5 50		       lda	sfx1pointhi,x
   7561  27274			69 00		       adc	#0
   7562  27276			95 50		       sta	sfx1pointhi,x
   7563  27278			4c fc f1	       jmp	servicesfxchannelsloop
   7564  2727b
   7565  2727b				    sfxsoundloop
   7566  2727b			48		       pha
   7567  2727c			b5 52		       lda	sfx1priority,x
   7568  2727e			d0 04		       bne	sfxsoundloop_carryon
   7569  27280			68		       pla		; fix the stack before we go
   7570  27281			4c 68 f2	       jmp	advancesfxpointer
   7571  27284				    sfxsoundloop_carryon
   7572  27284			68		       pla
   7573  27285			29 f0		       and	#$F0
   7574  27287			4a		       lsr
   7575  27288			4a		       lsr
   7576  27289			4a		       lsr
   7577  2728a			4a		       lsr
   7578  2728b
   7579  2728b				    zerosfx
   7580  2728b			95 4e		       sta	sfx1pointlo,x
   7581  2728d			95 50		       sta	sfx1pointhi,x
   7582  2728f			95 52		       sta	sfx1priority,x
   7583  27291			4c fc f1	       jmp	servicesfxchannelsloop
   7584  27294
   7585  27294
   7586  27294				    schedulesfx
   7587  27294							; called with sfxinstrumentlo=<data sfxinstrumenthi=>data sfxpitchoffset=pitch-offset sfxnoteindex=note index
   7588  27294			a0 00		       ldy	#0
   7589  27296			b1 e0		       lda	(sfxinstrumentlo),y
   7590  27298				   -	       ifconst	pokeysupport
   7591  27298				   -	       cmp	#$20	; POKEY?
   7592  27298				   -	       bne	scheduletiasfx
   7593  27298				   -	       jmp	schedulepokeysfx
   7594  27298					       endif
   7595  27298				    scheduletiasfx
   7596  27298							;cmp #$10 ; TIA?
   7597  27298							;beq continuescheduletiasfx
   7598  27298							; rts ; unhandled!!! 
   7599  27298				    continuescheduletiasfx
   7600  27298					       ifnconst	TIASFXMONO
   7601  27298			a5 4e		       lda	sfx1pointlo
   7602  2729a			05 50		       ora	sfx1pointhi
   7603  2729c			f0 13		       beq	schedulesfx1	;if channel 1 is idle, use it
   7604  2729e			a5 4f		       lda	sfx2pointlo
   7605  272a0			05 51		       ora	sfx2pointhi
   7606  272a2			f0 11		       beq	schedulesfx2	;if channel 2 is idle, use it
   7607  272a4							; Both channels are scheduled. 
   7608  272a4			a0 01		       ldy	#1
   7609  272a6			b1 e0		       lda	(sfxinstrumentlo),y
   7610  272a8			d0 01		       bne	interruptsfx
   7611  272aa			60		       rts		; the new sound has 0 priority and both channels are busy. Skip playing it.
   7612  272ab				    interruptsfx
   7613  272ab							;Compare which active sound has a lower priority. We'll interrupt the lower one.
   7614  272ab			a5 52		       lda	sfx1priority
   7615  272ad			c5 53		       cmp	sfx2priority
   7616  272af			b0 04		       bcs	schedulesfx2
   7617  272b1					       endif		; !TIASFXMONO
   7618  272b1
   7619  272b1				    schedulesfx1
   7620  272b1			a2 00		       ldx	#0	; channel 1
   7621  272b3					       ifnconst	TIASFXMONO
   7622  272b3			f0 02		       beq	skipschedulesfx2
   7623  272b5				    schedulesfx2
   7624  272b5			a2 01		       ldx	#1	; channel 2
   7625  272b7				    skipschedulesfx2
   7626  272b7					       endif		; !TIASFXMONO
   7627  272b7
   7628  272b7				   -	       ifconst	MUSICTRACKER
   7629  272b7				   -	       lda	sfxnoteindex
   7630  272b7				   -	       bpl	skipdrumkitoverride
   7631  272b7				   -	       and	#$7F	; subtract 128
   7632  272b7				   -	       sec
   7633  272b7				   -	       sbc	#4	; drums start at 132, i.e. octave 10
   7634  272b7				   -	       asl
   7635  272b7				   -	       tay
   7636  272b7				   -	       lda	tiadrumkitdefinition,y
   7637  272b7				   -	       sta	sfxinstrumentlo
   7638  272b7				   -	       iny
   7639  272b7				   -	       lda	tiadrumkitdefinition,y
   7640  272b7				   -	       sta	sfxinstrumenthi
   7641  272b7				   -	       lda	#0
   7642  272b7				   -	       sta	sfxnoteindex	; and tell the driver it's a non-pitched instrument
   7643  272b7				   -skipdrumkitoverride
   7644  272b7					       endif		; MUSICTRACKER
   7645  272b7			a0 01		       ldy	#1	; get priority and sound-resolution (in frames)
   7646  272b9			b1 e0		       lda	(sfxinstrumentlo),y
   7647  272bb			95 52		       sta	sfx1priority,x
   7648  272bd			c8		       iny
   7649  272be			b1 e0		       lda	(sfxinstrumentlo),y
   7650  272c0			95 56		       sta	sfx1frames,x
   7651  272c2			a5 e0		       lda	sfxinstrumentlo
   7652  272c4			18		       clc
   7653  272c5			69 03		       adc	#3
   7654  272c7			95 4e		       sta	sfx1pointlo,x
   7655  272c9			a5 e1		       lda	sfxinstrumenthi
   7656  272cb			69 00		       adc	#0
   7657  272cd			95 50		       sta	sfx1pointhi,x
   7658  272cf			a5 e2		       lda	sfxpitchoffset
   7659  272d1			95 54		       sta	sfx1poffset,x
   7660  272d3			a9 00		       lda	#0
   7661  272d5			95 58		       sta	sfx1tick,x
   7662  272d7			a5 e3		       lda	sfxnoteindex
   7663  272d9			95 cd		       sta	sfx1notedata,x
   7664  272db			60		       rts
   7665  272dc
   7666  272dc				    plotsprite
   7667  272dc					       ifnconst	NODRAWWAIT
   7668  272dc					       ifconst	DOUBLEBUFFER
   7669  272dc			a5 d5		       lda	doublebufferstate
   7670  272de			d0 04		       bne	skipplotspritewait
   7671  272e0					       endif		; DOUBLEBUFFER
   7672  272e0				   -	       ifconst	DEBUGWAITCOLOR
   7673  272e0				   -	       lda	#$41
   7674  272e0				   -	       sta	BACKGRND
   7675  272e0					       endif
   7676  272e0				    plotspritewait
   7677  272e0			a5 4d		       lda	visibleover
   7678  272e2			d0 fc		       bne	plotspritewait
   7679  272e4				    skipplotspritewait
   7680  272e4				   -	       ifconst	DEBUGWAITCOLOR
   7681  272e4				   -	       lda	#$0
   7682  272e4				   -	       sta	BACKGRND
   7683  272e4					       endif
   7684  272e4					       endif
   7685  272e4
   7686  272e4							;arguments: 
   7687  272e4							; temp1=lo graphicdata 
   7688  272e4							; temp2=hi graphicdata 
   7689  272e4							; temp3=palette | width byte
   7690  272e4							; temp4=x
   7691  272e4							; temp5=y
   7692  272e4							; temp6=mode
   7693  272e4			a5 46		       lda	temp5	;Y position
   7694  272e6			4a		       lsr		; 2 - Divide by 8 or 16
   7695  272e7			4a		       lsr		; 2
   7696  272e8			4a		       lsr		; 2
   7697  272e9					       if	WZONEHEIGHT = 16
   7698  272e9			4a		       lsr		; 2
   7699  272ea					       endif
   7700  272ea
   7701  272ea			aa		       tax
   7702  272eb
   7703  272eb					       ifnconst	NOLIMITCHECKING
   7704  272eb
   7705  272eb							; the next block allows for vertical masking, and ensures we don't overwrite non-DL memory
   7706  272eb
   7707  272eb			c9 0e		       cmp	#WZONECOUNT
   7708  272ed
   7709  272ed			90 0a		       bcc	continueplotsprite1	; the sprite is fully on-screen, so carry on...
   7710  272ef							; otherwise, check to see if the bottom half is in zone 0...
   7711  272ef
   7712  272ef					       if	WZONEHEIGHT = 16
   7713  272ef			c9 0f		       cmp	#15
   7714  272f1				   -	       else
   7715  272f1				   -	       cmp	#31
   7716  272f1					       endif
   7717  272f1
   7718  272f1			d0 05		       bne	exitplotsprite1
   7719  272f3			a2 00		       ldx	#0
   7720  272f5			4c 33 f3	       jmp	continueplotsprite2
   7721  272f8				    exitplotsprite1
   7722  272f8			60		       rts
   7723  272f9
   7724  272f9				    continueplotsprite1
   7725  272f9					       endif
   7726  272f9
   7727  272f9			bd 98 f6	       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   7728  272fc					       ifconst	DOUBLEBUFFER
   7729  272fc			18		       clc
   7730  272fd			65 d6		       adc	doublebufferdloffset
   7731  272ff					       endif		; DOUBLEBUFFER
   7732  272ff			85 63		       sta	dlpnt
   7733  27301			bd 8a f6	       lda	DLPOINTH,x
   7734  27304					       ifconst	DOUBLEBUFFER
   7735  27304			69 00		       adc	#0
   7736  27306					       endif		; DOUBLEBUFFER
   7737  27306			85 64		       sta	dlpnt+1
   7738  27308
   7739  27308							;Create DL entry for upper part of sprite
   7740  27308
   7741  27308			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   7742  2730a
   7743  2730a				   -	       ifconst	CHECKOVERWRITE
   7744  2730a				   -	       cpy	#DLLASTOBJ
   7745  2730a				   -	       beq	checkcontinueplotsprite2
   7746  2730a				   -continueplotsprite1a
   7747  2730a					       endif
   7748  2730a
   7749  2730a			a5 42		       lda	temp1	; graphic data, lo byte
   7750  2730c			91 63		       sta	(dlpnt),y	;Low byte of data address
   7751  2730e
   7752  2730e					       ifnconst	ATOMICSPRITEUPDATE
   7753  2730e			c8		       iny
   7754  2730f			a5 47		       lda	temp6
   7755  27311			91 63		       sta	(dlpnt),y
   7756  27313				   -	       else
   7757  27313				   -	       iny
   7758  27313				   -	       sty	temp8
   7759  27313					       endif
   7760  27313
   7761  27313			c8		       iny
   7762  27314
   7763  27314			a5 46		       lda	temp5	;Y position
   7764  27316			29 0f		       and	#(WZONEHEIGHT - 1)
   7765  27318			c9 01		       cmp	#1	; clear carry if our sprite is just in this zone
   7766  2731a			05 43		       ora	temp2	; graphic data, hi byte
   7767  2731c			91 63		       sta	(dlpnt),y
   7768  2731e
   7769  2731e
   7770  2731e			c8		       iny
   7771  2731f			a5 44		       lda	temp3	;palette|width
   7772  27321			91 63		       sta	(dlpnt),y
   7773  27323
   7774  27323			c8		       iny
   7775  27324			a5 45		       lda	temp4	;Horizontal position
   7776  27326			91 63		       sta	(dlpnt),y
   7777  27328
   7778  27328			c8		       iny
   7779  27329			94 65		       sty	dlend,x
   7780  2732b
   7781  2732b				   -	       ifconst	ALWAYSTERMINATE
   7782  2732b				   -	       iny
   7783  2732b				   -	       lda	#0
   7784  2732b				   -	       sta	(dlpnt),y
   7785  2732b					       endif
   7786  2732b
   7787  2732b				   -	       ifconst	ATOMICSPRITEUPDATE
   7788  2732b				   -	       ldy	temp8
   7789  2732b				   -	       lda	temp6
   7790  2732b				   -	       sta	(dlpnt),y
   7791  2732b					       endif
   7792  2732b
   7793  2732b				    checkcontinueplotsprite2
   7794  2732b
   7795  2732b			90 38		       bcc	doneSPDL	;branch if the sprite was fully in the last zone
   7796  2732d
   7797  2732d							;Create DL entry for lower part of sprite
   7798  2732d
   7799  2732d			e8		       inx		;Next region
   7800  2732e
   7801  2732e					       ifnconst	NOLIMITCHECKING
   7802  2732e			e0 0e		       cpx	#WZONECOUNT
   7803  27330
   7804  27330			90 01		       bcc	continueplotsprite2	; the second half of the sprite is fully on-screen, so carry on...
   7805  27332			60		       rts
   7806  27333				    continueplotsprite2
   7807  27333					       endif
   7808  27333
   7809  27333			bd 98 f6	       lda	DLPOINTL,x	;Get pointer to next DL
   7810  27336					       ifconst	DOUBLEBUFFER
   7811  27336			18		       clc
   7812  27337			65 d6		       adc	doublebufferdloffset
   7813  27339					       endif		; DOUBLEBUFFER
   7814  27339			85 63		       sta	dlpnt
   7815  2733b			bd 8a f6	       lda	DLPOINTH,x
   7816  2733e					       ifconst	DOUBLEBUFFER
   7817  2733e			69 00		       adc	#0
   7818  27340					       endif		; DOUBLEBUFFER
   7819  27340			85 64		       sta	dlpnt+1
   7820  27342			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   7821  27344
   7822  27344				   -	       ifconst	CHECKOVERWRITE
   7823  27344				   -	       cpy	#DLLASTOBJ
   7824  27344				   -	       bne	continueplotsprite2a
   7825  27344				   -	       rts
   7826  27344				   -continueplotsprite2a
   7827  27344					       endif
   7828  27344
   7829  27344			a5 42		       lda	temp1	; graphic data, lo byte
   7830  27346			91 63		       sta	(dlpnt),y
   7831  27348
   7832  27348					       ifnconst	ATOMICSPRITEUPDATE
   7833  27348			c8		       iny
   7834  27349			a5 47		       lda	temp6
   7835  2734b			91 63		       sta	(dlpnt),y
   7836  2734d				   -	       else
   7837  2734d				   -	       iny
   7838  2734d				   -	       sty	temp8
   7839  2734d					       endif
   7840  2734d
   7841  2734d			c8		       iny
   7842  2734e
   7843  2734e			a5 46		       lda	temp5	;Y position
   7844  27350			0b 0f		       anc	#(WZONEHEIGHT - 1)	; undocumented. A=A&IMM, then move bit 7 into carry
   7845  27352			05 43		       ora	temp2	; graphic data, hi byte
   7846  27354			e9 0f		       sbc	#(WZONEHEIGHT-1)	; start at the DMA hole. -1 because carry is clear
   7847  27356			91 63		       sta	(dlpnt),y
   7848  27358
   7849  27358			c8		       iny
   7850  27359
   7851  27359			a5 44		       lda	temp3	;palette|width
   7852  2735b			91 63		       sta	(dlpnt),y
   7853  2735d
   7854  2735d			c8		       iny
   7855  2735e
   7856  2735e			a5 45		       lda	temp4	;Horizontal position
   7857  27360			91 63		       sta	(dlpnt),y
   7858  27362
   7859  27362			c8		       iny
   7860  27363			94 65		       sty	dlend,x
   7861  27365
   7862  27365				   -	       ifconst	ALWAYSTERMINATE
   7863  27365				   -	       iny
   7864  27365				   -	       lda	#0
   7865  27365				   -	       sta	(dlpnt),y
   7866  27365					       endif
   7867  27365
   7868  27365				   -	       ifconst	ATOMICSPRITEUPDATE
   7869  27365				   -	       ldy	temp8
   7870  27365				   -	       lda	temp6
   7871  27365				   -	       sta	(dlpnt),y
   7872  27365					       endif
   7873  27365
   7874  27365				    doneSPDL
   7875  27365			60		       rts
   7876  27366
   7877  27366
   7878  27366				    lockzonex
   7879  27366				   -	       ifconst	ZONELOCKS
   7880  27366				   -	       ldy	dlend,x
   7881  27366				   -	       cpy	#DLLASTOBJ
   7882  27366				   -	       beq	lockzonexreturn	; the zone is either stuffed or locked. abort!
   7883  27366				   -	       lda	DLPOINTL,x
   7884  27366				   -	       ifconst	DOUBLEBUFFER
   7885  27366				   -	       clc
   7886  27366				   -	       adc	doublebufferdloffset
   7887  27366				   -	       endif		; DOUBLEBUFFER
   7888  27366				   -	       sta	dlpnt
   7889  27366				   -	       lda	DLPOINTH,x
   7890  27366				   -	       ifconst	DOUBLEBUFFER
   7891  27366				   -	       adc	#0
   7892  27366				   -	       endif		; DOUBLEBUFFER
   7893  27366				   -	       sta	dlpnt+1
   7894  27366				   -	       iny
   7895  27366				   -	       lda	#0
   7896  27366				   -	       sta	(dlpnt),y
   7897  27366				   -	       dey
   7898  27366				   -	       tya
   7899  27366				   -	       ldy	#(DLLASTOBJ-1)
   7900  27366				   -	       sta	(dlpnt),y
   7901  27366				   -	       iny
   7902  27366				   -	       sty	dlend,x
   7903  27366				   -lockzonexreturn
   7904  27366				   -	       rts
   7905  27366					       endif		; ZONELOCKS
   7906  27366				    unlockzonex
   7907  27366				   -	       ifconst	ZONELOCKS
   7908  27366				   -	       ldy	dlend,x
   7909  27366				   -	       cpy	#DLLASTOBJ
   7910  27366				   -	       bne	unlockzonexreturn	; if the zone isn't stuffed, it's not locked. abort!
   7911  27366				   -	       lda	DLPOINTL,x
   7912  27366				   -	       ifconst	DOUBLEBUFFER
   7913  27366				   -	       clc
   7914  27366				   -	       adc	doublebufferdloffset
   7915  27366				   -	       endif		; DOUBLEBUFFER
   7916  27366				   -	       sta	dlpnt
   7917  27366				   -	       lda	DLPOINTH,x
   7918  27366				   -	       ifconst	DOUBLEBUFFER
   7919  27366				   -	       adc	#0
   7920  27366				   -	       endif		; DOUBLEBUFFER
   7921  27366				   -	       sta	dlpnt+1
   7922  27366				   -	       dey
   7923  27366				   -			;ldy #(DLLASTOBJ-1)
   7924  27366				   -	       lda	(dlpnt),y
   7925  27366				   -	       tay
   7926  27366				   -	       sty	dlend,x
   7927  27366				   -unlockzonexreturn
   7928  27366					       endif		; ZONELOCKS
   7929  27366			60		       rts
   7930  27367
   7931  27367				    plotcharloop
   7932  27367							; ** read from a data indirectly pointed to from temp8,temp9
   7933  27367							; ** format is: lo_data, hi_data, palette|width, x, y
   7934  27367							; ** format ends with lo_data | hi_data = 0
   7935  27367
   7936  27367					       ifconst	DOUBLEBUFFER
   7937  27367			a5 d5		       lda	doublebufferstate
   7938  27369			d0 04		       bne	skipplotcharloopwait
   7939  2736b					       endif		; DOUBLEBUFFER
   7940  2736b				   -	       ifconst	DEBUGWAITCOLOR
   7941  2736b				   -	       lda	#$61
   7942  2736b				   -	       sta	BACKGRND
   7943  2736b					       endif
   7944  2736b				    plotcharloopwait
   7945  2736b			a5 4d		       lda	visibleover
   7946  2736d			d0 fc		       bne	plotcharloopwait
   7947  2736f				   -	       ifconst	DEBUGWAITCOLOR
   7948  2736f				   -	       lda	#0
   7949  2736f				   -	       sta	BACKGRND
   7950  2736f					       endif
   7951  2736f				    skipplotcharloopwait
   7952  2736f				    plotcharlooploop
   7953  2736f			a0 00		       ldy	#0
   7954  27371			b1 49		       lda	(temp8),y
   7955  27373			85 42		       sta	temp1
   7956  27375			c8		       iny
   7957  27376			b1 49		       lda	(temp8),y
   7958  27378			85 43		       sta	temp2
   7959  2737a			05 42		       ora	temp1
   7960  2737c			d0 01		       bne	plotcharloopcontinue
   7961  2737e							;the pointer=0, so return
   7962  2737e			60		       rts
   7963  2737f				    plotcharloopcontinue
   7964  2737f			c8		       iny
   7965  27380			b1 49		       lda	(temp8),y
   7966  27382			85 44		       sta	temp3
   7967  27384			c8		       iny
   7968  27385			b1 49		       lda	(temp8),y
   7969  27387			85 45		       sta	temp4
   7970  27389			c8		       iny
   7971  2738a			b1 49		       lda	(temp8),y
   7972  2738c							;sta temp5 ; not needed with our late entry.
   7973  2738c			20 a9 f3	       jsr	plotcharactersskipentry
   7974  2738f			a5 49		       lda	temp8
   7975  27391			18		       clc
   7976  27392			69 05		       adc	#5
   7977  27394			85 49		       sta	temp8
   7978  27396			a5 4a		       lda	temp9
   7979  27398			69 00		       adc	#0
   7980  2739a			85 4a		       sta	temp9
   7981  2739c			4c 6f f3	       jmp	plotcharlooploop
   7982  2739f
   7983  2739f				    plotcharacters
   7984  2739f					       ifconst	DOUBLEBUFFER
   7985  2739f			a5 d5		       lda	doublebufferstate
   7986  273a1			d0 04		       bne	skipplotcharacterswait
   7987  273a3					       endif		; DOUBLEBUFFER
   7988  273a3				   -	       ifconst	DEBUGWAITCOLOR
   7989  273a3				   -	       lda	#$41
   7990  273a3				   -	       sta	BACKGRND
   7991  273a3					       endif
   7992  273a3				    plotcharacterswait
   7993  273a3			a5 4d		       lda	visibleover
   7994  273a5			d0 fc		       bne	plotcharacterswait
   7995  273a7				   -	       ifconst	DEBUGWAITCOLOR
   7996  273a7				   -	       sta	BACKGRND
   7997  273a7					       endif
   7998  273a7				    skipplotcharacterswait
   7999  273a7							;arguments: 
   8000  273a7							; temp1=lo charactermap
   8001  273a7							; temp2=hi charactermap
   8002  273a7							; temp3=palette | width byte
   8003  273a7							; temp4=x
   8004  273a7							; temp5=y
   8005  273a7
   8006  273a7			a5 46		       lda	temp5	;Y position
   8007  273a9
   8008  273a9				    plotcharactersskipentry
   8009  273a9
   8010  273a9							;ifconst ZONEHEIGHT
   8011  273a9							; if ZONEHEIGHT = 16
   8012  273a9							; and #$0F
   8013  273a9							; endif
   8014  273a9							; if ZONEHEIGHT = 8
   8015  273a9							; and #$1F
   8016  273a9							; endif
   8017  273a9							;else
   8018  273a9							; and #$0F
   8019  273a9							;endif
   8020  273a9
   8021  273a9			aa		       tax
   8022  273aa			bd 98 f6	       lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   8023  273ad					       ifconst	DOUBLEBUFFER
   8024  273ad			18		       clc
   8025  273ae			65 d6		       adc	doublebufferdloffset
   8026  273b0					       endif		; DOUBLEBUFFER
   8027  273b0			85 63		       sta	dlpnt
   8028  273b2			bd 8a f6	       lda	DLPOINTH,x
   8029  273b5					       ifconst	DOUBLEBUFFER
   8030  273b5			69 00		       adc	#0
   8031  273b7					       endif		; DOUBLEBUFFER
   8032  273b7			85 64		       sta	dlpnt+1
   8033  273b9
   8034  273b9							;Create DL entry for the characters
   8035  273b9
   8036  273b9			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   8037  273bb
   8038  273bb				   -	       ifconst	CHECKOVERWRITE
   8039  273bb				   -	       cpy	#DLLASTOBJ
   8040  273bb				   -	       bne	continueplotcharacters
   8041  273bb				   -	       rts
   8042  273bb				   -continueplotcharacters
   8043  273bb					       endif
   8044  273bb
   8045  273bb			a5 42		       lda	temp1	; character map data, lo byte
   8046  273bd			91 63		       sta	(dlpnt),y	;(1) store low address
   8047  273bf
   8048  273bf			c8		       iny
   8049  273c0			ad 06 21	       lda	charactermode
   8050  273c3			91 63		       sta	(dlpnt),y	;(2) store mode
   8051  273c5
   8052  273c5			c8		       iny
   8053  273c6			a5 43		       lda	temp2	; character map, hi byte
   8054  273c8			91 63		       sta	(dlpnt),y	;(3) store high address
   8055  273ca
   8056  273ca			c8		       iny
   8057  273cb			a5 44		       lda	temp3	;palette|width
   8058  273cd			91 63		       sta	(dlpnt),y	;(4) store palette|width
   8059  273cf
   8060  273cf			c8		       iny
   8061  273d0			a5 45		       lda	temp4	;Horizontal position
   8062  273d2			91 63		       sta	(dlpnt),y	;(5) store horizontal position
   8063  273d4
   8064  273d4			c8		       iny
   8065  273d5			94 65		       sty	dlend,x	; save display list end byte
   8066  273d7			60		       rts
   8067  273d8
   8068  273d8
   8069  273d8				   -	       ifconst	plotvalueonscreen
   8070  273d8				   -plotcharacterslive
   8071  273d8				   -			; a version of plotcharacters that draws live and minimally disrupts the screen...
   8072  273d8				   -
   8073  273d8				   -			;arguments: 
   8074  273d8				   -			; temp1=lo charactermap
   8075  273d8				   -			; temp2=hi charactermap
   8076  273d8				   -			; temp3=palette | width byte
   8077  273d8				   -			; temp4=x
   8078  273d8				   -			; temp5=y
   8079  273d8				   -
   8080  273d8				   -	       lda	temp5	;Y position
   8081  273d8				   -
   8082  273d8				   -	       tax
   8083  273d8				   -	       lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   8084  273d8				   -	       ifconst	DOUBLEBUFFER
   8085  273d8				   -	       clc
   8086  273d8				   -	       adc	doublebufferdloffset
   8087  273d8				   -	       endif		; DOUBLEBUFFER
   8088  273d8				   -	       sta	dlpnt
   8089  273d8				   -	       lda	DLPOINTH,x
   8090  273d8				   -	       ifconst	DOUBLEBUFFER
   8091  273d8				   -	       adc	#0
   8092  273d8				   -	       endif		; DOUBLEBUFFER
   8093  273d8				   -	       sta	dlpnt+1
   8094  273d8				   -
   8095  273d8				   -			;Create DL entry for the characters
   8096  273d8				   -
   8097  273d8				   -	       ldy	dlend,x	;Get the index to the end of this DL
   8098  273d8				   -
   8099  273d8				   -	       ifconst	CHECKOVERWRITE
   8100  273d8				   -	       cpy	#DLLASTOBJ
   8101  273d8				   -	       bne	continueplotcharacterslive
   8102  273d8				   -	       rts
   8103  273d8				   -continueplotcharacterslive
   8104  273d8				   -	       endif
   8105  273d8				   -
   8106  273d8				   -	       lda	temp1	; character map data, lo byte
   8107  273d8				   -	       sta	(dlpnt),y	;(1) store low address
   8108  273d8				   -
   8109  273d8				   -	       iny
   8110  273d8				   -			; we don't add the second byte yet, since the charmap could briefly
   8111  273d8				   -			; render without a proper character map address, width, or position.
   8112  273d8				   -	       lda	charactermode
   8113  273d8				   -	       sta	(dlpnt),y	;(2) store mode
   8114  273d8				   -
   8115  273d8				   -	       iny
   8116  273d8				   -	       lda	temp2	; character map, hi byte
   8117  273d8				   -	       sta	(dlpnt),y	;(3) store high address
   8118  273d8				   -
   8119  273d8				   -	       iny
   8120  273d8				   -	       lda	temp3	;palette|width
   8121  273d8				   -	       sta	(dlpnt),y	;(4) store palette|width
   8122  273d8				   -
   8123  273d8				   -	       iny
   8124  273d8				   -	       lda	temp4	;Horizontal position
   8125  273d8				   -	       sta	(dlpnt),y	;(5) store horizontal position
   8126  273d8				   -
   8127  273d8				   -	       iny
   8128  273d8				   -	       sty	dlend,x	; save display list end byte
   8129  273d8				   -
   8130  273d8				   -	       rts
   8131  273d8					       endif		;plotcharacterslive
   8132  273d8
   8133  273d8				   -	       ifconst	USED_PLOTVALUE
   8134  273d8				   -plotvalue
   8135  273d8				   -			; calling 7800basic command:
   8136  273d8				   -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   8137  273d8				   -			; ...displays the variable as BCD digits
   8138  273d8				   -			;
   8139  273d8				   -			; asm sub arguments: 
   8140  273d8				   -			; temp1=lo charactermap
   8141  273d8				   -			; temp2=hi charactermap
   8142  273d8				   -			; temp3=palette | width byte
   8143  273d8				   -			; temp4=x
   8144  273d8				   -			; temp5=y
   8145  273d8				   -			; temp6=number of digits
   8146  273d8				   -			; temp7=lo variable
   8147  273d8				   -			; temp8=hi variable
   8148  273d8				   -			; temp9=character mode
   8149  273d8				   -
   8150  273d8				   -plotdigitcount =	temp6
   8151  273d8				   -
   8152  273d8				   -	       ifconst	ZONELOCKS
   8153  273d8				   -	       ldx	temp5
   8154  273d8				   -	       ldy	dlend,x
   8155  273d8				   -	       cpy	#DLLASTOBJ
   8156  273d8				   -	       bne	carryonplotvalue
   8157  273d8				   -	       rts
   8158  273d8				   -carryonplotvalue
   8159  273d8				   -	       endif
   8160  273d8				   -
   8161  273d8				   -	       lda	#0
   8162  273d8				   -	       tay
   8163  273d8				   -	       ldx	valbufend
   8164  273d8				   -
   8165  273d8				   -	       lda	plotdigitcount
   8166  273d8				   -	       and	#1
   8167  273d8				   -	       beq	pvnibble2char
   8168  273d8				   -	       lda	#0
   8169  273d8				   -	       sta	VALBUFFER,x	; just in case we skip this digit
   8170  273d8				   -	       beq	pvnibble2char_skipnibble
   8171  273d8				   -
   8172  273d8				   -pvnibble2char
   8173  273d8				   -			; high nibble...
   8174  273d8				   -	       lda	(temp7),y
   8175  273d8				   -	       and	#$f0
   8176  273d8				   -	       lsr
   8177  273d8				   -	       lsr
   8178  273d8				   -	       lsr
   8179  273d8				   -	       ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   8180  273d8				   -	       lsr
   8181  273d8				   -	       endif
   8182  273d8				   -
   8183  273d8				   -	       clc
   8184  273d8				   -	       adc	temp1	; add the offset to character graphics to our value
   8185  273d8				   -	       sta	VALBUFFER,x
   8186  273d8				   -	       inx
   8187  273d8				   -	       dec	plotdigitcount
   8188  273d8				   -
   8189  273d8				   -pvnibble2char_skipnibble
   8190  273d8				   -			; low nibble...
   8191  273d8				   -	       lda	(temp7),y
   8192  273d8				   -	       and	#$0f
   8193  273d8				   -	       ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   8194  273d8				   -	       asl
   8195  273d8				   -	       endif
   8196  273d8				   -	       clc
   8197  273d8				   -	       adc	temp1	; add the offset to character graphics to our value
   8198  273d8				   -	       sta	VALBUFFER,x
   8199  273d8				   -	       inx
   8200  273d8				   -	       iny
   8201  273d8				   -
   8202  273d8				   -	       dec	plotdigitcount
   8203  273d8				   -	       bne	pvnibble2char
   8204  273d8				   -
   8205  273d8				   -			;point to the start of our valuebuffer
   8206  273d8				   -	       clc
   8207  273d8				   -	       lda	#<VALBUFFER
   8208  273d8				   -	       adc	valbufend
   8209  273d8				   -	       sta	temp1
   8210  273d8				   -	       lda	#>VALBUFFER
   8211  273d8				   -	       adc	#0
   8212  273d8				   -	       sta	temp2
   8213  273d8				   -
   8214  273d8				   -			;advance valbufend to the end of our value buffer
   8215  273d8				   -	       stx	valbufend
   8216  273d8				   -
   8217  273d8				   -	       ifnconst	plotvalueonscreen
   8218  273d8				   -	       jmp	plotcharacters
   8219  273d8				   -	       else
   8220  273d8				   -	       jmp	plotcharacterslive
   8221  273d8				   -	       endif
   8222  273d8				   -
   8223  273d8					       endif		; USED_PLOTVALUE
   8224  273d8
   8225  273d8
   8226  273d8				   -	       ifconst	USED_PLOTVALUEEXTRA
   8227  273d8				   -plotdigitcount =	temp6
   8228  273d8				   -plotvalueextra
   8229  273d8				   -			; calling 7800basic command:
   8230  273d8				   -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   8231  273d8				   -			; ...displays the variable as BCD digits
   8232  273d8				   -			;
   8233  273d8				   -			; asm sub arguments: 
   8234  273d8				   -			; temp1=lo charactermap
   8235  273d8				   -			; temp2=hi charactermap
   8236  273d8				   -			; temp3=palette | width byte
   8237  273d8				   -			; temp4=x
   8238  273d8				   -			; temp5=y
   8239  273d8				   -			; temp6=number of digits
   8240  273d8				   -			; temp7=lo variable
   8241  273d8				   -			; temp8=hi variable
   8242  273d8				   -
   8243  273d8				   -	       lda	#0
   8244  273d8				   -	       tay
   8245  273d8				   -	       ldx	valbufend
   8246  273d8				   -	       ifnconst	plotvalueonscreen
   8247  273d8				   -	       sta	VALBUFFER,x
   8248  273d8				   -	       endif
   8249  273d8				   -
   8250  273d8				   -	       lda	plotdigitcount
   8251  273d8				   -	       and	#1
   8252  273d8				   -
   8253  273d8				   -	       bne	pvnibble2char_skipnibbleextra
   8254  273d8				   -
   8255  273d8				   -pvnibble2charextra
   8256  273d8				   -			; high nibble...
   8257  273d8				   -	       lda	(temp7),y
   8258  273d8				   -	       and	#$f0
   8259  273d8				   -	       lsr
   8260  273d8				   -	       lsr
   8261  273d8				   -	       ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   8262  273d8				   -	       lsr
   8263  273d8				   -	       endif
   8264  273d8				   -	       clc
   8265  273d8				   -	       adc	temp1	; add the offset to character graphics to our value
   8266  273d8				   -	       sta	VALBUFFER,x
   8267  273d8				   -	       inx
   8268  273d8				   -
   8269  273d8				   -			; second half of the digit
   8270  273d8				   -	       clc
   8271  273d8				   -	       adc	#1
   8272  273d8				   -	       sta	VALBUFFER,x
   8273  273d8				   -	       inx
   8274  273d8				   -
   8275  273d8				   -pvnibble2char_skipnibbleextra
   8276  273d8				   -			; low nibble...
   8277  273d8				   -	       lda	(temp7),y
   8278  273d8				   -	       and	#$0f
   8279  273d8				   -	       ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   8280  273d8				   -	       asl
   8281  273d8				   -	       endif
   8282  273d8				   -	       asl
   8283  273d8				   -
   8284  273d8				   -	       clc
   8285  273d8				   -	       adc	temp1	; add the offset to character graphics to our value
   8286  273d8				   -	       sta	VALBUFFER,x
   8287  273d8				   -	       inx
   8288  273d8				   -
   8289  273d8				   -	       clc
   8290  273d8				   -	       adc	#1
   8291  273d8				   -	       sta	VALBUFFER,x
   8292  273d8				   -	       inx
   8293  273d8				   -	       iny
   8294  273d8				   -
   8295  273d8				   -	       dec	plotdigitcount
   8296  273d8				   -	       bne	pvnibble2charextra
   8297  273d8				   -
   8298  273d8				   -			;point to the start of our valuebuffer
   8299  273d8				   -	       clc
   8300  273d8				   -	       lda	#<VALBUFFER
   8301  273d8				   -	       adc	valbufend
   8302  273d8				   -	       sta	temp1
   8303  273d8				   -	       lda	#>VALBUFFER
   8304  273d8				   -	       adc	#0
   8305  273d8				   -	       sta	temp2
   8306  273d8				   -
   8307  273d8				   -			;advance valbufend to the end of our value buffer
   8308  273d8				   -	       stx	valbufend
   8309  273d8				   -
   8310  273d8				   -	       ifnconst	plotvalueonscreen
   8311  273d8				   -	       jmp	plotcharacters
   8312  273d8				   -	       else
   8313  273d8				   -	       jmp	plotcharacterslive
   8314  273d8				   -	       endif
   8315  273d8					       endif		; USED_PLOTVALUEEXTRA
   8316  273d8
   8317  273d8				    boxcollision
   8318  273d8				   -	       ifconst	BOXCOLLISION
   8319  273d8				   -			; the worst case cycle-time for the code below is 43 cycles.
   8320  273d8				   -			; unfortunately, prior to getting here we've burned 44 cycles in argument setup. eep!
   8321  273d8				   -
   8322  273d8				   -			;__boxx1 = accumulator
   8323  273d8				   -			;__boxy1 = y
   8324  273d8				   -__boxw1    =	temp3
   8325  273d8				   -__boxh1    =	temp4
   8326  273d8				   -
   8327  273d8				   -__boxx2    =	temp5
   8328  273d8				   -__boxy2    =	temp6
   8329  273d8				   -__boxw2    =	temp7
   8330  273d8				   -__boxh2    =	temp8
   8331  273d8				   -
   8332  273d8				   -DoXCollisionCheck
   8333  273d8				   -			;lda __boxx1 ; skipped. already in the accumulator
   8334  273d8				   -	       cmp	__boxx2	;3
   8335  273d8				   -	       bcs	X1isbiggerthanX2	;2/3
   8336  273d8				   -X2isbiggerthanX1
   8337  273d8				   -			; carry is clear
   8338  273d8				   -	       adc	__boxw1	;3
   8339  273d8				   -	       cmp	__boxx2	;3
   8340  273d8				   -	       bcs	DoYCollisionCheck	;3/2
   8341  273d8				   -	       rts		;6 - carry clear, no collision
   8342  273d8				   -X1isbiggerthanX2
   8343  273d8				   -	       clc		;2
   8344  273d8				   -	       sbc	__boxw2	;3
   8345  273d8				   -	       cmp	__boxx2	;3
   8346  273d8				   -	       bcs	noboxcollision	;3/2
   8347  273d8				   -DoYCollisionCheck
   8348  273d8				   -	       tya		; 2 ; use to be "lda __boxy1"
   8349  273d8				   -	       cmp	__boxy2	;3
   8350  273d8				   -	       bcs	Y1isbiggerthanY2	;3/2
   8351  273d8				   -Y2isbiggerthanY1
   8352  273d8				   -			; carry is clear
   8353  273d8				   -	       adc	__boxh1	;3
   8354  273d8				   -	       cmp	__boxy2	;3
   8355  273d8				   -	       rts		;6 
   8356  273d8				   -Y1isbiggerthanY2
   8357  273d8				   -	       clc		;2
   8358  273d8				   -	       sbc	__boxh2	;3
   8359  273d8				   -	       cmp	__boxy2	;3
   8360  273d8				   -	       bcs	noboxcollision	;3/2
   8361  273d8				   -yesboxcollision
   8362  273d8				   -	       sec		;2
   8363  273d8				   -	       rts		;6
   8364  273d8				   -noboxcollision
   8365  273d8				   -	       clc		;2
   8366  273d8				   -	       rts		;6
   8367  273d8					       endif		; BOXCOLLISION
   8368  273d8
   8369  273d8				    randomize
   8370  273d8			a5 40		       lda	rand
   8371  273da			4a		       lsr
   8372  273db			26 41		       rol	rand16
   8373  273dd			90 02		       bcc	noeor
   8374  273df			49 b4		       eor	#$B4
   8375  273e1				    noeor
   8376  273e1			85 40		       sta	rand
   8377  273e3			45 41		       eor	rand16
   8378  273e5			60		       rts
   8379  273e6
   8380  273e6							; *** bcd conversion routine courtesy Omegamatrix
   8381  273e6							; *** http://atariage.com/forums/blog/563/entry-10832-hex-to-bcd-conversion-0-99/
   8382  273e6				    converttobcd
   8383  273e6							;value to convert is in the accumulator
   8384  273e6			85 42		       sta	temp1
   8385  273e8			4a		       lsr
   8386  273e9			65 42		       adc	temp1
   8387  273eb			6a		       ror
   8388  273ec			4a		       lsr
   8389  273ed			4a		       lsr
   8390  273ee			65 42		       adc	temp1
   8391  273f0			6a		       ror
   8392  273f1			65 42		       adc	temp1
   8393  273f3			6a		       ror
   8394  273f4			4a		       lsr
   8395  273f5			29 3c		       and	#$3C
   8396  273f7			85 43		       sta	temp2
   8397  273f9			4a		       lsr
   8398  273fa			65 43		       adc	temp2
   8399  273fc			65 42		       adc	temp1
   8400  273fe			60		       rts		; return the result in the accumulator
   8401  273ff
   8402  273ff							; Y and A contain multiplicands, result in A
   8403  273ff				    mul8
   8404  273ff			84 42		       sty	temp1
   8405  27401			85 43		       sta	temp2
   8406  27403			a9 00		       lda	#0
   8407  27405				    reptmul8
   8408  27405			46 43		       lsr	temp2
   8409  27407			90 03		       bcc	skipmul8
   8410  27409			18		       clc
   8411  2740a			65 42		       adc	temp1
   8412  2740c							;bcs donemul8 might save cycles?
   8413  2740c				    skipmul8
   8414  2740c							;beq donemul8 might save cycles?
   8415  2740c			06 42		       asl	temp1
   8416  2740e			d0 f5		       bne	reptmul8
   8417  27410				    donemul8
   8418  27410			60		       rts
   8419  27411
   8420  27411				    div8
   8421  27411							; A=numerator Y=denominator, result in A
   8422  27411			c0 02		       cpy	#2
   8423  27413			90 0a		       bcc	div8end+1	;div by 0 = bad, div by 1=no calc needed, so bail out
   8424  27415			84 42		       sty	temp1
   8425  27417			a0 ff		       ldy	#$ff
   8426  27419				    div8loop
   8427  27419			e5 42		       sbc	temp1
   8428  2741b			c8		       iny
   8429  2741c			b0 fb		       bcs	div8loop
   8430  2741e				    div8end
   8431  2741e			98		       tya
   8432  2741f							; result in A
   8433  2741f			60		       rts
   8434  27420
   8435  27420							; Y and A contain multiplicands, result in temp2,A=low, temp1=high
   8436  27420				    mul16
   8437  27420			84 42		       sty	temp1
   8438  27422			85 43		       sta	temp2
   8439  27424
   8440  27424			a9 00		       lda	#0
   8441  27426			a2 08		       ldx	#8
   8442  27428			46 42		       lsr	temp1
   8443  2742a				    mul16_1
   8444  2742a			90 03		       bcc	mul16_2
   8445  2742c			18		       clc
   8446  2742d			65 43		       adc	temp2
   8447  2742f				    mul16_2
   8448  2742f			6a		       ror
   8449  27430			66 42		       ror	temp1
   8450  27432			ca		       dex
   8451  27433			d0 f5		       bne	mul16_1
   8452  27435			85 43		       sta	temp2
   8453  27437			60		       rts
   8454  27438
   8455  27438							; div int/int
   8456  27438							; numerator in A, denom in temp1
   8457  27438							; returns with quotient in A, remainder in temp1
   8458  27438				    div16
   8459  27438			85 43		       sta	temp2
   8460  2743a			84 42		       sty	temp1
   8461  2743c			a9 00		       lda	#0
   8462  2743e			a2 08		       ldx	#8
   8463  27440			06 43		       asl	temp2
   8464  27442				    div16_1
   8465  27442			2a		       rol
   8466  27443			c5 42		       cmp	temp1
   8467  27445			90 02		       bcc	div16_2
   8468  27447			e5 42		       sbc	temp1
   8469  27449				    div16_2
   8470  27449			26 43		       rol	temp2
   8471  2744b			ca		       dex
   8472  2744c			d0 f4		       bne	div16_1
   8473  2744e			85 42		       sta	temp1
   8474  27450			a5 43		       lda	temp2
   8475  27452			60		       rts
   8476  27453
   8477  27453					       ifconst	bankswitchmode
   8478  27453				    BS_jsr
   8479  27453				   -	       ifconst	dumpbankswitch
   8480  27453				   -	       sta	dumpbankswitch
   8481  27453					       endif
   8482  27453				   -	       ifconst	MCPDEVCART
   8483  27453				   -	       ora	#$18
   8484  27453				   -	       sta	$3000
   8485  27453					       else
   8486  27453			8d 00 80	       sta	$8000
   8487  27456					       endif
   8488  27456			68		       pla
   8489  27457			aa		       tax
   8490  27458			68		       pla
   8491  27459			60		       rts
   8492  2745a
   8493  2745a				    BS_return
   8494  2745a			68		       pla		; bankswitch bank
   8495  2745b				   -	       ifconst	dumpbankswitch
   8496  2745b				   -	       sta	dumpbankswitch
   8497  2745b					       endif
   8498  2745b				   -	       ifconst	BANKRAM
   8499  2745b				   -	       sta	currentbank
   8500  2745b				   -	       ora	currentrambank
   8501  2745b					       endif
   8502  2745b				   -	       ifconst	MCPDEVCART
   8503  2745b				   -	       ora	#$18
   8504  2745b				   -	       sta	$3000
   8505  2745b					       else
   8506  2745b			8d 00 80	       sta	$8000
   8507  2745e					       endif
   8508  2745e			68		       pla		; bankswitch $0 flag
   8509  2745f			60		       rts
   8510  27460					       endif
   8511  27460
   8512  27460				    checkselectswitch
   8513  27460			ad 82 02	       lda	SWCHB	; first check the real select switch...
   8514  27463			29 02		       and	#%00000010
   8515  27465					       ifnconst	MOUSESUPPORT
   8516  27465					       ifnconst	TRAKBALLSUPPORT
   8517  27465			f0 05		       beq	checkselectswitchreturn	; switch is pressed
   8518  27467			ad 80 02	       lda	SWCHA	; then check the soft "select" joysick code...
   8519  2746a			29 b0		       and	#%10110000	; R_DU
   8520  2746c					       endif		; TRAKBALLSUPPORT
   8521  2746c					       endif		; MOUSESUPPORT
   8522  2746c				    checkselectswitchreturn
   8523  2746c			60		       rts
   8524  2746d
   8525  2746d				    checkresetswitch
   8526  2746d			ad 82 02	       lda	SWCHB	; first check the real reset switch...
   8527  27470			29 01		       and	#%00000001
   8528  27472					       ifnconst	MOUSESUPPORT
   8529  27472					       ifnconst	TRAKBALLSUPPORT
   8530  27472			f0 05		       beq	checkresetswitchreturn	; switch is pressed
   8531  27474			ad 80 02	       lda	SWCHA	; then check the soft "reset" joysick code...
   8532  27477			29 70		       and	#%01110000	; _LDU
   8533  27479					       endif		; TRAKBALLSUPPORT
   8534  27479					       endif		; MOUSESUPPORT
   8535  27479				    checkresetswitchreturn
   8536  27479			60		       rts
   8537  2747a
   8538  2747a				   -	       ifconst	FINESCROLLENABLED
   8539  2747a				   -finescrolldlls
   8540  2747a				   -	       ldx	temp1	; first DLL index x3
   8541  2747a				   -	       lda	DLLMEM,x
   8542  2747a				   -	       and	#%11110000
   8543  2747a				   -	       ora	finescrolly
   8544  2747a				   -	       sta	DLLMEM,x
   8545  2747a				   -
   8546  2747a				   -	       ldx	temp2	; last DLL index x3
   8547  2747a				   -	       lda	DLLMEM,x
   8548  2747a				   -	       and	#%11110000
   8549  2747a				   -	       ora	finescrolly
   8550  2747a				   -	       eor	#(WZONEHEIGHT-1)
   8551  2747a				   -	       sta	DLLMEM,x
   8552  2747a				   -	       rts
   8553  2747a					       endif		; FINESCROLLENABLED
   8554  2747a
   8555  2747a				   -	       ifconst	USED_ADJUSTVISIBLE
   8556  2747a				   -adjustvisible
   8557  2747a				   -			; called with temp1=first visible zone *3, temp2=last visible zone *3
   8558  2747a				   -	       jsr	waitforvblankstart	; ensure vblank just started
   8559  2747a				   -	       ldx	visibleDLLstart
   8560  2747a				   -findfirstinterrupt
   8561  2747a				   -	       lda	DLLMEM,x
   8562  2747a				   -	       bmi	foundfirstinterrupt
   8563  2747a				   -	       inx
   8564  2747a				   -	       inx
   8565  2747a				   -	       inx
   8566  2747a				   -	       bne	findfirstinterrupt
   8567  2747a				   -foundfirstinterrupt
   8568  2747a				   -	       and	#%01111111	; clear the interrupt bit
   8569  2747a				   -	       sta	DLLMEM,x
   8570  2747a				   -	       ifconst	DOUBLEBUFFER
   8571  2747a				   -	       sta	DLLMEM+DBOFFSET,x
   8572  2747a				   -	       endif		; DOUBLEBUFFER
   8573  2747a				   -	       ldx	overscanDLLstart
   8574  2747a				   -findlastinterrupt
   8575  2747a				   -	       lda	DLLMEM,x
   8576  2747a				   -	       bmi	foundlastinterrupt
   8577  2747a				   -	       dex
   8578  2747a				   -	       dex
   8579  2747a				   -	       dex
   8580  2747a				   -	       bne	findlastinterrupt
   8581  2747a				   -foundlastinterrupt
   8582  2747a				   -	       and	#%01111111	; clear the interrupt bit
   8583  2747a				   -	       sta	DLLMEM,x
   8584  2747a				   -	       ifconst	DOUBLEBUFFER
   8585  2747a				   -	       sta	DLLMEM+DBOFFSET,x
   8586  2747a				   -	       endif		; DOUBLEBUFFER
   8587  2747a				   -			;now we need to set the new interrupts
   8588  2747a				   -	       clc
   8589  2747a				   -	       lda	temp1
   8590  2747a				   -	       adc	visibleDLLstart
   8591  2747a				   -	       tax
   8592  2747a				   -	       lda	DLLMEM,x
   8593  2747a				   -	       ora	#%10000000
   8594  2747a				   -	       sta	DLLMEM,x
   8595  2747a				   -	       ifconst	DOUBLEBUFFER
   8596  2747a				   -	       sta	DLLMEM+DBOFFSET,x
   8597  2747a				   -	       endif		; DOUBLEBUFFER
   8598  2747a				   -	       clc
   8599  2747a				   -	       lda	temp2
   8600  2747a				   -	       adc	visibleDLLstart
   8601  2747a				   -	       tax
   8602  2747a				   -	       lda	DLLMEM,x
   8603  2747a				   -	       ora	#%10000000
   8604  2747a				   -	       sta	DLLMEM,x
   8605  2747a				   -	       ifconst	DOUBLEBUFFER
   8606  2747a				   -	       sta	DLLMEM+DBOFFSET,x
   8607  2747a				   -	       endif		; DOUBLEBUFFER
   8608  2747a				   -	       jsr	vblankresync
   8609  2747a				   -	       rts
   8610  2747a					       endif		; USED_ADJUSTVISIBLE
   8611  2747a
   8612  2747a				    vblankresync
   8613  2747a			20 3b f5	       jsr	waitforvblankstart	; ensure vblank just started
   8614  2747d			a9 00		       lda	#0
   8615  2747f			85 4d		       sta	visibleover
   8616  27481			a9 03		       lda	#3
   8617  27483			8d b2 01	       sta	interruptindex
   8618  27486			60		       rts
   8619  27487
   8620  27487				    createallgamedlls
   8621  27487			a2 00		       ldx	#0
   8622  27489			a9 09		       lda	#NVLINES
   8623  2748b			ac 09 21	       ldy	paldetected
   8624  2748e			f0 03		       beq	skipcreatePALpadding
   8625  27490			18		       clc
   8626  27491			69 15		       adc	#21
   8627  27493				    skipcreatePALpadding
   8628  27493			20 d1 f4	       jsr	createnonvisibledlls
   8629  27496			8e 3c 21	       stx	visibleDLLstart
   8630  27499			20 0b f5	       jsr	createvisiblezones
   8631  2749c			8e 3d 21	       stx	overscanDLLstart
   8632  2749f				    createallgamedllscontinue
   8633  2749f			a9 40		       lda	#(NVLINES+55)	; extras for PAL
   8634  274a1			20 d1 f4	       jsr	createnonvisibledlls
   8635  274a4
   8636  274a4			ae 3c 21	       ldx	visibleDLLstart
   8637  274a7			bd 00 18	       lda	DLLMEM,x
   8638  274aa			09 80		       ora	#%10000000	; NMI 1 - start of visible screen
   8639  274ac			9d 00 18	       sta	DLLMEM,x
   8640  274af					       ifconst	DOUBLEBUFFER
   8641  274af			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   8642  274b2					       endif		; DOUBLEBUFFER
   8643  274b2
   8644  274b2			ae 3d 21	       ldx	overscanDLLstart
   8645  274b5			bd 00 18	       lda	DLLMEM,x
   8646  274b8			09 83		       ora	#%10000011	; NMI 2 - end of visible screen
   8647  274ba			29 f3		       and	#%11110011	; change this to a 1-line DLL, so there's time enough for the "deeper overscan" DLL
   8648  274bc			9d 00 18	       sta	DLLMEM,x
   8649  274bf					       ifconst	DOUBLEBUFFER
   8650  274bf			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   8651  274c2					       endif		; DOUBLEBUFFER
   8652  274c2
   8653  274c2			e8		       inx
   8654  274c3			e8		       inx
   8655  274c4			e8		       inx
   8656  274c5
   8657  274c5			bd 00 18	       lda	DLLMEM,x
   8658  274c8			09 80		       ora	#%10000000	; NMI 3 - deeper overscan
   8659  274ca			9d 00 18	       sta	DLLMEM,x
   8660  274cd					       ifconst	DOUBLEBUFFER
   8661  274cd			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   8662  274d0					       endif		; DOUBLEBUFFER
   8663  274d0
   8664  274d0			60		       rts
   8665  274d1
   8666  274d1				    createnonvisibledlls
   8667  274d1			85 42		       sta	temp1
   8668  274d3			4a		       lsr
   8669  274d4			4a		       lsr
   8670  274d5			4a		       lsr
   8671  274d6			4a		       lsr		; /16
   8672  274d7			f0 09		       beq	skipcreatenonvisibledlls1loop
   8673  274d9			a8		       tay
   8674  274da				    createnonvisibledlls1loop
   8675  274da			a9 4f		       lda	#%01001111	;low nibble=16 lines, high nibble=Holey DMA
   8676  274dc			20 f1 f4	       jsr	createblankdllentry
   8677  274df			88		       dey
   8678  274e0			d0 f8		       bne	createnonvisibledlls1loop
   8679  274e2				    skipcreatenonvisibledlls1loop
   8680  274e2			a5 42		       lda	temp1
   8681  274e4			29 0f		       and	#%00001111
   8682  274e6			f0 08		       beq	createnonvisibledllsreturn
   8683  274e8			38		       sec
   8684  274e9			e9 01		       sbc	#1
   8685  274eb			09 40		       ora	#%01000000
   8686  274ed			20 f1 f4	       jsr	createblankdllentry
   8687  274f0				    createnonvisibledllsreturn
   8688  274f0			60		       rts
   8689  274f1
   8690  274f1				    createblankdllentry
   8691  274f1			9d 00 18	       sta	DLLMEM,x
   8692  274f4					       ifconst	DOUBLEBUFFER
   8693  274f4			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   8694  274f7					       endif		; DOUBLEBUFFER
   8695  274f7			e8		       inx
   8696  274f8			a9 21		       lda	#$21	; blank
   8697  274fa			9d 00 18	       sta	DLLMEM,x
   8698  274fd					       ifconst	DOUBLEBUFFER
   8699  274fd			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   8700  27500					       endif		; DOUBLEBUFFER
   8701  27500			e8		       inx
   8702  27501			a9 00		       lda	#$00
   8703  27503			9d 00 18	       sta	DLLMEM,x
   8704  27506					       ifconst	DOUBLEBUFFER
   8705  27506			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   8706  27509					       endif		; DOUBLEBUFFER
   8707  27509			e8		       inx
   8708  2750a			60		       rts
   8709  2750b
   8710  2750b				    createvisiblezones
   8711  2750b			a0 00		       ldy	#0
   8712  2750d				    createvisiblezonesloop
   8713  2750d			b9 a6 f6	       lda.w	DLHEIGHT,y
   8714  27510			09 40		       ora	#(WZONEHEIGHT * 4)	; set Holey DMA for 8 or 16 tall zones
   8715  27512			9d 00 18	       sta	DLLMEM,x
   8716  27515					       ifconst	DOUBLEBUFFER
   8717  27515			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   8718  27518					       endif		; DOUBLEBUFFER
   8719  27518			e8		       inx
   8720  27519			b9 8a f6	       lda	DLPOINTH,y
   8721  2751c			9d 00 18	       sta	DLLMEM,x
   8722  2751f					       ifconst	DOUBLEBUFFER
   8723  2751f			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   8724  27522					       endif		; DOUBLEBUFFER
   8725  27522			e8		       inx
   8726  27523			b9 98 f6	       lda	DLPOINTL,y
   8727  27526			9d 00 18	       sta	DLLMEM,x
   8728  27529					       ifconst	DOUBLEBUFFER
   8729  27529			18		       clc
   8730  2752a			69 34		       adc	#DOUBLEBUFFEROFFSET
   8731  2752c			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   8732  2752f			90 03		       bcc	skiphidoublebufferadjust	; dlls are big endian, so we need to fix the hi byte after-the-fact...
   8733  27531			fe 6f 18	       inc	DLLMEM+DBOFFSET-1,x
   8734  27534				    skiphidoublebufferadjust
   8735  27534					       endif		; DOUBLEBUFFER
   8736  27534			e8		       inx
   8737  27535			c8		       iny
   8738  27536			c0 0e		       cpy	#WZONECOUNT
   8739  27538			d0 d3		       bne	createvisiblezonesloop
   8740  2753a			60		       rts
   8741  2753b
   8742  2753b				    waitforvblankstart
   8743  2753b				    vblankendwait
   8744  2753b			24 28		       BIT	MSTAT
   8745  2753d			30 fc		       bmi	vblankendwait
   8746  2753f				    vblankstartwait
   8747  2753f			24 28		       BIT	MSTAT
   8748  27541			10 fc		       bpl	vblankstartwait
   8749  27543			60		       rts
   8750  27544
   8751  27544					       ifconst	DOUBLEBUFFER
   8752  27544				    flipdisplaybufferreturn
   8753  27544			60		       rts
   8754  27545				    flipdisplaybuffer
   8755  27545				   -	       ifconst	interrupthold
   8756  27545				   -	       lda	#$FF
   8757  27545				   -	       sta	interrupthold
   8758  27545					       endif
   8759  27545			a5 d5		       lda	doublebufferstate
   8760  27547			f0 fb		       beq	flipdisplaybufferreturn	; exit if we're not in double-buffer
   8761  27549
   8762  27549			20 4d f1	       jsr	terminatedisplaybuffer	; terminate the working buffer before we flip
   8763  2754c
   8764  2754c			a5 d5		       lda	doublebufferstate
   8765  2754e			4a		       lsr		; /2, so we'll see 0 or 1, rather than 1 or 3
   8766  2754f			aa		       tax
   8767  27550
   8768  27550							; ensure we don't flip mid-display. otherwise the displayed DL will be the one the game is working on.
   8769  27550
   8770  27550				    flipdisplaybufferwait1
   8771  27550			a5 4d		       lda	visibleover
   8772  27552			f0 fc		       beq	flipdisplaybufferwait1
   8773  27554
   8774  27554				    flipdisplaybufferwait
   8775  27554			a5 4d		       lda	visibleover
   8776  27556			d0 fc		       bne	flipdisplaybufferwait
   8777  27558
   8778  27558			ad b3 01	       lda	doublebufferminimumframetarget
   8779  2755b			f0 0b		       beq	skipminimumframecode
   8780  2755d			ad b4 01	       lda	doublebufferminimumframeindex
   8781  27560			d0 ee		       bne	flipdisplaybufferwait1
   8782  27562			ad b3 01	       lda	doublebufferminimumframetarget
   8783  27565			8d b4 01	       sta	doublebufferminimumframeindex
   8784  27568				    skipminimumframecode
   8785  27568
   8786  27568			bd c8 f5	       lda	DLLMEMLutHi,x
   8787  2756b			85 2c		       sta	DPPH
   8788  2756d			bd c6 f5	       lda	DLLMEMLutLo,x
   8789  27570			85 30		       sta	DPPL
   8790  27572
   8791  27572			bd ca f5	       lda	NewPageflipstate,x
   8792  27575			85 d5		       sta	doublebufferstate
   8793  27577			bd cc f5	       lda	NewPageflipoffset,x
   8794  2757a			85 d6		       sta	doublebufferdloffset
   8795  2757c
   8796  2757c			a5 d7		       lda	doublebufferbufferdirty
   8797  2757e			f0 c4		       beq	flipdisplaybufferreturn
   8798  27580
   8799  27580							; The doublebuffer buffer is dirty, so the game code must have issued a savescreen recently.
   8800  27580							; To make savescreen work with the new working buffer, we need to copy over the saved objects
   8801  27580							; from the displayed buffer to the working buffer...
   8802  27580
   8803  27580			a5 d6		       lda	doublebufferdloffset
   8804  27582			49 34		       eor	#DOUBLEBUFFEROFFSET
   8805  27584			85 47		       sta	temp6	; make temp6 the anti-doublebufferdloffset variable
   8806  27586
   8807  27586			a2 0d		       ldx	#(WZONECOUNT-1)
   8808  27588				    copybufferzoneloop
   8809  27588
   8810  27588			bd 98 f6	       lda	DLPOINTL,x
   8811  2758b			18		       clc
   8812  2758c			65 d6		       adc	doublebufferdloffset
   8813  2758e			85 42		       sta	temp1
   8814  27590			bd 8a f6	       lda	DLPOINTH,x
   8815  27593			69 00		       adc	#0
   8816  27595			85 43		       sta	temp2
   8817  27597
   8818  27597			bd 98 f6	       lda	DLPOINTL,x
   8819  2759a			18		       clc
   8820  2759b			65 47		       adc	temp6
   8821  2759d			85 44		       sta	temp3
   8822  2759f			bd 8a f6	       lda	DLPOINTH,x
   8823  275a2			69 00		       adc	#0
   8824  275a4			85 45		       sta	temp4
   8825  275a6
   8826  275a6			b5 82		       lda	dlendsave,x
   8827  275a8			a8		       tay
   8828  275a9				    copybuffercharsloop
   8829  275a9			b1 44		       lda	(temp3),y
   8830  275ab			91 42		       sta	(temp1),y
   8831  275ad			88		       dey
   8832  275ae			10 f9		       bpl	copybuffercharsloop
   8833  275b0			ca		       dex
   8834  275b1			10 d5		       bpl	copybufferzoneloop
   8835  275b3			a9 00		       lda	#0
   8836  275b5			85 d7		       sta	doublebufferbufferdirty
   8837  275b7			60		       rts
   8838  275b8
   8839  275b8				    doublebufferoff
   8840  275b8			a9 01		       lda	#1
   8841  275ba			85 d5		       sta	doublebufferstate
   8842  275bc			20 45 f5	       jsr	flipdisplaybuffer
   8843  275bf			a9 00		       lda	#0
   8844  275c1			85 d5		       sta	doublebufferstate
   8845  275c3			85 d6		       sta	doublebufferdloffset
   8846  275c5			60		       rts
   8847  275c6
   8848  275c6				    DLLMEMLutLo
   8849  275c6			00 70		       .byte.b	<DLLMEM,<(DLLMEM+DBOFFSET)
   8850  275c8				    DLLMEMLutHi
   8851  275c8			18 18		       .byte.b	>DLLMEM,>(DLLMEM+DBOFFSET)
   8852  275ca				    NewPageflipstate
   8853  275ca			03 01		       .byte.b	3,1
   8854  275cc				    NewPageflipoffset
   8855  275cc			34 00		       .byte.b	DOUBLEBUFFEROFFSET,0
   8856  275ce
   8857  275ce					       endif		; DOUBLEBUFFER
   8858  275ce
   8859  275ce				   -	       ifconst	MOUSESUPPORT
   8860  275ce				   -
   8861  275ce				   -rotationalcompare
   8862  275ce				   -			; old =   00	  01	  10	 11
   8863  275ce				   -	       .byte	$00, $01, $ff, $00	; new=00
   8864  275ce				   -	       .byte	$ff, $00, $00, $01	; new=01
   8865  275ce				   -	       .byte	$01, $00, $00, $ff	; new=10
   8866  275ce				   -	       .byte	$00, $ff, $01, $00	; new=11
   8867  275ce				   -
   8868  275ce				   -			;  0000YyXx st mouse
   8869  275ce				   -
   8870  275ce				   -			;  0000xyXY amiga mouse
   8871  275ce				   -
   8872  275ce				   -	       ifconst	MOUSEXONLY
   8873  275ce				   -amigatoataribits		; swap bits 1 and 4...
   8874  275ce				   -	       .byte	%0000, %0000, %0010, %0010
   8875  275ce				   -	       .byte	%0000, %0000, %0010, %0010
   8876  275ce				   -	       .byte	%0001, %0001, %0011, %0011
   8877  275ce				   -	       .byte	%0001, %0001, %0011, %0011
   8878  275ce				   -
   8879  275ce				   -			; null change bits
   8880  275ce				   -	       .byte	%0000, %0001, %0010, %0011
   8881  275ce				   -	       .byte	%0000, %0001, %0010, %0011
   8882  275ce				   -	       .byte	%0000, %0001, %0010, %0011
   8883  275ce				   -	       .byte	%0000, %0001, %0010, %0011
   8884  275ce				   -
   8885  275ce				   -	       else		; !MOUSEXONLY
   8886  275ce				   -
   8887  275ce				   -amigatoataribits		; swap bits 1 and 4...
   8888  275ce				   -	       .byte	%0000, %1000, %0010, %1010
   8889  275ce				   -	       .byte	%0100, %1100, %0110, %1110
   8890  275ce				   -	       .byte	%0001, %1001, %0011, %1011
   8891  275ce				   -	       .byte	%0101, %1101, %0111, %1111
   8892  275ce				   -			; null change bits
   8893  275ce				   -	       .byte	%0000, %0001, %0010, %0011
   8894  275ce				   -	       .byte	%0100, %0101, %0110, %0111
   8895  275ce				   -	       .byte	%1000, %1001, %1010, %1011
   8896  275ce				   -	       .byte	%1100, %1101, %1110, %1111
   8897  275ce				   -	       endif		; !MOUSEXONLY
   8898  275ce				   -
   8899  275ce					       endif		; MOUSESUPPORT
   8900  275ce
   8901  275ce				    mouse0update
   8902  275ce				   -	       ifconst	MOUSE0SUPPORT
   8903  275ce				   -
   8904  275ce				   -mousetableselect =	inttemp2
   8905  275ce				   -mousexdelta =	inttemp3
   8906  275ce				   -mouseydelta =	inttemp4
   8907  275ce				   -lastSWCHA  =	inttemp6
   8908  275ce				   -
   8909  275ce				   -			;  0000YyXx st mouse
   8910  275ce				   -			;  0000xyXY amiga mouse
   8911  275ce				   -
   8912  275ce				   -	       lda	#$ff
   8913  275ce				   -	       sta	lastSWCHA
   8914  275ce				   -
   8915  275ce				   -	       ldy	port0control
   8916  275ce				   -
   8917  275ce				   -	       lda	#%00010000
   8918  275ce				   -	       cpy	#9	; AMIGA?
   8919  275ce				   -	       bne	skipamigabitsfix0
   8920  275ce				   -	       lda	#0
   8921  275ce				   -skipamigabitsfix0
   8922  275ce				   -	       sta	mousetableselect
   8923  275ce				   -	       ifconst	DRIVINGBOOST
   8924  275ce				   -	       cpy	#6	; DRIVING?
   8925  275ce				   -	       bne	skipdriving0setup
   8926  275ce				   -			; swap mousex0 and mousey0. mousex seen by the 7800basic program
   8927  275ce				   -			; trails the actual mousex0, so we can smoothly interpolate toward
   8928  275ce				   -			; the actual position. This actual position is stored in mousey0 
   8929  275ce				   -			; after the driver has run.
   8930  275ce				   -	       ldx	mousex0
   8931  275ce				   -	       lda	mousey0
   8932  275ce				   -	       stx	mousey0
   8933  275ce				   -	       sta	mousex0
   8934  275ce				   -skipdriving0setup
   8935  275ce				   -	       endif		; DRIVINGBOOST
   8936  275ce				   -
   8937  275ce				   -	       lda	#0
   8938  275ce				   -	       sta	mousexdelta
   8939  275ce				   -	       sta	mouseydelta
   8940  275ce				   -
   8941  275ce				   -	       ifnconst	MOUSETIME
   8942  275ce				   -	       ifnconst	MOUSEXONLY
   8943  275ce				   -	       lda	#180	; minimum for x+y
   8944  275ce				   -	       else
   8945  275ce				   -	       lda	#100	; minimum for just x
   8946  275ce				   -	       endif
   8947  275ce				   -	       else
   8948  275ce				   -	       lda	#MOUSETIME
   8949  275ce				   -	       endif
   8950  275ce				   -	       jsr	SETTIM64T	; INTIM is in Y
   8951  275ce				   -
   8952  275ce				   -mouse0updateloop
   8953  275ce				   -	       lda	SWCHA
   8954  275ce				   -	       asr	#%11110000	; Undocumented. A = A & #IMM, then LSR A.
   8955  275ce				   -	       cmp	lastSWCHA
   8956  275ce				   -	       beq	mouse0loopcondition
   8957  275ce				   -	       sta	lastSWCHA
   8958  275ce				   -	       lsr
   8959  275ce				   -	       lsr
   8960  275ce				   -	       lsr
   8961  275ce				   -
   8962  275ce				   -	       ora	mousetableselect	; atari/amiga decoding table selection
   8963  275ce				   -
   8964  275ce				   -			; st mice encode on different bits/joystick-lines than amiga mice...
   8965  275ce				   -			;  0000YyXx st mouse
   8966  275ce				   -			;  0000xyXY amiga mouse
   8967  275ce				   -			; ...so can shuffle the amiga bits to reuse the st driver.
   8968  275ce				   -	       tay
   8969  275ce				   -	       lax	amigatoataribits,y
   8970  275ce				   -
   8971  275ce				   -	       ifnconst	MOUSEXONLY
   8972  275ce				   -			; first the Y...
   8973  275ce				   -	       and	#%00001100
   8974  275ce				   -	       ora	mousecodey0
   8975  275ce				   -	       tay
   8976  275ce				   -	       lda	rotationalcompare,y
   8977  275ce				   -	       clc
   8978  275ce				   -	       adc	mouseydelta
   8979  275ce				   -	       sta	mouseydelta
   8980  275ce				   -	       tya
   8981  275ce				   -	       lsr
   8982  275ce				   -	       lsr
   8983  275ce				   -	       sta	mousecodey0
   8984  275ce				   -	       txa
   8985  275ce				   -			; ...then the X...
   8986  275ce				   -	       and	#%00000011
   8987  275ce				   -	       tax
   8988  275ce				   -	       endif		; !MOUSEXONLY
   8989  275ce				   -
   8990  275ce				   -	       asl
   8991  275ce				   -	       asl
   8992  275ce				   -	       ora	mousecodex0
   8993  275ce				   -	       tay
   8994  275ce				   -	       lda	rotationalcompare,y
   8995  275ce				   -	       adc	mousexdelta	; carry was clear by previous ASL
   8996  275ce				   -	       sta	mousexdelta
   8997  275ce				   -	       stx	mousecodex0
   8998  275ce				   -mouse0loopcondition
   8999  275ce				   -	       lda	TIMINT
   9000  275ce				   -	       bpl	mouse0updateloop
   9001  275ce				   -
   9002  275ce				   -			; *** adapt to selected device resolution. 
   9003  275ce				   -	       ldx	port0control
   9004  275ce				   -
   9005  275ce				   -	       ifconst	PRECISIONMOUSING
   9006  275ce				   -	       ldy	port0resolution
   9007  275ce				   -	       bne	mouse0halveddone
   9008  275ce				   -	       cpx	#6	; half-resolution is no good for driving wheels
   9009  275ce				   -	       beq	mouse0halveddone
   9010  275ce				   -			; resolution=0 is half mouse resolution, necessary for precision 
   9011  275ce				   -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   9012  275ce				   -
   9013  275ce				   -	       lda	mousexdelta
   9014  275ce				   -	       cmp	#$80
   9015  275ce				   -	       ror		; do a signed divide by 2.
   9016  275ce				   -	       clc
   9017  275ce				   -	       adc	mousex0
   9018  275ce				   -	       sta	mousex0
   9019  275ce				   -	       ifnconst	MOUSEXONLY
   9020  275ce				   -	       lda	mouseydelta
   9021  275ce				   -	       clc
   9022  275ce				   -	       adc	mousey0
   9023  275ce				   -	       sta	mousey0
   9024  275ce				   -	       endif
   9025  275ce				   -			; at half resolution we just exit after updating x and y
   9026  275ce				   -	       jmp	LLRET0
   9027  275ce				   -mouse0halveddone
   9028  275ce				   -	       endif		; PRECISIONMOUSING
   9029  275ce				   -
   9030  275ce				   -	       ifnconst	MOUSEXONLY
   9031  275ce				   -	       asl	mouseydelta	; *2 because Y resolution is finer
   9032  275ce				   -	       ldy	port0resolution
   9033  275ce				   -	       dey
   9034  275ce				   -	       lda	#0
   9035  275ce				   -mousey0resolutionfix
   9036  275ce				   -	       clc
   9037  275ce				   -	       adc	mouseydelta
   9038  275ce				   -	       dey
   9039  275ce				   -	       bpl	mousey0resolutionfix
   9040  275ce				   -	       clc
   9041  275ce				   -	       adc	mousey0
   9042  275ce				   -	       sta	mousey0
   9043  275ce				   -	       endif		; MOUSEXONLY
   9044  275ce				   -
   9045  275ce				   -	       ldy	port0resolution
   9046  275ce				   -	       dey
   9047  275ce				   -	       lda	#0
   9048  275ce				   -mousex0resolutionfix
   9049  275ce				   -	       clc
   9050  275ce				   -	       adc	mousexdelta
   9051  275ce				   -	       dey
   9052  275ce				   -	       bpl	mousex0resolutionfix
   9053  275ce				   -	       ifnconst	DRIVINGBOOST
   9054  275ce				   -	       clc
   9055  275ce				   -	       adc	mousex0
   9056  275ce				   -	       sta	mousex0
   9057  275ce				   -	       else
   9058  275ce				   -	       cpx	#6
   9059  275ce				   -	       beq	carryonmouse0boost
   9060  275ce				   -	       clc
   9061  275ce				   -	       adc	mousex0
   9062  275ce				   -	       sta	mousex0
   9063  275ce				   -	       jmp	LLRET0
   9064  275ce				   -carryonmouse0boost
   9065  275ce				   -	       sta	mousexdelta
   9066  275ce				   -	       clc
   9067  275ce				   -	       adc	mousecodey0
   9068  275ce				   -	       sta	mousecodey0
   9069  275ce				   -	       clc
   9070  275ce				   -	       adc	mousex0
   9071  275ce				   -	       tay		; save the target X
   9072  275ce				   -	       adc	mousey0	; average in the smoothly-trailing X
   9073  275ce				   -	       ror
   9074  275ce				   -	       sta	mousex0	; mousex0 now has the smoothly trailing X
   9075  275ce				   -	       sty	mousey0	; and mousey0 has the the target X
   9076  275ce				   -
   9077  275ce				   -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   9078  275ce				   -			; A has mousex0, the smoothly trailing X
   9079  275ce				   -	       sbc	mousey0	; less the target X
   9080  275ce				   -	       bpl	skipabsolutedrive0
   9081  275ce				   -	       eor	#$ff
   9082  275ce				   -skipabsolutedrive0
   9083  275ce				   -	       cmp	#64	; just an unreasonably large change
   9084  275ce				   -	       bcc	skipdrivewrapfix0
   9085  275ce				   -	       sty	mousex0	; if X wrapped, we catch the trailing X up to the target X
   9086  275ce				   -skipdrivewrapfix0
   9087  275ce				   -
   9088  275ce				   -			; get rid of the tweening if the distance travelled was very small
   9089  275ce				   -	       lda	mousexdelta
   9090  275ce				   -	       cmp	port0resolution
   9091  275ce				   -	       bcs	skipbetweenfix0
   9092  275ce				   -	       lda	mousex0
   9093  275ce				   -	       sta	mousey0
   9094  275ce				   -skipbetweenfix0
   9095  275ce				   -
   9096  275ce				   -drivingboostreductioncheck0
   9097  275ce				   -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   9098  275ce				   -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   9099  275ce				   -			; negated again because truncation during BCD math results in 
   9100  275ce				   -			; differing magnitudes, depending if the value is  +ve or -ve.
   9101  275ce				   -driving0fix
   9102  275ce				   -	       lax	mousecodey0
   9103  275ce				   -	       cmp	#$80
   9104  275ce				   -	       bcs	driving0skipnegate1
   9105  275ce				   -	       eor	#$FF
   9106  275ce				   -	       adc	#1
   9107  275ce				   -	       sta	mousecodey0
   9108  275ce				   -driving0skipnegate1
   9109  275ce				   -	       cmp	#$80
   9110  275ce				   -	       ror
   9111  275ce				   -	       cmp	#$80
   9112  275ce				   -	       ror
   9113  275ce				   -	       cmp	#$80
   9114  275ce				   -	       ror
   9115  275ce				   -	       sta	inttemp1
   9116  275ce				   -	       lda	mousecodey0
   9117  275ce				   -	       sec
   9118  275ce				   -	       sbc	inttemp1
   9119  275ce				   -	       cpx	#$80
   9120  275ce				   -	       bcs	driving0skipnegate2
   9121  275ce				   -	       eor	#$FF
   9122  275ce				   -	       adc	#1
   9123  275ce				   -driving0skipnegate2
   9124  275ce				   -	       sta	mousecodey0
   9125  275ce				   -drivingboostdone0
   9126  275ce				   -	       endif		; DRIVINGBOOST
   9127  275ce				   -
   9128  275ce				   -	       jmp	LLRET0
   9129  275ce				   -
   9130  275ce					       endif		; MOUSE0SUPPORT
   9131  275ce
   9132  275ce				    mouse1update
   9133  275ce				   -	       ifconst	MOUSE1SUPPORT
   9134  275ce				   -
   9135  275ce				   -mousetableselect =	inttemp2
   9136  275ce				   -mousexdelta =	inttemp3
   9137  275ce				   -mouseydelta =	inttemp4
   9138  275ce				   -lastSWCHA  =	inttemp6
   9139  275ce				   -
   9140  275ce				   -			;  0000YyXx st mouse
   9141  275ce				   -			;  0000xyXY amiga mouse
   9142  275ce				   -
   9143  275ce				   -	       lda	#$ff
   9144  275ce				   -	       sta	lastSWCHA
   9145  275ce				   -
   9146  275ce				   -	       ldy	port1control
   9147  275ce				   -
   9148  275ce				   -	       lda	#%00010000
   9149  275ce				   -	       cpy	#9	; AMIGA?
   9150  275ce				   -	       bne	skipamigabitsfix1
   9151  275ce				   -	       lda	#0
   9152  275ce				   -skipamigabitsfix1
   9153  275ce				   -	       sta	mousetableselect
   9154  275ce				   -	       ifconst	DRIVINGBOOST
   9155  275ce				   -	       cpy	#6	; DRIVING?
   9156  275ce				   -	       bne	skipdriving1setup
   9157  275ce				   -			; swap mousex1 and mousey1. mousex seen by the 7800basic program
   9158  275ce				   -			; trails the actual mousex1, so we can smoothly interpolate toward
   9159  275ce				   -			; the actual position. This actual position is stored in mousey1 
   9160  275ce				   -			; after the driver has run.
   9161  275ce				   -	       ldx	mousex1
   9162  275ce				   -	       lda	mousey1
   9163  275ce				   -	       stx	mousey1
   9164  275ce				   -	       sta	mousex1
   9165  275ce				   -skipdriving1setup
   9166  275ce				   -	       endif		; DRIVINGBOOST
   9167  275ce				   -
   9168  275ce				   -	       lda	#0
   9169  275ce				   -	       sta	mousexdelta
   9170  275ce				   -	       sta	mouseydelta
   9171  275ce				   -
   9172  275ce				   -	       ifnconst	MOUSETIME
   9173  275ce				   -	       ifnconst	MOUSEXONLY
   9174  275ce				   -	       lda	#180	; minimum for x+y
   9175  275ce				   -	       else
   9176  275ce				   -	       lda	#100	; minimum for just x
   9177  275ce				   -	       endif
   9178  275ce				   -	       else
   9179  275ce				   -	       lda	#MOUSETIME
   9180  275ce				   -	       endif
   9181  275ce				   -	       jsr	SETTIM64T	; INTIM is in Y
   9182  275ce				   -
   9183  275ce				   -mouse1updateloop
   9184  275ce				   -	       lda	SWCHA
   9185  275ce				   -	       and	#%00001111
   9186  275ce				   -	       cmp	lastSWCHA
   9187  275ce				   -	       beq	mouse1loopcondition
   9188  275ce				   -	       sta	lastSWCHA
   9189  275ce				   -
   9190  275ce				   -	       ora	mousetableselect	; atari/amiga decoding table selection
   9191  275ce				   -
   9192  275ce				   -			; st mice encode on different bits/joystick-lines than amiga mice...
   9193  275ce				   -			;  0000YyXx st mouse
   9194  275ce				   -			;  0000xyXY amiga mouse
   9195  275ce				   -			; ...so can shuffle the amiga bits to reuse the st driver.
   9196  275ce				   -	       tay
   9197  275ce				   -	       lax	amigatoataribits,y
   9198  275ce				   -
   9199  275ce				   -	       ifnconst	MOUSEXONLY
   9200  275ce				   -			; first the Y...
   9201  275ce				   -	       and	#%00001100
   9202  275ce				   -	       ora	mousecodey1
   9203  275ce				   -	       tay
   9204  275ce				   -	       lda	rotationalcompare,y
   9205  275ce				   -	       clc
   9206  275ce				   -	       adc	mouseydelta
   9207  275ce				   -	       sta	mouseydelta
   9208  275ce				   -	       tya
   9209  275ce				   -	       lsr
   9210  275ce				   -	       lsr
   9211  275ce				   -	       sta	mousecodey1
   9212  275ce				   -	       txa
   9213  275ce				   -			; ...then the X...
   9214  275ce				   -	       and	#%00000011
   9215  275ce				   -	       tax
   9216  275ce				   -	       endif		; !MOUSEXONLY
   9217  275ce				   -
   9218  275ce				   -	       asl
   9219  275ce				   -	       asl
   9220  275ce				   -	       ora	mousecodex1
   9221  275ce				   -	       tay
   9222  275ce				   -	       lda	rotationalcompare,y
   9223  275ce				   -	       adc	mousexdelta	; carry was clear by previous ASL
   9224  275ce				   -	       sta	mousexdelta
   9225  275ce				   -	       stx	mousecodex1
   9226  275ce				   -mouse1loopcondition
   9227  275ce				   -	       lda	TIMINT
   9228  275ce				   -	       bpl	mouse1updateloop
   9229  275ce				   -
   9230  275ce				   -			; *** adapt to selected device resolution. 
   9231  275ce				   -	       ldx	port1control
   9232  275ce				   -
   9233  275ce				   -	       ifconst	PRECISIONMOUSING
   9234  275ce				   -	       ldy	port1resolution
   9235  275ce				   -	       bne	mouse1halveddone
   9236  275ce				   -	       cpx	#6	; half-resolution is no good for driving wheels
   9237  275ce				   -	       beq	mouse1halveddone
   9238  275ce				   -			; resolution=0 is half mouse resolution, necessary for precision 
   9239  275ce				   -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   9240  275ce				   -
   9241  275ce				   -	       lda	mousexdelta
   9242  275ce				   -	       cmp	#$80
   9243  275ce				   -	       ror		; do a signed divide by 2.
   9244  275ce				   -	       clc
   9245  275ce				   -	       adc	mousex1
   9246  275ce				   -	       sta	mousex1
   9247  275ce				   -	       ifnconst	MOUSEXONLY
   9248  275ce				   -	       lda	mouseydelta
   9249  275ce				   -	       clc
   9250  275ce				   -	       adc	mousey1
   9251  275ce				   -	       sta	mousey1
   9252  275ce				   -	       endif
   9253  275ce				   -			; at half resolution we just exit after updating x and y
   9254  275ce				   -	       jmp	LLRET1
   9255  275ce				   -mouse1halveddone
   9256  275ce				   -	       endif		; PRECISIONMOUSING
   9257  275ce				   -
   9258  275ce				   -	       ifnconst	MOUSEXONLY
   9259  275ce				   -	       asl	mouseydelta	; *2 because Y resolution is finer
   9260  275ce				   -	       ldy	port1resolution
   9261  275ce				   -	       dey
   9262  275ce				   -	       lda	#0
   9263  275ce				   -mousey1resolutionfix
   9264  275ce				   -	       clc
   9265  275ce				   -	       adc	mouseydelta
   9266  275ce				   -	       dey
   9267  275ce				   -	       bpl	mousey1resolutionfix
   9268  275ce				   -	       clc
   9269  275ce				   -	       adc	mousey1
   9270  275ce				   -	       sta	mousey1
   9271  275ce				   -	       endif		; MOUSEXONLY
   9272  275ce				   -
   9273  275ce				   -	       ldy	port1resolution
   9274  275ce				   -	       dey
   9275  275ce				   -	       lda	#0
   9276  275ce				   -mousex1resolutionfix
   9277  275ce				   -	       clc
   9278  275ce				   -	       adc	mousexdelta
   9279  275ce				   -	       dey
   9280  275ce				   -	       bpl	mousex1resolutionfix
   9281  275ce				   -	       ifnconst	DRIVINGBOOST
   9282  275ce				   -	       clc
   9283  275ce				   -	       adc	mousex1
   9284  275ce				   -	       sta	mousex1
   9285  275ce				   -	       else
   9286  275ce				   -	       cpx	#6
   9287  275ce				   -	       beq	carryonmouse1boost
   9288  275ce				   -	       clc
   9289  275ce				   -	       adc	mousex1
   9290  275ce				   -	       sta	mousex1
   9291  275ce				   -	       jmp	LLRET1
   9292  275ce				   -carryonmouse1boost
   9293  275ce				   -	       sta	mousexdelta
   9294  275ce				   -	       clc
   9295  275ce				   -	       adc	mousecodey1
   9296  275ce				   -	       sta	mousecodey1
   9297  275ce				   -	       clc
   9298  275ce				   -	       adc	mousex1
   9299  275ce				   -	       tay		; save the target X
   9300  275ce				   -	       adc	mousey1	; average in the smoothly-trailing X
   9301  275ce				   -	       ror
   9302  275ce				   -	       sta	mousex1	; mousex0 now has the smoothly trailing X
   9303  275ce				   -	       sty	mousey1	; and mousey0 has the the target X
   9304  275ce				   -
   9305  275ce				   -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   9306  275ce				   -			; A has mousex1, the smoothly trailing X
   9307  275ce				   -	       sbc	mousey1	; less the target X
   9308  275ce				   -	       bpl	skipabsolutedrive1
   9309  275ce				   -	       eor	#$ff
   9310  275ce				   -skipabsolutedrive1
   9311  275ce				   -	       cmp	#64	; just an unreasonably large change
   9312  275ce				   -	       bcc	skipdrivewrapfix1
   9313  275ce				   -	       sty	mousex1	; if X wrapped, we catch the trailing X up to the target X
   9314  275ce				   -skipdrivewrapfix1
   9315  275ce				   -
   9316  275ce				   -			; get rid of the tweening if the distance travelled was very small
   9317  275ce				   -	       lda	mousexdelta
   9318  275ce				   -	       cmp	port1resolution
   9319  275ce				   -	       bcs	skipbetweenfix1
   9320  275ce				   -	       lda	mousex1
   9321  275ce				   -	       sta	mousey1
   9322  275ce				   -skipbetweenfix1
   9323  275ce				   -
   9324  275ce				   -drivingboostreductioncheck1
   9325  275ce				   -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   9326  275ce				   -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   9327  275ce				   -			; negated again because truncation during BCD math results in 
   9328  275ce				   -			; differing magnitudes, depending if the value is  +ve or -ve.
   9329  275ce				   -driving1fix
   9330  275ce				   -	       lax	mousecodey1
   9331  275ce				   -	       cmp	#$80
   9332  275ce				   -	       bcs	driving0skipnegate1
   9333  275ce				   -	       eor	#$FF
   9334  275ce				   -	       adc	#1
   9335  275ce				   -	       sta	mousecodey1
   9336  275ce				   -driving0skipnegate1
   9337  275ce				   -	       cmp	#$80
   9338  275ce				   -	       ror
   9339  275ce				   -	       cmp	#$80
   9340  275ce				   -	       ror
   9341  275ce				   -	       cmp	#$80
   9342  275ce				   -	       ror
   9343  275ce				   -	       sta	inttemp1
   9344  275ce				   -	       lda	mousecodey1
   9345  275ce				   -	       sec
   9346  275ce				   -	       sbc	inttemp1
   9347  275ce				   -	       cpx	#$80
   9348  275ce				   -	       bcs	driving1skipnegate2
   9349  275ce				   -	       eor	#$FF
   9350  275ce				   -	       adc	#1
   9351  275ce				   -driving1skipnegate2
   9352  275ce				   -	       sta	mousecodey1
   9353  275ce				   -drivingboostdone1
   9354  275ce				   -	       endif		; DRIVINGBOOST
   9355  275ce				   -
   9356  275ce				   -	       jmp	LLRET1
   9357  275ce				   -
   9358  275ce					       endif		; MOUSE1SUPPORT
   9359  275ce
   9360  275ce
   9361  275ce				    trakball0update
   9362  275ce				   -	       ifconst	TRAKBALL0SUPPORT
   9363  275ce				   -	       ifnconst	TRAKTIME
   9364  275ce				   -	       ifnconst	TRAKXONLY
   9365  275ce				   -	       lda	#180	; minimum for x+y
   9366  275ce				   -	       else		;  !TRAKXONLY
   9367  275ce				   -	       lda	#100	; minimum for just x
   9368  275ce				   -	       endif		; !TRAKXONLY
   9369  275ce				   -	       else		; !TRAKTIME
   9370  275ce				   -	       lda	#TRAKTIME
   9371  275ce				   -	       endif		; !TRAKTIME
   9372  275ce				   -	       jsr	SETTIM64T	; INTIM is in Y
   9373  275ce				   -	       ldx	#0
   9374  275ce				   -	       ifnconst	TRAKXONLY
   9375  275ce				   -	       ldy	#0
   9376  275ce				   -	       endif		;  TRAKXONLY
   9377  275ce				   -trakball0updateloop
   9378  275ce				   -	       lda	SWCHA
   9379  275ce				   -	       and	#%00110000
   9380  275ce				   -	       cmp	trakballcodex0
   9381  275ce				   -	       sta	trakballcodex0
   9382  275ce				   -	       beq	trakball0movementXdone
   9383  275ce				   -	       and	#%00010000
   9384  275ce				   -	       beq	trakball0negativeX
   9385  275ce				   -trakball0positiveX
   9386  275ce				   -			;(2 from beq)
   9387  275ce				   -	       inx		; 2
   9388  275ce				   -	       jmp	trakball0movementXdone	; 3
   9389  275ce				   -trakball0negativeX
   9390  275ce				   -			;(3 from beq)
   9391  275ce				   -	       dex		; 2
   9392  275ce				   -	       nop		; 2
   9393  275ce				   -trakball0movementXdone
   9394  275ce				   -
   9395  275ce				   -	       ifnconst	TRAKXONLY
   9396  275ce				   -	       lda	SWCHA
   9397  275ce				   -	       and	#%11000000
   9398  275ce				   -	       cmp	trakballcodey0
   9399  275ce				   -	       sta	trakballcodey0
   9400  275ce				   -	       beq	trakball0movementYdone
   9401  275ce				   -	       and	#%01000000
   9402  275ce				   -	       beq	trakball0negativeY
   9403  275ce				   -trakball0positiveY
   9404  275ce				   -			;(2 from beq)
   9405  275ce				   -	       iny		; 2
   9406  275ce				   -	       jmp	trakball0movementYdone	; 3
   9407  275ce				   -trakball0negativeY
   9408  275ce				   -			;(3 from beq)
   9409  275ce				   -	       dey		; 2
   9410  275ce				   -	       nop		; 2
   9411  275ce				   -trakball0movementYdone
   9412  275ce				   -	       endif		; !TRAKXONLY
   9413  275ce				   -
   9414  275ce				   -	       lda	TIMINT
   9415  275ce				   -	       bpl	trakball0updateloop
   9416  275ce				   -	       lda	#0
   9417  275ce				   -	       cpx	#0
   9418  275ce				   -	       beq	trakball0skipXadjust
   9419  275ce				   -	       clc
   9420  275ce				   -trakball0Xloop
   9421  275ce				   -	       adc	port0resolution
   9422  275ce				   -	       dex
   9423  275ce				   -	       bne	trakball0Xloop
   9424  275ce				   -	       clc
   9425  275ce				   -	       adc	trakballx0
   9426  275ce				   -	       sta	trakballx0
   9427  275ce				   -trakball0skipXadjust
   9428  275ce				   -	       ifnconst	TRAKXONLY
   9429  275ce				   -	       lda	#0
   9430  275ce				   -	       cpy	#0
   9431  275ce				   -	       beq	trakball0skipYadjust
   9432  275ce				   -	       clc
   9433  275ce				   -trakball0yloop
   9434  275ce				   -	       adc	port0resolution
   9435  275ce				   -	       dey
   9436  275ce				   -	       bne	trakball0yloop
   9437  275ce				   -	       clc
   9438  275ce				   -	       adc	trakbally0
   9439  275ce				   -	       sta	trakbally0
   9440  275ce				   -trakball0skipYadjust
   9441  275ce				   -	       endif		; !TRAKXONLY
   9442  275ce				   -
   9443  275ce				   -	       jmp	LLRET0
   9444  275ce					       endif
   9445  275ce
   9446  275ce
   9447  275ce
   9448  275ce				    trakball1update
   9449  275ce				   -	       ifconst	TRAKBALL1SUPPORT
   9450  275ce				   -	       ifnconst	TRAKTIME
   9451  275ce				   -	       ifnconst	TRAKXONLY
   9452  275ce				   -	       lda	#180	; minimum for x+y
   9453  275ce				   -	       else		;  !TRAKXONLY
   9454  275ce				   -	       lda	#100	; minimum for just x
   9455  275ce				   -	       endif		; !TRAKXONLY
   9456  275ce				   -	       else		; !TRAKTIME
   9457  275ce				   -	       lda	#TRAKTIME
   9458  275ce				   -	       endif		; !TRAKTIME
   9459  275ce				   -	       jsr	SETTIM64T	; INTIM is in Y
   9460  275ce				   -	       ldx	#0
   9461  275ce				   -	       ifnconst	TRAKXONLY
   9462  275ce				   -	       ldy	#0
   9463  275ce				   -	       endif		;  TRAKXONLY
   9464  275ce				   -trakball1updateloop
   9465  275ce				   -	       lda	SWCHA
   9466  275ce				   -	       and	#%00000011
   9467  275ce				   -	       cmp	trakballcodex1
   9468  275ce				   -	       sta	trakballcodex1
   9469  275ce				   -	       beq	trakball1movementXdone
   9470  275ce				   -	       and	#%00000001
   9471  275ce				   -	       beq	trakball1negativeX
   9472  275ce				   -trakball1positiveX
   9473  275ce				   -			;(2 from beq)
   9474  275ce				   -	       inx		; 2
   9475  275ce				   -	       jmp	trakball1movementXdone	; 3
   9476  275ce				   -trakball1negativeX
   9477  275ce				   -			;(3 from beq)
   9478  275ce				   -	       dex		; 2
   9479  275ce				   -	       nop		; 2
   9480  275ce				   -trakball1movementXdone
   9481  275ce				   -
   9482  275ce				   -	       ifnconst	TRAKXONLY
   9483  275ce				   -	       lda	SWCHA
   9484  275ce				   -	       and	#%00001100
   9485  275ce				   -	       cmp	trakballcodey1
   9486  275ce				   -	       sta	trakballcodey1
   9487  275ce				   -	       beq	trakball1movementYdone
   9488  275ce				   -	       and	#%00000100
   9489  275ce				   -	       beq	trakball1negativeY
   9490  275ce				   -trakball1positiveY
   9491  275ce				   -			;(2 from beq)
   9492  275ce				   -	       iny		; 2
   9493  275ce				   -	       jmp	trakball1movementYdone	; 3
   9494  275ce				   -trakball1negativeY
   9495  275ce				   -			;(3 from beq)
   9496  275ce				   -	       dey		; 2
   9497  275ce				   -	       nop		; 2
   9498  275ce				   -trakball1movementYdone
   9499  275ce				   -	       endif		; !TRAKXONLY
   9500  275ce				   -
   9501  275ce				   -	       lda	TIMINT
   9502  275ce				   -	       bpl	trakball1updateloop
   9503  275ce				   -	       lda	#0
   9504  275ce				   -	       cpx	#0
   9505  275ce				   -	       beq	trakball1skipXadjust
   9506  275ce				   -	       clc
   9507  275ce				   -trakball1Xloop
   9508  275ce				   -	       adc	port1resolution
   9509  275ce				   -	       dex
   9510  275ce				   -	       bne	trakball1Xloop
   9511  275ce				   -	       clc
   9512  275ce				   -	       adc	trakballx1
   9513  275ce				   -	       sta	trakballx1
   9514  275ce				   -trakball1skipXadjust
   9515  275ce				   -	       ifnconst	TRAKXONLY
   9516  275ce				   -	       lda	#0
   9517  275ce				   -	       cpy	#0
   9518  275ce				   -	       beq	trakball1skipYadjust
   9519  275ce				   -	       clc
   9520  275ce				   -trakball1yloop
   9521  275ce				   -	       adc	port1resolution
   9522  275ce				   -	       dey
   9523  275ce				   -	       bne	trakball1yloop
   9524  275ce				   -	       clc
   9525  275ce				   -	       adc	trakbally1
   9526  275ce				   -	       sta	trakbally1
   9527  275ce				   -trakball1skipYadjust
   9528  275ce				   -	       endif		; !TRAKXONLY
   9529  275ce				   -
   9530  275ce				   -	       jmp	LLRET1
   9531  275ce					       endif
   9532  275ce
   9533  275ce
   9534  275ce				    paddleport0update
   9535  275ce				   -	       ifconst	PADDLE0SUPPORT
   9536  275ce				   -	       lda	#6
   9537  275ce				   -	       sta	VBLANK	; start charging the paddle caps
   9538  275ce				   -	       lda	#0	; use PADDLE timing
   9539  275ce				   -	       jsr	SETTIM64T	; INTIM is in Y
   9540  275ce				   -
   9541  275ce				   -paddleport0updateloop
   9542  275ce				   -	       lda	INPT0
   9543  275ce				   -	       bmi	skippaddle0setposition
   9544  275ce				   -	       sty	paddleposition0
   9545  275ce				   -skippaddle0setposition
   9546  275ce				   -	       ifconst	TWOPADDLESUPPORT
   9547  275ce				   -	       lda	INPT1
   9548  275ce				   -	       bmi	skippaddle1setposition
   9549  275ce				   -	       sty	paddleposition1
   9550  275ce				   -skippaddle1setposition
   9551  275ce				   -	       endif
   9552  275ce				   -	       ldy	INTIM
   9553  275ce				   -	       cpy	#TIMEOFFSET
   9554  275ce				   -	       bcs	paddleport0updateloop
   9555  275ce				   -
   9556  275ce				   -	       lda	#%10000110
   9557  275ce				   -	       sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   9558  275ce				   -	       sec
   9559  275ce				   -	       lda	paddleposition0
   9560  275ce				   -	       sbc	#TIMEOFFSET
   9561  275ce				   -	       ifconst	PADDLESCALEX2
   9562  275ce				   -	       asl
   9563  275ce				   -	       endif
   9564  275ce				   -
   9565  275ce				   -	       ifnconst	PADDLESMOOTHINGOFF
   9566  275ce				   -	       clc
   9567  275ce				   -	       adc	paddleprevious0
   9568  275ce				   -	       ror
   9569  275ce				   -	       sta	paddleprevious0
   9570  275ce				   -	       endif
   9571  275ce				   -
   9572  275ce				   -	       sta	paddleposition0
   9573  275ce				   -
   9574  275ce				   -	       ifconst	TWOPADDLESUPPORT
   9575  275ce				   -	       sec
   9576  275ce				   -	       lda	paddleposition1
   9577  275ce				   -	       sbc	#TIMEOFFSET
   9578  275ce				   -	       ifconst	PADDLESCALEX2
   9579  275ce				   -	       asl
   9580  275ce				   -	       endif
   9581  275ce				   -
   9582  275ce				   -	       ifnconst	PADDLESMOOTHINGOFF
   9583  275ce				   -	       clc
   9584  275ce				   -	       adc	paddleprevious1
   9585  275ce				   -	       ror
   9586  275ce				   -	       sta	paddleprevious1
   9587  275ce				   -	       endif
   9588  275ce				   -	       sta	paddleposition1
   9589  275ce				   -	       endif		; TWOPADDLESUPPORT
   9590  275ce				   -
   9591  275ce				   -	       jmp	LLRET0
   9592  275ce					       endif
   9593  275ce
   9594  275ce				    paddleport1update
   9595  275ce				   -	       ifconst	PADDLE1SUPPORT
   9596  275ce				   -	       lda	#6
   9597  275ce				   -	       sta	VBLANK	; start charging the paddle caps
   9598  275ce				   -
   9599  275ce				   -	       lda	#0	; use PADDLE timing
   9600  275ce				   -	       jsr	SETTIM64T	; INTIM is in Y
   9601  275ce				   -
   9602  275ce				   -paddleport1updateloop
   9603  275ce				   -	       lda	INPT2
   9604  275ce				   -	       bmi	skippaddle2setposition
   9605  275ce				   -	       sty	paddleposition2
   9606  275ce				   -skippaddle2setposition
   9607  275ce				   -	       ifconst	TWOPADDLESUPPORT
   9608  275ce				   -	       lda	INPT3
   9609  275ce				   -	       bmi	skippaddle3setposition
   9610  275ce				   -	       sty	paddleposition3
   9611  275ce				   -skippaddle3setposition
   9612  275ce				   -	       endif
   9613  275ce				   -	       ldy	INTIM
   9614  275ce				   -	       cpy	#TIMEOFFSET
   9615  275ce				   -	       bcs	paddleport1updateloop
   9616  275ce				   -
   9617  275ce				   -	       lda	#%10000110
   9618  275ce				   -	       sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   9619  275ce				   -	       sec
   9620  275ce				   -	       lda	paddleposition2
   9621  275ce				   -	       sbc	#TIMEOFFSET
   9622  275ce				   -	       ifconst	PADDLESCALEX2
   9623  275ce				   -	       asl
   9624  275ce				   -	       endif
   9625  275ce				   -
   9626  275ce				   -	       ifnconst	PADDLESMOOTHINGOFF
   9627  275ce				   -	       clc
   9628  275ce				   -	       adc	paddleprevious2
   9629  275ce				   -	       ror
   9630  275ce				   -	       sta	paddleprevious2
   9631  275ce				   -	       endif
   9632  275ce				   -
   9633  275ce				   -	       sta	paddleposition2
   9634  275ce				   -
   9635  275ce				   -	       ifconst	TWOPADDLESUPPORT
   9636  275ce				   -	       sec
   9637  275ce				   -	       lda	paddleposition3
   9638  275ce				   -	       sbc	#TIMEOFFSET
   9639  275ce				   -	       ifconst	PADDLESCALEX2
   9640  275ce				   -	       asl
   9641  275ce				   -	       endif
   9642  275ce				   -
   9643  275ce				   -	       ifnconst	PADDLESMOOTHINGOFF
   9644  275ce				   -	       clc
   9645  275ce				   -	       adc	paddleprevious3
   9646  275ce				   -	       ror
   9647  275ce				   -	       sta	paddleprevious3
   9648  275ce				   -	       endif
   9649  275ce				   -	       sta	paddleposition3
   9650  275ce				   -	       endif		; TWOPADDLESUPPORT
   9651  275ce				   -
   9652  275ce				   -	       jmp	LLRET1
   9653  275ce					       endif
   9654  275ce
   9655  275ce
   9656  275ce				    paddlebuttonhandler 		; outside of conditional, for button-handler LUT
   9657  275ce				   -	       ifconst	PADDLESUPPORT
   9658  275ce				   -			; x=0|1 for port, rather than paddle #. 
   9659  275ce				   -			; Only the first paddle button will integrate into "joy0fire" testing. If the
   9660  275ce				   -			; game wants to support 2 paddles, up to the game to instead test the 
   9661  275ce				   -			; joystick right+left directions instead.
   9662  275ce				   -	       lda	SWCHA	; top of nibble is first paddle button
   9663  275ce				   -	       cpx	#0	; port 0?
   9664  275ce				   -	       beq	skippaddleport2shift
   9665  275ce				   -	       asl		; shift second port to upper nibble
   9666  275ce				   -	       asl
   9667  275ce				   -	       asl
   9668  275ce				   -	       asl
   9669  275ce				   -skippaddleport2shift
   9670  275ce				   -	       and	#%10000000
   9671  275ce				   -	       eor	#%10000000	; invert
   9672  275ce				   -	       sta	sINPT1,x
   9673  275ce				   -	       jmp	buttonreadloopreturn
   9674  275ce					       endif		; PADDLESUPPORT
   9675  275ce
   9676  275ce				    mousebuttonhandler		; outside of conditional, for button-handler LUT
   9677  275ce				   -	       ifconst	MOUSESUPPORT
   9678  275ce				   -			; stick the mouse buttons in the correct shadow register...
   9679  275ce				   -	       txa
   9680  275ce				   -	       asl
   9681  275ce				   -	       tay		; y=x*2
   9682  275ce				   -	       lda	INPT4,x
   9683  275ce				   -	       eor	#%10000000
   9684  275ce				   -	       lsr
   9685  275ce				   -	       sta	sINPT1,x
   9686  275ce				   -
   9687  275ce				   -	       lda	INPT1,y
   9688  275ce				   -	       and	#%10000000
   9689  275ce				   -	       eor	#%10000000
   9690  275ce				   -	       ora	sINPT1,x
   9691  275ce				   -	       sta	sINPT1,x
   9692  275ce				   -	       jmp	buttonreadloopreturn
   9693  275ce					       endif		; MOUSESUPPORT
   9694  275ce
   9695  275ce				   -	       ifconst	KEYPADSUPPORT
   9696  275ce				   -			; ** select keypad rows 0 to 3 over 4 frames...
   9697  275ce				   -keypadrowselect
   9698  275ce				   -	       ldy	#0
   9699  275ce				   -	       lda	port0control
   9700  275ce				   -	       cmp	#7
   9701  275ce				   -	       bne	skipport0val
   9702  275ce				   -	       iny		; y=y+1
   9703  275ce				   -skipport0val
   9704  275ce				   -	       lda	port1control
   9705  275ce				   -	       cmp	#7
   9706  275ce				   -	       bne	skipport1val
   9707  275ce				   -	       iny
   9708  275ce				   -	       iny		; y=y+2
   9709  275ce				   -skipport1val
   9710  275ce				   -	       lda	keyrowdirectionmask,y
   9711  275ce				   -	       sta	CTLSWA
   9712  275ce				   -	       tya
   9713  275ce				   -	       asl
   9714  275ce				   -	       asl
   9715  275ce				   -	       sta	inttemp1
   9716  275ce				   -	       lda	framecounter
   9717  275ce				   -	       and	#3
   9718  275ce				   -	       ora	inttemp1
   9719  275ce				   -	       tax
   9720  275ce				   -	       lda	keyrowselectvalue,x
   9721  275ce				   -	       sta	SWCHA
   9722  275ce				   -	       rts
   9723  275ce				   -
   9724  275ce				   -keyrowdirectionmask
   9725  275ce				   -	       .byte	#%00000000	; 0 : port0=input  port1=input
   9726  275ce				   -	       .byte	#%11110000	; 1 : port0=output port1=input
   9727  275ce				   -	       .byte	#%00001111	; 2 : port0=input  port1=output
   9728  275ce				   -	       .byte	#%11111111	; 3 : port0=output port1=output
   9729  275ce				   -
   9730  275ce				   -keyrowselectvalue
   9731  275ce				   -	       .byte	#%00000000, #%00000000, #%00000000, #%00000000	; no row selected, all pins high, always
   9732  275ce				   -	       .byte	#%11100000, #%11010000, #%10110000, #%01110000	; p0 keypad in
   9733  275ce				   -	       .byte	#%00001110, #%00001101, #%00001011, #%00000111	; p1 keypad in
   9734  275ce				   -	       .byte	#%11101110, #%11011101, #%10111011, #%01110111	; p0+p1 keypads in
   9735  275ce					       endif		;  KEYPADSUPPORT
   9736  275ce
   9737  275ce				   -	       ifconst	KEYPADSUPPORT
   9738  275ce				   -			; TODO - split into compile-time KEYPAD0SUPPORT and KEYPAD1SUPPORT
   9739  275ce				   -keypadcolumnread
   9740  275ce				   -	       lda	port0control
   9741  275ce				   -	       cmp	#7
   9742  275ce				   -	       bne	skipkeypadcolumnread0
   9743  275ce				   -	       lda	framecounter
   9744  275ce				   -	       and	#3
   9745  275ce				   -	       asl		; x2 because keypad variables are interleaved
   9746  275ce				   -	       tax
   9747  275ce				   -	       lda	#0
   9748  275ce				   -	       sta	keypadmatrix0a,x
   9749  275ce				   -	       lda	INPT0
   9750  275ce				   -	       cmp	#$80
   9751  275ce				   -	       rol	keypadmatrix0a,x
   9752  275ce				   -	       lda	INPT1
   9753  275ce				   -	       cmp	#$80
   9754  275ce				   -	       rol	keypadmatrix0a,x
   9755  275ce				   -	       lda	INPT4
   9756  275ce				   -	       cmp	#$80
   9757  275ce				   -	       rol	keypadmatrix0a,x
   9758  275ce				   -	       lda	keypadmatrix0a,x
   9759  275ce				   -	       eor	#%00000111
   9760  275ce				   -	       sta	keypadmatrix0a,x
   9761  275ce				   -skipkeypadcolumnread0
   9762  275ce				   -
   9763  275ce				   -	       lda	port1control
   9764  275ce				   -	       cmp	#7
   9765  275ce				   -	       bne	skipkeypadcolumnread1
   9766  275ce				   -	       lda	framecounter
   9767  275ce				   -	       and	#3
   9768  275ce				   -	       asl		; x2 because keypad variables are interleaved
   9769  275ce				   -	       tax
   9770  275ce				   -	       lda	#0
   9771  275ce				   -	       sta	keypadmatrix1a,x
   9772  275ce				   -	       rol	keypadmatrix1a,x
   9773  275ce				   -	       lda	INPT2
   9774  275ce				   -	       cmp	#$80
   9775  275ce				   -	       rol	keypadmatrix1a,x
   9776  275ce				   -	       lda	INPT3
   9777  275ce				   -	       cmp	#$80
   9778  275ce				   -	       rol	keypadmatrix1a,x
   9779  275ce				   -	       lda	INPT5
   9780  275ce				   -	       cmp	#$80
   9781  275ce				   -	       rol	keypadmatrix1a,x
   9782  275ce				   -	       lda	keypadmatrix1a,x
   9783  275ce				   -	       eor	#%00000111
   9784  275ce				   -	       sta	keypadmatrix1a,x
   9785  275ce				   -skipkeypadcolumnread1
   9786  275ce				   -	       rts
   9787  275ce					       endif		; KEYPADSUPPORT
   9788  275ce
   9789  275ce				    setportforinput
   9790  275ce			a5 e4		       lda	CTLSWAs
   9791  275d0			3d d9 f5	       and	allpinsinputlut,x
   9792  275d3			85 e4		       sta	CTLSWAs
   9793  275d5			8d 81 02	       sta	CTLSWA
   9794  275d8			60		       rts
   9795  275d9
   9796  275d9				    allpinsinputlut
   9797  275d9			0f f0		       .byte.b	$0F, $F0
   9798  275db
   9799  275db				    setonebuttonmode
   9800  275db			a9 06		       lda	#6	; in case we're in unlocked-bios mode
   9801  275dd			85 01		       sta	VBLANK	; if we were on paddles, the line is grounded out.
   9802  275df			a9 14		       lda	#$14
   9803  275e1			8d 83 02	       sta	CTLSWB	; set both 2-button disable bits to writable
   9804  275e4			a5 e5		       lda	CTLSWBs
   9805  275e6			1d ef f5	       ora	thisjoy2buttonbit,x
   9806  275e9			85 e5		       sta	CTLSWBs
   9807  275eb			8d 82 02	       sta	SWCHB	; turn off the 2-button disable bits
   9808  275ee			60		       rts
   9809  275ef
   9810  275ef				    thisjoy2buttonbit
   9811  275ef			04 10		       .byte.b	$04, $10
   9812  275f1
   9813  275f1				    settwobuttonmode
   9814  275f1			a9 06		       lda	#6	; in case we're in unlocked-bios mode
   9815  275f3			85 01		       sta	VBLANK	; if we were on paddles, the line is grounded out.
   9816  275f5			a9 14		       lda	#$14
   9817  275f7			8d 83 02	       sta	CTLSWB	; set both 2-button disable bits to writable
   9818  275fa			a5 e5		       lda	CTLSWBs
   9819  275fc			3d 05 f6	       and	thisjoy2buttonmask,x
   9820  275ff			85 e5		       sta	CTLSWBs
   9821  27601			8d 82 02	       sta	SWCHB
   9822  27604			60		       rts
   9823  27605
   9824  27605				    thisjoy2buttonmask
   9825  27605			fb ef		       .byte.b	$fb, $ef
   9826  27607
   9827  27607							; Provided under the CC0 license. See the included LICENSE.txt for details.
   9828  27607
   9829  27607				    START
   9830  27607				    start
   9831  27607
   9832  27607							;******** more or less the Atari recommended startup procedure
   9833  27607
   9834  27607			78		       sei
   9835  27608			d8		       cld
   9836  27609
   9837  27609					       ifnconst	NOTIALOCK
   9838  27609			a9 07		       lda	#$07
   9839  2760b				   -	       else
   9840  2760b				   -	       lda	#$06
   9841  2760b					       endif
   9842  2760b			85 01		       sta	INPTCTRL	;lock 7800 into 7800 mode
   9843  2760d			a9 7f		       lda	#$7F
   9844  2760f			85 3c		       sta	CTRL	;disable DMA
   9845  27611			a9 00		       lda	#$00
   9846  27613			85 38		       sta	OFFSET
   9847  27615					       ifnconst	NOTIALOCK
   9848  27615			85 01		       sta	INPTCTRL
   9849  27617			85 20		       sta	BACKGRND	; black default, in case a flash cart is using something else
   9850  27619					       endif
   9851  27619			a2 ff		       ldx	#$FF
   9852  2761b			9a		       txs
   9853  2761c
   9854  2761c							;************** Clear Memory
   9855  2761c
   9856  2761c							; ** Clear 1800-27FF, pg0+pg1 memory.
   9857  2761c				    ClearMemPages
   9858  2761c			a9 00		       lda	#0
   9859  2761e			a8		       tay		; y=0
   9860  2761f			85 80		       sta	$80
   9861  27621			a2 18		       ldx	#$18
   9862  27623				    ClearMemPagesLoop
   9863  27623			86 81		       stx	$81	; needed for when we step on ZP memory
   9864  27625			91 80		       sta	($80),y	;Store data
   9865  27627			c8		       iny		;Next byte
   9866  27628			d0 f9		       bne	ClearMemPagesLoop
   9867  2762a			e8		       inx
   9868  2762b			e0 28		       cpx	#$28
   9869  2762d			d0 f4		       bne	ClearMemPagesLoop
   9870  2762f			85 81		       sta	$81
   9871  27631
   9872  27631							;seed random number with hopefully-random timer value
   9873  27631			a9 01		       lda	#1
   9874  27633			0d 84 02	       ora	INTIM
   9875  27636			85 40		       sta	rand
   9876  27638
   9877  27638							; detect the console type...
   9878  27638				    pndetectvblankstart
   9879  27638			a5 28		       lda	MSTAT
   9880  2763a			10 fc		       bpl	pndetectvblankstart	; if we're not in VBLANK, wait for it to start 
   9881  2763c				    pndetectvblankover
   9882  2763c			a5 28		       lda	MSTAT
   9883  2763e			30 fc		       bmi	pndetectvblankover	;  then wait for it to be over
   9884  27640			a0 00		       ldy	#$00
   9885  27642			a2 00		       ldx	#$00
   9886  27644				    pndetectvblankhappening
   9887  27644			a5 28		       lda	MSTAT
   9888  27646			30 07		       bmi	pndetectinvblank	;  if VBLANK starts, exit our counting loop 
   9889  27648			85 24		       sta	WSYNC
   9890  2764a			85 24		       sta	WSYNC
   9891  2764c			e8		       inx
   9892  2764d			d0 f5		       bne	pndetectvblankhappening
   9893  2764f				    pndetectinvblank
   9894  2764f			e0 7d		       cpx	#125
   9895  27651			90 02		       bcc	pndetecispal
   9896  27653			a0 01		       ldy	#$01
   9897  27655				    pndetecispal
   9898  27655			8c 09 21	       sty	paldetected
   9899  27658
   9900  27658			20 87 f4	       jsr	createallgamedlls
   9901  2765b
   9902  2765b			a9 18		       lda	#>DLLMEM
   9903  2765d			85 2c		       sta	DPPH
   9904  2765f			a9 00		       lda	#<DLLMEM
   9905  27661			85 30		       sta	DPPL
   9906  27663
   9907  27663				   -	       ifconst	pokeysupport
   9908  27663				   -			; pokey support is compiled in, so try to detect it...
   9909  27663				   -	       jsr	detectpokeylocation
   9910  27663					       endif
   9911  27663
   9912  27663			a9 01		       lda	#1	; default for port 0 and 1 is a regular joystick
   9913  27665			8d b9 01	       sta	port0control
   9914  27668			8d ba 01	       sta	port1control
   9915  2766b
   9916  2766b							;Setup port A to read mode
   9917  2766b							;lda #$00
   9918  2766b							;sta SWCHA
   9919  2766b							;sta CTLSWA
   9920  2766b
   9921  2766b				   -	       ifconst	HSSUPPORT
   9922  2766b				   -	       ifconst	bankswitchmode
   9923  2766b				   -	       ifconst	included.hiscore.asm.bank
   9924  2766b				   -	       ifconst	MCPDEVCART
   9925  2766b				   -	       lda	#($18 | included.hiscore.asm.bank)
   9926  2766b				   -	       ifconst	dumpbankswitch
   9927  2766b				   -	       sta	dumpbankswitch
   9928  2766b				   -	       endif
   9929  2766b				   -	       sta	$3000
   9930  2766b				   -	       else
   9931  2766b				   -	       lda	#(included.hiscore.asm.bank)
   9932  2766b				   -	       ifconst	dumpbankswitch
   9933  2766b				   -	       sta	dumpbankswitch
   9934  2766b				   -	       endif
   9935  2766b				   -	       sta	$8000
   9936  2766b				   -	       endif
   9937  2766b				   -	       endif		; included.hiscore.asm.bank
   9938  2766b				   -	       endif		; bankswitchmode
   9939  2766b				   -			; try to detect HSC
   9940  2766b				   -	       jsr	detecthsc
   9941  2766b				   -	       and	#1
   9942  2766b				   -	       sta	hsdevice
   9943  2766b				   -skipHSCdetect
   9944  2766b				   -			; try to detect AtariVox eeprom
   9945  2766b				   -	       jsr	detectatarivoxeeprom
   9946  2766b				   -	       and	#2
   9947  2766b				   -	       ora	hsdevice
   9948  2766b				   -	       cmp	#3
   9949  2766b				   -	       bne	storeAinhsdevice
   9950  2766b				   -			; For now, we tie break by giving HSC priority over AtariVox.
   9951  2766b				   -			; Later we should check each device's priority byte if set, instead, 
   9952  2766b				   -	       lda	#2
   9953  2766b				   -storeAinhsdevice
   9954  2766b				   -	       sta	hsdevice
   9955  2766b				   -	       lda	#$ff
   9956  2766b				   -	       sta	hsdifficulty
   9957  2766b				   -	       sta	hsgameslot
   9958  2766b				   -	       sta	hsnewscoreline
   9959  2766b					       endif		; HSSUPPORT
   9960  2766b
   9961  2766b				   -	       ifconst	AVOXVOICE
   9962  2766b				   -	       jsr	silenceavoxvoice
   9963  2766b					       endif
   9964  2766b
   9965  2766b				   -	       ifconst	RMT
   9966  2766b				   -	       ifconst	RMTVOLUME
   9967  2766b				   -	       lda	#$F0	; default to full RMT volume
   9968  2766b				   -	       sta	rmtvolume
   9969  2766b				   -	       ifconst	TIAVOLUME
   9970  2766b				   -	       sta	tiavolume
   9971  2766b				   -	       endif		; TIAVOLUME
   9972  2766b				   -	       endif		; RMTVOLUME
   9973  2766b					       else		; !RMT
   9974  2766b				   -	       ifconst	TIAVOLUME
   9975  2766b				   -	       lda	#$F0	; default to full TIA volume
   9976  2766b				   -	       sta	tiavolume
   9977  2766b					       endif		; TIAVOLUME
   9978  2766b					       endif		; RMT
   9979  2766b
   9980  2766b					       ifconst	bankswitchmode
   9981  2766b							; we need to switch to the first bank as a default. this needs to
   9982  2766b							; happen before DMA, in case there's a topscreenroutine in bank 0
   9983  2766b				   -	       ifconst	MCPDEVCART
   9984  2766b				   -	       lda	#$18	; xxx11nnn - switch to bank 0
   9985  2766b				   -	       ifconst	dumpbankswitch
   9986  2766b				   -	       sta	dumpbankswitch
   9987  2766b				   -	       endif
   9988  2766b				   -	       sta	$3000
   9989  2766b					       else
   9990  2766b			a9 00		       lda	#0
   9991  2766d				   -	       ifconst	dumpbankswitch
   9992  2766d				   -	       sta	dumpbankswitch
   9993  2766d					       endif
   9994  2766d			8d 00 80	       sta	$8000
   9995  27670					       endif
   9996  27670					       endif
   9997  27670
   9998  27670							; CTRL 76543210
   9999  27670							; 7 colorburst kill
  10000  27670							; 6,5 dma ctrl 2=normal DMA, 3=no DMA
  10001  27670							; 4 character width 1=2 byte chars, 0=1 byte chars
  10002  27670							; 3 border control 0=background color border, 1=black border
  10003  27670							; 2 kangaroo mode 0=transparency, 1=kangaroo
  10004  27670							; 1,0 read mode 0=160x2/160x4 1=N/A 2=320B/320D 3=320A/320C
  10005  27670
  10006  27670					       ifconst	DOUBLEWIDE
  10007  27670			a9 50		       lda	#%01010000	;Enable DMA, mode=160x2/160x4, 2x character width
  10008  27672				   -	       else
  10009  27672				   -	       lda	#%01000000	;Enable DMA, mode=160x2/160x4
  10010  27672					       endif
  10011  27672
  10012  27672			20 3b f5	       jsr	waitforvblankstart	; give the some vblank time to minimally update the display
  10013  27675
  10014  27675			85 3c		       sta	CTRL
  10015  27677			8d 07 21	       sta	sCTRL
  10016  2767a
  10017  2767a			20 7a f4	       jsr	vblankresync
  10018  2767d
  10019  2767d			a2 01		       ldx	#1
  10020  2767f			20 f1 f5	       jsr	settwobuttonmode
  10021  27682			a2 00		       ldx	#0
  10022  27684			20 f1 f5	       jsr	settwobuttonmode
  10023  27687
  10024  27687					       ifnconst	.altgamestart
  10025  27687			4c 00 80	       jmp	game
  10026  2768a				   -	       else
  10027  2768a				   -	       jmp	.altgamestart
  10028  2768a					       endif
  10029  2768a
  10030  2768a							; Provided under the CC0 license. See the included LICENSE.txt for details.
  10031  2768a
  10032  2768a							;************** Setup DLL entries
  10033  2768a
  10034  2768a							; setup some working definitions, to avoid ifnconst mess elsewhere...
  10035  2768a				   -	       ifnconst	SCREENHEIGHT
  10036  2768a				   -WSCREENHEIGHT =	192
  10037  2768a					       else
  10038  2768a			00 e0	    WSCREENHEIGHT =	SCREENHEIGHT
  10039  2768a					       endif
  10040  2768a
  10041  2768a				   -	       ifnconst	ZONEHEIGHT
  10042  2768a				   -WZONEHEIGHT =	16
  10043  2768a					       else
  10044  2768a			00 10	    WZONEHEIGHT =	ZONEHEIGHT
  10045  2768a					       endif
  10046  2768a
  10047  2768a					       ifnconst	ZONECOUNT
  10048  2768a			00 0e	    WZONECOUNT =	(WSCREENHEIGHT/WZONEHEIGHT)
  10049  2768a				   -	       else
  10050  2768a				   -WZONECOUNT =	ZONECOUNT
  10051  2768a					       endif
  10052  2768a
  10053  2768a							; top of the frame, non-visible lines. this is based on NTSC,
  10054  2768a							; but we add in extra NV lines at the end of the display to ensure
  10055  2768a							; our PAL friends can play the game without it crashing.
  10056  2768a			00 09	    NVLINES    =	((243-WSCREENHEIGHT)/2)
  10057  2768a
  10058  2768a				   -	       ifnconst	DLMEMSTART
  10059  2768a				   -	       ifnconst	DOUBLEBUFFER
  10060  2768a				   -WDLMEMSTART =	$1880
  10061  2768a				   -	       else
  10062  2768a				   -WDLMEMSTART =	$18E0
  10063  2768a				   -	       endif		; DOUBLEBUFFER
  10064  2768a					       else
  10065  2768a			22 00	    WDLMEMSTART =	DLMEMSTART
  10066  2768a					       endif
  10067  2768a
  10068  2768a				   -	       ifnconst	DLMEMEND
  10069  2768a				   -	       ifconst	EXTRADLMEMORY
  10070  2768a				   -WDLMEMEND  =	$23FF
  10071  2768a				   -	       else
  10072  2768a				   -WDLMEMEND  =	$1FFF
  10073  2768a				   -	       endif
  10074  2768a					       else
  10075  2768a			27 ff	    WDLMEMEND  =	DLMEMEND
  10076  2768a					       endif
  10077  2768a
  10078  2768a
  10079  2768a			06 00	    WMEMSIZE   =	(WDLMEMEND-WDLMEMSTART+1)
  10080  2768a
  10081  2768a				   -	       ifnconst	DOUBLEBUFFER
  10082  2768a				   -DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-2)/5)*5)	; -2 to always ensure we have 1x double-byte terminator
  10083  2768a					       else
  10084  2768a			00 32	    DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-4)/10)*5)	; -4 to always ensure we have 2x double-byte terminators
  10085  2768a					       endif
  10086  2768a
  10087  2768a			00 34	    TDOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)	; offset between DL buffers. ie. half the real DL
  10088  2768a				   -	       if	TDOUBLEBUFFEROFFSET > 255
  10089  2768a				   -DOUBLEBUFFEROFFSET =	255
  10090  2768a					       else
  10091  2768a			00 34	    DOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)
  10092  2768a					       endif
  10093  2768a
  10094  2768a				   -	       ifconst	EXTRADLMEMORY
  10095  2768a				   -SECONDDLHALFSTART SET	$2300
  10096  2768a					       endif
  10097  2768a
  10098  2768a				    DLPOINTH
  10099  2768a				    DLINDEX    SET	0
  10100  2768a					       REPEAT	WZONECOUNT
  10101  2768a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10102  2768a				   -	       ifconst	EXTRADLMEMORY
  10103  2768a				   -	       if	TMPMEMADDRESS > $1FFF
  10104  2768a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10105  2768a				   -	       else
  10106  2768a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10107  2768a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10108  2768a				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
  10109  2768a				   -	       endif
  10110  2768a				   -	       endif		; TMPMEMADDRESS > $1FFF
  10111  2768a					       endif		; EXTRADLMEMORY
  10112  2768a							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
  10113  2768a			22		       .byte.b	>TMPMEMADDRESS
  10114  2768a				    DLINDEX    SET	DLINDEX + 1
  10100  2768a					       REPEND
  10101  2768a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10102  2768b				   -	       ifconst	EXTRADLMEMORY
  10103  2768b				   -	       if	TMPMEMADDRESS > $1FFF
  10104  2768b				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10105  2768b				   -	       else
  10106  2768b				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10107  2768b				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10108  2768b				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
  10109  2768b				   -	       endif
  10110  2768b				   -	       endif		; TMPMEMADDRESS > $1FFF
  10111  2768b					       endif		; EXTRADLMEMORY
  10112  2768b							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
  10113  2768b			22		       .byte.b	>TMPMEMADDRESS
  10114  2768b				    DLINDEX    SET	DLINDEX + 1
  10100  2768b					       REPEND
  10101  2768b				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10102  2768c				   -	       ifconst	EXTRADLMEMORY
  10103  2768c				   -	       if	TMPMEMADDRESS > $1FFF
  10104  2768c				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10105  2768c				   -	       else
  10106  2768c				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10107  2768c				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10108  2768c				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
  10109  2768c				   -	       endif
  10110  2768c				   -	       endif		; TMPMEMADDRESS > $1FFF
  10111  2768c					       endif		; EXTRADLMEMORY
  10112  2768c							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
  10113  2768c			22		       .byte.b	>TMPMEMADDRESS
  10114  2768c				    DLINDEX    SET	DLINDEX + 1
  10100  2768c					       REPEND
  10101  2768c				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10102  2768d				   -	       ifconst	EXTRADLMEMORY
  10103  2768d				   -	       if	TMPMEMADDRESS > $1FFF
  10104  2768d				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10105  2768d				   -	       else
  10106  2768d				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10107  2768d				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10108  2768d				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
  10109  2768d				   -	       endif
  10110  2768d				   -	       endif		; TMPMEMADDRESS > $1FFF
  10111  2768d					       endif		; EXTRADLMEMORY
  10112  2768d							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
  10113  2768d			23		       .byte.b	>TMPMEMADDRESS
  10114  2768d				    DLINDEX    SET	DLINDEX + 1
  10100  2768d					       REPEND
  10101  2768d				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10102  2768e				   -	       ifconst	EXTRADLMEMORY
  10103  2768e				   -	       if	TMPMEMADDRESS > $1FFF
  10104  2768e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10105  2768e				   -	       else
  10106  2768e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10107  2768e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10108  2768e				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
  10109  2768e				   -	       endif
  10110  2768e				   -	       endif		; TMPMEMADDRESS > $1FFF
  10111  2768e					       endif		; EXTRADLMEMORY
  10112  2768e							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
  10113  2768e			23		       .byte.b	>TMPMEMADDRESS
  10114  2768e				    DLINDEX    SET	DLINDEX + 1
  10100  2768e					       REPEND
  10101  2768e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10102  2768f				   -	       ifconst	EXTRADLMEMORY
  10103  2768f				   -	       if	TMPMEMADDRESS > $1FFF
  10104  2768f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10105  2768f				   -	       else
  10106  2768f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10107  2768f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10108  2768f				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
  10109  2768f				   -	       endif
  10110  2768f				   -	       endif		; TMPMEMADDRESS > $1FFF
  10111  2768f					       endif		; EXTRADLMEMORY
  10112  2768f							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
  10113  2768f			24		       .byte.b	>TMPMEMADDRESS
  10114  2768f				    DLINDEX    SET	DLINDEX + 1
  10100  2768f					       REPEND
  10101  2768f				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10102  27690				   -	       ifconst	EXTRADLMEMORY
  10103  27690				   -	       if	TMPMEMADDRESS > $1FFF
  10104  27690				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10105  27690				   -	       else
  10106  27690				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10107  27690				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10108  27690				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
  10109  27690				   -	       endif
  10110  27690				   -	       endif		; TMPMEMADDRESS > $1FFF
  10111  27690					       endif		; EXTRADLMEMORY
  10112  27690							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
  10113  27690			24		       .byte.b	>TMPMEMADDRESS
  10114  27690				    DLINDEX    SET	DLINDEX + 1
  10100  27690					       REPEND
  10101  27690				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10102  27691				   -	       ifconst	EXTRADLMEMORY
  10103  27691				   -	       if	TMPMEMADDRESS > $1FFF
  10104  27691				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10105  27691				   -	       else
  10106  27691				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10107  27691				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10108  27691				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
  10109  27691				   -	       endif
  10110  27691				   -	       endif		; TMPMEMADDRESS > $1FFF
  10111  27691					       endif		; EXTRADLMEMORY
  10112  27691							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
  10113  27691			25		       .byte.b	>TMPMEMADDRESS
  10114  27691				    DLINDEX    SET	DLINDEX + 1
  10100  27691					       REPEND
  10101  27691				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10102  27692				   -	       ifconst	EXTRADLMEMORY
  10103  27692				   -	       if	TMPMEMADDRESS > $1FFF
  10104  27692				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10105  27692				   -	       else
  10106  27692				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10107  27692				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10108  27692				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
  10109  27692				   -	       endif
  10110  27692				   -	       endif		; TMPMEMADDRESS > $1FFF
  10111  27692					       endif		; EXTRADLMEMORY
  10112  27692							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
  10113  27692			25		       .byte.b	>TMPMEMADDRESS
  10114  27692				    DLINDEX    SET	DLINDEX + 1
  10100  27692					       REPEND
  10101  27692				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10102  27693				   -	       ifconst	EXTRADLMEMORY
  10103  27693				   -	       if	TMPMEMADDRESS > $1FFF
  10104  27693				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10105  27693				   -	       else
  10106  27693				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10107  27693				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10108  27693				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
  10109  27693				   -	       endif
  10110  27693				   -	       endif		; TMPMEMADDRESS > $1FFF
  10111  27693					       endif		; EXTRADLMEMORY
  10112  27693							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
  10113  27693			25		       .byte.b	>TMPMEMADDRESS
  10114  27693				    DLINDEX    SET	DLINDEX + 1
  10100  27693					       REPEND
  10101  27693				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10102  27694				   -	       ifconst	EXTRADLMEMORY
  10103  27694				   -	       if	TMPMEMADDRESS > $1FFF
  10104  27694				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10105  27694				   -	       else
  10106  27694				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10107  27694				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10108  27694				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
  10109  27694				   -	       endif
  10110  27694				   -	       endif		; TMPMEMADDRESS > $1FFF
  10111  27694					       endif		; EXTRADLMEMORY
  10112  27694							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
  10113  27694			26		       .byte.b	>TMPMEMADDRESS
  10114  27694				    DLINDEX    SET	DLINDEX + 1
  10100  27694					       REPEND
  10101  27694				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10102  27695				   -	       ifconst	EXTRADLMEMORY
  10103  27695				   -	       if	TMPMEMADDRESS > $1FFF
  10104  27695				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10105  27695				   -	       else
  10106  27695				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10107  27695				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10108  27695				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
  10109  27695				   -	       endif
  10110  27695				   -	       endif		; TMPMEMADDRESS > $1FFF
  10111  27695					       endif		; EXTRADLMEMORY
  10112  27695							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
  10113  27695			26		       .byte.b	>TMPMEMADDRESS
  10114  27695				    DLINDEX    SET	DLINDEX + 1
  10100  27695					       REPEND
  10101  27695				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10102  27696				   -	       ifconst	EXTRADLMEMORY
  10103  27696				   -	       if	TMPMEMADDRESS > $1FFF
  10104  27696				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10105  27696				   -	       else
  10106  27696				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10107  27696				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10108  27696				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
  10109  27696				   -	       endif
  10110  27696				   -	       endif		; TMPMEMADDRESS > $1FFF
  10111  27696					       endif		; EXTRADLMEMORY
  10112  27696							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
  10113  27696			27		       .byte.b	>TMPMEMADDRESS
  10114  27696				    DLINDEX    SET	DLINDEX + 1
  10100  27696					       REPEND
  10101  27696				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10102  27697				   -	       ifconst	EXTRADLMEMORY
  10103  27697				   -	       if	TMPMEMADDRESS > $1FFF
  10104  27697				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10105  27697				   -	       else
  10106  27697				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10107  27697				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10108  27697				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
  10109  27697				   -	       endif
  10110  27697				   -	       endif		; TMPMEMADDRESS > $1FFF
  10111  27697					       endif		; EXTRADLMEMORY
  10112  27697							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
  10113  27697			27		       .byte.b	>TMPMEMADDRESS
  10114  27697				    DLINDEX    SET	DLINDEX + 1
  10115  27698					       REPEND
  10116  27698
  10117  27698				   -	       ifconst	EXTRADLMEMORY
  10118  27698				   -	       echo	"   ",[SECONDDLHALFSTART],"to",[$27FF],"was claimed as extra DL memory."
  10119  27698					       endif
  10120  27698
  10121  27698
  10122  27698				    DLPOINTL
  10123  27698				    DLINDEX    SET	0
  10124  27698					       REPEAT	WZONECOUNT
  10125  27698				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10126  27698				   -	       ifconst	EXTRADLMEMORY
  10127  27698				   -	       if	TMPMEMADDRESS > $1FFF
  10128  27698				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10129  27698				   -	       else
  10130  27698				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10131  27698				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10132  27698				   -	       endif
  10133  27698				   -	       endif		; TMPMEMADDRESS > $1FFF
  10134  27698					       endif		; EXTRADLMEMORY
  10135  27698			00		       .byte.b	<TMPMEMADDRESS
  10136  27698				    DLINDEX    SET	DLINDEX + 1
  10124  27698					       REPEND
  10125  27698				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10126  27699				   -	       ifconst	EXTRADLMEMORY
  10127  27699				   -	       if	TMPMEMADDRESS > $1FFF
  10128  27699				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10129  27699				   -	       else
  10130  27699				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10131  27699				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10132  27699				   -	       endif
  10133  27699				   -	       endif		; TMPMEMADDRESS > $1FFF
  10134  27699					       endif		; EXTRADLMEMORY
  10135  27699			6d		       .byte.b	<TMPMEMADDRESS
  10136  27699				    DLINDEX    SET	DLINDEX + 1
  10124  27699					       REPEND
  10125  27699				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10126  2769a				   -	       ifconst	EXTRADLMEMORY
  10127  2769a				   -	       if	TMPMEMADDRESS > $1FFF
  10128  2769a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10129  2769a				   -	       else
  10130  2769a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10131  2769a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10132  2769a				   -	       endif
  10133  2769a				   -	       endif		; TMPMEMADDRESS > $1FFF
  10134  2769a					       endif		; EXTRADLMEMORY
  10135  2769a			db		       .byte.b	<TMPMEMADDRESS
  10136  2769a				    DLINDEX    SET	DLINDEX + 1
  10124  2769a					       REPEND
  10125  2769a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10126  2769b				   -	       ifconst	EXTRADLMEMORY
  10127  2769b				   -	       if	TMPMEMADDRESS > $1FFF
  10128  2769b				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10129  2769b				   -	       else
  10130  2769b				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10131  2769b				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10132  2769b				   -	       endif
  10133  2769b				   -	       endif		; TMPMEMADDRESS > $1FFF
  10134  2769b					       endif		; EXTRADLMEMORY
  10135  2769b			49		       .byte.b	<TMPMEMADDRESS
  10136  2769b				    DLINDEX    SET	DLINDEX + 1
  10124  2769b					       REPEND
  10125  2769b				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10126  2769c				   -	       ifconst	EXTRADLMEMORY
  10127  2769c				   -	       if	TMPMEMADDRESS > $1FFF
  10128  2769c				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10129  2769c				   -	       else
  10130  2769c				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10131  2769c				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10132  2769c				   -	       endif
  10133  2769c				   -	       endif		; TMPMEMADDRESS > $1FFF
  10134  2769c					       endif		; EXTRADLMEMORY
  10135  2769c			b6		       .byte.b	<TMPMEMADDRESS
  10136  2769c				    DLINDEX    SET	DLINDEX + 1
  10124  2769c					       REPEND
  10125  2769c				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10126  2769d				   -	       ifconst	EXTRADLMEMORY
  10127  2769d				   -	       if	TMPMEMADDRESS > $1FFF
  10128  2769d				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10129  2769d				   -	       else
  10130  2769d				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10131  2769d				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10132  2769d				   -	       endif
  10133  2769d				   -	       endif		; TMPMEMADDRESS > $1FFF
  10134  2769d					       endif		; EXTRADLMEMORY
  10135  2769d			24		       .byte.b	<TMPMEMADDRESS
  10136  2769d				    DLINDEX    SET	DLINDEX + 1
  10124  2769d					       REPEND
  10125  2769d				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10126  2769e				   -	       ifconst	EXTRADLMEMORY
  10127  2769e				   -	       if	TMPMEMADDRESS > $1FFF
  10128  2769e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10129  2769e				   -	       else
  10130  2769e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10131  2769e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10132  2769e				   -	       endif
  10133  2769e				   -	       endif		; TMPMEMADDRESS > $1FFF
  10134  2769e					       endif		; EXTRADLMEMORY
  10135  2769e			92		       .byte.b	<TMPMEMADDRESS
  10136  2769e				    DLINDEX    SET	DLINDEX + 1
  10124  2769e					       REPEND
  10125  2769e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10126  2769f				   -	       ifconst	EXTRADLMEMORY
  10127  2769f				   -	       if	TMPMEMADDRESS > $1FFF
  10128  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10129  2769f				   -	       else
  10130  2769f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10131  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10132  2769f				   -	       endif
  10133  2769f				   -	       endif		; TMPMEMADDRESS > $1FFF
  10134  2769f					       endif		; EXTRADLMEMORY
  10135  2769f			00		       .byte.b	<TMPMEMADDRESS
  10136  2769f				    DLINDEX    SET	DLINDEX + 1
  10124  2769f					       REPEND
  10125  2769f				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10126  276a0				   -	       ifconst	EXTRADLMEMORY
  10127  276a0				   -	       if	TMPMEMADDRESS > $1FFF
  10128  276a0				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10129  276a0				   -	       else
  10130  276a0				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10131  276a0				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10132  276a0				   -	       endif
  10133  276a0				   -	       endif		; TMPMEMADDRESS > $1FFF
  10134  276a0					       endif		; EXTRADLMEMORY
  10135  276a0			6d		       .byte.b	<TMPMEMADDRESS
  10136  276a0				    DLINDEX    SET	DLINDEX + 1
  10124  276a0					       REPEND
  10125  276a0				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10126  276a1				   -	       ifconst	EXTRADLMEMORY
  10127  276a1				   -	       if	TMPMEMADDRESS > $1FFF
  10128  276a1				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10129  276a1				   -	       else
  10130  276a1				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10131  276a1				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10132  276a1				   -	       endif
  10133  276a1				   -	       endif		; TMPMEMADDRESS > $1FFF
  10134  276a1					       endif		; EXTRADLMEMORY
  10135  276a1			db		       .byte.b	<TMPMEMADDRESS
  10136  276a1				    DLINDEX    SET	DLINDEX + 1
  10124  276a1					       REPEND
  10125  276a1				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10126  276a2				   -	       ifconst	EXTRADLMEMORY
  10127  276a2				   -	       if	TMPMEMADDRESS > $1FFF
  10128  276a2				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10129  276a2				   -	       else
  10130  276a2				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10131  276a2				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10132  276a2				   -	       endif
  10133  276a2				   -	       endif		; TMPMEMADDRESS > $1FFF
  10134  276a2					       endif		; EXTRADLMEMORY
  10135  276a2			49		       .byte.b	<TMPMEMADDRESS
  10136  276a2				    DLINDEX    SET	DLINDEX + 1
  10124  276a2					       REPEND
  10125  276a2				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10126  276a3				   -	       ifconst	EXTRADLMEMORY
  10127  276a3				   -	       if	TMPMEMADDRESS > $1FFF
  10128  276a3				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10129  276a3				   -	       else
  10130  276a3				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10131  276a3				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10132  276a3				   -	       endif
  10133  276a3				   -	       endif		; TMPMEMADDRESS > $1FFF
  10134  276a3					       endif		; EXTRADLMEMORY
  10135  276a3			b6		       .byte.b	<TMPMEMADDRESS
  10136  276a3				    DLINDEX    SET	DLINDEX + 1
  10124  276a3					       REPEND
  10125  276a3				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10126  276a4				   -	       ifconst	EXTRADLMEMORY
  10127  276a4				   -	       if	TMPMEMADDRESS > $1FFF
  10128  276a4				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10129  276a4				   -	       else
  10130  276a4				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10131  276a4				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10132  276a4				   -	       endif
  10133  276a4				   -	       endif		; TMPMEMADDRESS > $1FFF
  10134  276a4					       endif		; EXTRADLMEMORY
  10135  276a4			24		       .byte.b	<TMPMEMADDRESS
  10136  276a4				    DLINDEX    SET	DLINDEX + 1
  10124  276a4					       REPEND
  10125  276a4				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10126  276a5				   -	       ifconst	EXTRADLMEMORY
  10127  276a5				   -	       if	TMPMEMADDRESS > $1FFF
  10128  276a5				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10129  276a5				   -	       else
  10130  276a5				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10131  276a5				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10132  276a5				   -	       endif
  10133  276a5				   -	       endif		; TMPMEMADDRESS > $1FFF
  10134  276a5					       endif		; EXTRADLMEMORY
  10135  276a5			92		       .byte.b	<TMPMEMADDRESS
  10136  276a5				    DLINDEX    SET	DLINDEX + 1
  10137  276a6					       REPEND
  10138  276a6
  10139  276a6
  10140  276a6				    DLINDEX    SET	0
  10141  276a6					       REPEAT	WZONECOUNT
  10142  276a6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10143  276a6				   -	       ifconst	EXTRADLMEMORY
  10144  276a6				   -	       if	TMPMEMADDRESS > $1FFF
  10145  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10146  276a6				   -	       else
  10147  276a6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10148  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10149  276a6				   -	       endif
  10150  276a6				   -	       endif		; TMPMEMADDRESS > $1FFF
  10151  276a6					       endif		; EXTRADLMEMORY
  10152  276a6
  10153  276a6			22 00	    ZONE0ADDRESS =	TMPMEMADDRESS
  10154  276a6
  10155  276a6				    DLINDEX    SET	DLINDEX + 1
  10141  276a6					       REPEND
  10142  276a6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10143  276a6				   -	       ifconst	EXTRADLMEMORY
  10144  276a6				   -	       if	TMPMEMADDRESS > $1FFF
  10145  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10146  276a6				   -	       else
  10147  276a6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10148  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10149  276a6				   -	       endif
  10150  276a6				   -	       endif		; TMPMEMADDRESS > $1FFF
  10151  276a6					       endif		; EXTRADLMEMORY
  10152  276a6
  10153  276a6			22 6d	    ZONE1ADDRESS =	TMPMEMADDRESS
  10154  276a6
  10155  276a6				    DLINDEX    SET	DLINDEX + 1
  10141  276a6					       REPEND
  10142  276a6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10143  276a6				   -	       ifconst	EXTRADLMEMORY
  10144  276a6				   -	       if	TMPMEMADDRESS > $1FFF
  10145  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10146  276a6				   -	       else
  10147  276a6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10148  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10149  276a6				   -	       endif
  10150  276a6				   -	       endif		; TMPMEMADDRESS > $1FFF
  10151  276a6					       endif		; EXTRADLMEMORY
  10152  276a6
  10153  276a6			22 db	    ZONE2ADDRESS =	TMPMEMADDRESS
  10154  276a6
  10155  276a6				    DLINDEX    SET	DLINDEX + 1
  10141  276a6					       REPEND
  10142  276a6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10143  276a6				   -	       ifconst	EXTRADLMEMORY
  10144  276a6				   -	       if	TMPMEMADDRESS > $1FFF
  10145  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10146  276a6				   -	       else
  10147  276a6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10148  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10149  276a6				   -	       endif
  10150  276a6				   -	       endif		; TMPMEMADDRESS > $1FFF
  10151  276a6					       endif		; EXTRADLMEMORY
  10152  276a6
  10153  276a6			23 49	    ZONE3ADDRESS =	TMPMEMADDRESS
  10154  276a6
  10155  276a6				    DLINDEX    SET	DLINDEX + 1
  10141  276a6					       REPEND
  10142  276a6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10143  276a6				   -	       ifconst	EXTRADLMEMORY
  10144  276a6				   -	       if	TMPMEMADDRESS > $1FFF
  10145  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10146  276a6				   -	       else
  10147  276a6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10148  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10149  276a6				   -	       endif
  10150  276a6				   -	       endif		; TMPMEMADDRESS > $1FFF
  10151  276a6					       endif		; EXTRADLMEMORY
  10152  276a6
  10153  276a6			23 b6	    ZONE4ADDRESS =	TMPMEMADDRESS
  10154  276a6
  10155  276a6				    DLINDEX    SET	DLINDEX + 1
  10141  276a6					       REPEND
  10142  276a6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10143  276a6				   -	       ifconst	EXTRADLMEMORY
  10144  276a6				   -	       if	TMPMEMADDRESS > $1FFF
  10145  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10146  276a6				   -	       else
  10147  276a6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10148  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10149  276a6				   -	       endif
  10150  276a6				   -	       endif		; TMPMEMADDRESS > $1FFF
  10151  276a6					       endif		; EXTRADLMEMORY
  10152  276a6
  10153  276a6			24 24	    ZONE5ADDRESS =	TMPMEMADDRESS
  10154  276a6
  10155  276a6				    DLINDEX    SET	DLINDEX + 1
  10141  276a6					       REPEND
  10142  276a6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10143  276a6				   -	       ifconst	EXTRADLMEMORY
  10144  276a6				   -	       if	TMPMEMADDRESS > $1FFF
  10145  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10146  276a6				   -	       else
  10147  276a6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10148  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10149  276a6				   -	       endif
  10150  276a6				   -	       endif		; TMPMEMADDRESS > $1FFF
  10151  276a6					       endif		; EXTRADLMEMORY
  10152  276a6
  10153  276a6			24 92	    ZONE6ADDRESS =	TMPMEMADDRESS
  10154  276a6
  10155  276a6				    DLINDEX    SET	DLINDEX + 1
  10141  276a6					       REPEND
  10142  276a6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10143  276a6				   -	       ifconst	EXTRADLMEMORY
  10144  276a6				   -	       if	TMPMEMADDRESS > $1FFF
  10145  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10146  276a6				   -	       else
  10147  276a6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10148  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10149  276a6				   -	       endif
  10150  276a6				   -	       endif		; TMPMEMADDRESS > $1FFF
  10151  276a6					       endif		; EXTRADLMEMORY
  10152  276a6
  10153  276a6			25 00	    ZONE7ADDRESS =	TMPMEMADDRESS
  10154  276a6
  10155  276a6				    DLINDEX    SET	DLINDEX + 1
  10141  276a6					       REPEND
  10142  276a6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10143  276a6				   -	       ifconst	EXTRADLMEMORY
  10144  276a6				   -	       if	TMPMEMADDRESS > $1FFF
  10145  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10146  276a6				   -	       else
  10147  276a6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10148  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10149  276a6				   -	       endif
  10150  276a6				   -	       endif		; TMPMEMADDRESS > $1FFF
  10151  276a6					       endif		; EXTRADLMEMORY
  10152  276a6
  10153  276a6			25 6d	    ZONE8ADDRESS =	TMPMEMADDRESS
  10154  276a6
  10155  276a6				    DLINDEX    SET	DLINDEX + 1
  10141  276a6					       REPEND
  10142  276a6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10143  276a6				   -	       ifconst	EXTRADLMEMORY
  10144  276a6				   -	       if	TMPMEMADDRESS > $1FFF
  10145  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10146  276a6				   -	       else
  10147  276a6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10148  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10149  276a6				   -	       endif
  10150  276a6				   -	       endif		; TMPMEMADDRESS > $1FFF
  10151  276a6					       endif		; EXTRADLMEMORY
  10152  276a6
  10153  276a6			25 db	    ZONE9ADDRESS =	TMPMEMADDRESS
  10154  276a6
  10155  276a6				    DLINDEX    SET	DLINDEX + 1
  10141  276a6					       REPEND
  10142  276a6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10143  276a6				   -	       ifconst	EXTRADLMEMORY
  10144  276a6				   -	       if	TMPMEMADDRESS > $1FFF
  10145  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10146  276a6				   -	       else
  10147  276a6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10148  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10149  276a6				   -	       endif
  10150  276a6				   -	       endif		; TMPMEMADDRESS > $1FFF
  10151  276a6					       endif		; EXTRADLMEMORY
  10152  276a6
  10153  276a6			26 49	    ZONE10ADDRESS =	TMPMEMADDRESS
  10154  276a6
  10155  276a6				    DLINDEX    SET	DLINDEX + 1
  10141  276a6					       REPEND
  10142  276a6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10143  276a6				   -	       ifconst	EXTRADLMEMORY
  10144  276a6				   -	       if	TMPMEMADDRESS > $1FFF
  10145  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10146  276a6				   -	       else
  10147  276a6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10148  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10149  276a6				   -	       endif
  10150  276a6				   -	       endif		; TMPMEMADDRESS > $1FFF
  10151  276a6					       endif		; EXTRADLMEMORY
  10152  276a6
  10153  276a6			26 b6	    ZONE11ADDRESS =	TMPMEMADDRESS
  10154  276a6
  10155  276a6				    DLINDEX    SET	DLINDEX + 1
  10141  276a6					       REPEND
  10142  276a6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10143  276a6				   -	       ifconst	EXTRADLMEMORY
  10144  276a6				   -	       if	TMPMEMADDRESS > $1FFF
  10145  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10146  276a6				   -	       else
  10147  276a6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10148  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10149  276a6				   -	       endif
  10150  276a6				   -	       endif		; TMPMEMADDRESS > $1FFF
  10151  276a6					       endif		; EXTRADLMEMORY
  10152  276a6
  10153  276a6			27 24	    ZONE12ADDRESS =	TMPMEMADDRESS
  10154  276a6
  10155  276a6				    DLINDEX    SET	DLINDEX + 1
  10141  276a6					       REPEND
  10142  276a6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
  10143  276a6				   -	       ifconst	EXTRADLMEMORY
  10144  276a6				   -	       if	TMPMEMADDRESS > $1FFF
  10145  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10146  276a6				   -	       else
  10147  276a6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
  10148  276a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
  10149  276a6				   -	       endif
  10150  276a6				   -	       endif		; TMPMEMADDRESS > $1FFF
  10151  276a6					       endif		; EXTRADLMEMORY
  10152  276a6
  10153  276a6			27 92	    ZONE13ADDRESS =	TMPMEMADDRESS
  10154  276a6
  10155  276a6				    DLINDEX    SET	DLINDEX + 1
  10156  276a6					       REPEND
  10157  276a6
  10158  276a6
     $2200 to $27ff used as zone memory, allowing 10 display objects per zone.
  10159  276a6					       echo	"   ",[WDLMEMSTART],"to",[WDLMEMEND],"used as zone memory, allowing",[(DLLASTOBJ/5)]d,"display objects per zone."
  10160  276a6
  10161  276a6				    DLHEIGHT
  10162  276a6					       REPEAT	WZONECOUNT
  10163  276a6			0f		       .byte.b	(WZONEHEIGHT-1)
  10162  276a6					       REPEND
  10163  276a7			0f		       .byte.b	(WZONEHEIGHT-1)
  10162  276a7					       REPEND
  10163  276a8			0f		       .byte.b	(WZONEHEIGHT-1)
  10162  276a8					       REPEND
  10163  276a9			0f		       .byte.b	(WZONEHEIGHT-1)
  10162  276a9					       REPEND
  10163  276aa			0f		       .byte.b	(WZONEHEIGHT-1)
  10162  276aa					       REPEND
  10163  276ab			0f		       .byte.b	(WZONEHEIGHT-1)
  10162  276ab					       REPEND
  10163  276ac			0f		       .byte.b	(WZONEHEIGHT-1)
  10162  276ac					       REPEND
  10163  276ad			0f		       .byte.b	(WZONEHEIGHT-1)
  10162  276ad					       REPEND
  10163  276ae			0f		       .byte.b	(WZONEHEIGHT-1)
  10162  276ae					       REPEND
  10163  276af			0f		       .byte.b	(WZONEHEIGHT-1)
  10162  276af					       REPEND
  10163  276b0			0f		       .byte.b	(WZONEHEIGHT-1)
  10162  276b0					       REPEND
  10163  276b1			0f		       .byte.b	(WZONEHEIGHT-1)
  10162  276b1					       REPEND
  10163  276b2			0f		       .byte.b	(WZONEHEIGHT-1)
  10162  276b2					       REPEND
  10163  276b3			0f		       .byte.b	(WZONEHEIGHT-1)
  10164  276b4					       REPEND
  10165  276b4
  10166  276b4							; Provided under the CC0 license. See the included LICENSE.txt for details.
  10167  276b4
  10168  276b4							; a simple guard, than ensures the 7800basic code hasn't
  10169  276b4							; spilled into the encryption area...
     2250 bytes left in the 7800basic reserved area.
  10170  276b4					       echo	"   ",($FF7E-*)d,"bytes left in the 7800basic reserved area."
  10171  276b4				   -	       if	(*>$FF7D)
  10172  276b4				   -	       ERR		; abort the assembly
  10173  276b4					       endif
  10174  276b4							; Provided under the CC0 license. See the included LICENSE.txt for details.
  10175  276b4
  10176  276b4				   -	       ifconst	DEV
  10177  276b4				   -	       ifnconst	ZONEHEIGHT
  10178  276b4				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
  10179  276b4				   -	       else
  10180  276b4				   -	       if	ZONEHEIGHT = 8
  10181  276b4				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
  10182  276b4				   -	       else
  10183  276b4				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
  10184  276b4				   -	       endif
  10185  276b4				   -	       endif
  10186  276b4					       endif
  10187  276b4
  10188  276b4							; FF7E/FF7F contains the 7800basic crc checksum word
  10189  276b4
  10190  276b4							; FF80 - FFF7 contains the 7800 encryption key 
  10191  276b4
  10192  276b4				   -	       ifnconst	bankswitchmode
  10193  276b4				   -	       ORG	$FFF8
  10194  276b4					       else
  10195  276b4					       ifconst	ROM128K
  10196  27ff8					       ORG	$27FF8
  10197  27ff8					       RORG	$FFF8
  10198  27ff8					       endif
  10199  27ff8				   -	       ifconst	ROM144K
  10200  27ff8				   -	       ORG	$27FF8
  10201  27ff8				   -	       RORG	$FFF8
  10202  27ff8					       endif
  10203  27ff8				   -	       ifconst	ROM256K
  10204  27ff8				   -	       ORG	$47FF8
  10205  27ff8				   -	       RORG	$FFF8
  10206  27ff8					       endif
  10207  27ff8				   -	       ifconst	ROM272K
  10208  27ff8				   -	       ORG	$47FF8
  10209  27ff8				   -	       RORG	$FFF8
  10210  27ff8					       endif
  10211  27ff8				   -	       ifconst	ROM512K
  10212  27ff8				   -	       ORG	$87FF8
  10213  27ff8				   -	       RORG	$FFF8
  10214  27ff8					       endif
  10215  27ff8				   -	       ifconst	ROM528K
  10216  27ff8				   -	       ORG	$87FF8
  10217  27ff8				   -	       RORG	$FFF8
  10218  27ff8					       endif
  10219  27ff8					       endif
  10220  27ff8
  10221  27ff8
  10222  27ff8			ff		       .byte.b	$FF	; region verification. $FF=all regions
  10223  27ff9			f7		       .byte.b	$F7	; high nibble:  encryption check from $N000 to $FF7F. we only hash the last 4k for faster boot.
  10224  27ffa							; low nibble :  N=7 atari rainbow start, N=3 no atari rainbow
  10225  27ffa
  10226  27ffa							;Vectors
  10227  27ffa			00 f0		       .word.w	NMI
  10228  27ffc			07 f6		       .word.w	START
  10229  27ffe			67 f0		       .word.w	IRQ
  10230  28000
